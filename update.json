{
  "update": [
    {
      "path": "plugins/ai/tofigure.js",
      "code": "/* CODE LAIN CHEK\nhttps://whatsapp.com/channel/0029VbARSvBCMY0PDV53rt0m\nJANGAN LUPA FOLLOW\n*/\n\n/* CODE LAIN CHEK\nhttps://whatsapp.com/channel/0029VbARSvBCMY0PDV53rt0m\nJANGAN LUPA FOLLOW\n*/\n\n// CREATE BY REZA DEVS KUROMI\nlet fetch = require(\\\"node-fetch\\\");\nlet FormData = require(\\\"form-data\\\");\nlet { fromBuffer } = require(\\\"file-type\\\");\nlet axios = require(\\\"axios\\\");\n\nexports.run = {\n    usage: [\\\"tofigure\\\", \\\"stylefigure\\\"],\n    hidden: [\\\"tfigure\\\"],\n    use: \\\"command + kirim gambar / reply gambar\\\",\n    category: \\\"ai\\\",\n\n    async: async (m, { kuromi, quoted }) => {\n        try {\n            if (!quoted || !/image/.test(quoted.mime))\n                return m.reply(\\\"Reply gambar atau kirim gambar dengan command.\\\");\n\n            kuromi.sendReact(m.chat, \\\"ðŸ•’\\\", m.key);\n\n            // ===============================\n            // DOWNLOAD IMAGE\n            // ===============================\n            let buffer = await quoted.download();\n            if (!buffer) throw \\\"Gagal download gambar.\\\";\n\n            let type = await fromBuffer(buffer);\n            let ext = type?.ext || \\\"jpg\\\";\n\n            // ===============================\n            // UPLOAD KE CATBOX\n            // ===============================\n            let form = new FormData();\n            form.append(\\\"fileToUpload\\\", buffer, \\\"file.\\\" + ext);\n            form.append(\\\"reqtype\\\", \\\"fileupload\\\");\n\n            let imageUrl = await (\n                await fetch(\\\"https://catbox.moe/user/api.php\\\", {\n                    method: \\\"POST\\\",\n                    body: form\n                })\n            ).text();\n\n            if (!/^https?:\\/\\//.test(imageUrl))\n                throw \\\"Gagal upload ke catbox.\\\";\n\n            // ===============================\n            // CALL API NEKOLABS (POST JSON)\n            // ===============================\n            let { data } = await axios.post(\n                \\\"https://api.nekolabs.web.id/style-changer/figure\\\",\n                { imageUrl },\n                { headers: { \\\"Content-Type\\\": \\\"application/json\\\" }, timeout: 120000 }\n            );\n\n            if (!data || !data.success || !data.result)\n                throw \\\"API gagal memproses gambar.\\\";\n\n            // ===============================\n            // SEND RESULT\n            // ===============================\n            await kuromi.sendMessage(\n                m.chat,\n                {\n                    image: { url: data.result },\n                    caption:\n                        `âœ¨ *To Figure Success*\\n` +\n                        `â± ${data.responseTime || \\\"-\\\"}`\n                },\n                { quoted: m }\n            );\n\n            kuromi.sendReact(m.chat, \\\"âœ…\\\", m.key);\n\n        } catch (e) {\n            console.error(e);\n            kuromi.sendReact(m.chat, \\\"âŒ\\\", m.key);\n            m.reply(\\\"âŒ Gagal convert ke figure.\\\");\n        }\n    },\n\n    location: \\\"plugins/ai/tofigure.js\\\"\n};",
      "time": "2025-12-16 16:09:40"
    },
    {
      "path": "plugins/convert/stickermeme.js",
      "code": "/* CODE LAIN CHEK\nhttps://whatsapp.com/channel/0029VbARSvBCMY0PDV53rt0m\nJANGAN LUPA FOLLOW\n*/\n\n// CREATE BY REZA DEVS KUROMI (UPDATED NEKOLABS)\n\nconst axios = require(\\\"axios\\\");\nconst FormData = require(\\\"form-data\\\");\nconst { fromBuffer } = require(\\\"file-type\\\");\n\n// ===============================\n// UPLOAD IMAGE KE TMPFILES\n// ===============================\nasync function uploadTmp(buffer) {\n    const { ext, mime } = await fromBuffer(buffer) || {};\n    const form = new FormData();\n\n    form.append(\\\"file\\\", buffer, {\n        filename: `image.${ext}`,\n        contentType: mime\n    });\n\n    const res = await axios.post(\n        \\\"https://tmpfiles.org/api/v1/upload\\\",\n        form,\n        { headers: form.getHeaders() }\n    );\n\n    return \\\"https://tmpfiles.org/dl/\\\" +\n        res.data.data.url.split(\\\"tmpfiles.org/\\\")[1];\n}\n\nexports.run = {\n    usage: [\\\"stickermeme\\\"],\n    hidden: [\\\"smeme\\\"],\n    use: \\\"text atas | text bawah\\\",\n    category: \\\"convert\\\",\n    limit: 5,\n    restrict: true,\n    location: \\\"plugins/convert/stickermeme.js\\\",\n\n    async: async (m, { kuromi, quoted, func, packname, author }) => {\n\n        if (!m.text)\n            return m.reply(func.example(m.cmd, \\\"Malas | Menanggapi\\\"));\n\n        if (m.text.length > 75)\n            return m.reply(\\\"Text terlalu panjang.\\\");\n\n        let textT = \\\"-\\\";\n        let textB = \\\"\\\";\n\n        if (m.text.includes(\\\"|\\\")) {\n            let split = m.text.split(\\\"|\\\");\n            textT = split[0]?.trim() || \\\"-\\\";\n            textB = split[1]?.trim() || \\\"\\\";\n        } else {\n            textT = m.text.trim();\n        }\n\n        if (!quoted || !/image\\/(jpe?g|png|webp)/.test(quoted.mime))\n            return m.reply(`Kirim atau reply gambar dengan caption:\\n${m.cmd} text atas | text bawah`);\n\n        if (quoted.mime.includes(\\\"webp\\\") && quoted.isAnimated)\n            return m.reply(\\\"Sticker GIF tidak didukung.\\\");\n\n        kuromi.sendReact(m.chat, \\\"ðŸ•’\\\", m.key);\n\n        // ===============================\n        // DOWNLOAD & UPLOAD IMAGE\n        // ===============================\n        const buffer = await quoted.download();\n        const imageUrl = await uploadTmp(buffer);\n\n        // ===============================\n        // REQUEST KE NEKOLABS\n        // ===============================\n        const meme = await axios.post(\n            \\\"https://api.nekolabs.web.id/canvas/meme\\\",\n            {\n                imageUrl,\n                textT,\n                textB\n            },\n            {\n                responseType: \\\"arraybuffer\\\",\n                headers: {\n                    \\\"Content-Type\\\": \\\"application/json\\\"\n                }\n            }\n        );\n\n        // ===============================\n        // KIRIM STICKER\n        // ===============================\n        await kuromi.sendSticker(\n            m.chat,\n            meme.data,\n            m,\n            {\n                packname,\n                author,\n                expiration: m.expiration\n            }\n        );\n    }\n};",
      "time": "2025-12-17 11:14:16"
    },
    {
      "path": "plugins/convert/quickchat.js",
      "code": "/* CODE LAIN CHEK\nhttps://whatsapp.com/channel/0029VbARSvBCMY0PDV53rt0m\nJANGAN LUPA FOLLOW\n*/\n\n// CREATE BY REZA DEVS KUROMI (UPDATED NEKOLABS)\n\nconst axios = require(\\\"axios\\\");\n\nexports.run = {\n    usage: [\\\"quickchat\\\", \\\"quickchat2\\\", \\\"quickchat3\\\", \\\"quickchat4\\\"],\n    hidden: [\\\"qc\\\", \\\"qc2\\\", \\\"qc3\\\", \\\"qc4\\\"],\n    use: \\\"text / reply text\\\",\n    category: \\\"convert\\\",\n    restrict: true,\n    limit: true,\n    location: \\\"plugins/convert/quickchat.js\\\",\n\n    async: async (m, { kuromi, func, packname, author }) => {\n\n        let text;\n        if (m.args.length) {\n            text = m.args.join(\\\" \\\");\n        } else if (m.quoted?.text) {\n            text = m.quoted.text;\n        }\n\n        if (!text)\n            return m.reply(\\\"Input atau reply text!\\\");\n\n        if (text.length > 50)\n            return m.reply(\\\"Max 50 character!\\\");\n\n        kuromi.sendReact(m.chat, \\\"ðŸ•’\\\", m.key);\n\n        // ===============================\n        // WARNA BERDASARKAN COMMAND\n        // ===============================\n        let color = \\\"#333\\\";\n        if (/^(quickchat|qc)$/.test(m.command)) color = \\\"#CCFFFF\\\";\n        if (/^(quickchat2|qc2)$/.test(m.command)) color = \\\"#000000\\\";\n        if (/^(quickchat3|qc3)$/.test(m.command)) color = \\\"#999999\\\";\n        if (/^(quickchat4|qc4)$/.test(m.command)) color = \\\"#FF9999\\\";\n\n        try {\n            // ===============================\n            // DATA USER\n            // ===============================\n            const sender = m.quoted?.sender || m.sender;\n            const name = m.quoted\n                ? global.db.users[sender]?.name || m.pushname\n                : m.pushname;\n\n            const profile = await kuromi\n                .profilePictureUrl(sender, \\\"image\\\")\n                .catch(() => \\\"https://api.nekolabs.web.id/ali-oss/v1/example.jpg\\\");\n\n            // ===============================\n            // REQUEST KE NEKOLABS\n            // ===============================\n            const res = await axios.post(\n                \\\"https://api.nekolabs.web.id/canvas/quote-chat\\\",\n                {\n                    text,\n                    name,\n                    profile,\n                    color\n                },\n                {\n                    responseType: \\\"arraybuffer\\\",\n                    headers: {\n                        \\\"Content-Type\\\": \\\"application/json\\\"\n                    }\n                }\n            );\n\n            const buffer = Buffer.from(res.data);\n\n            // ===============================\n            // KIRIM STICKER\n            // ===============================\n            if (m.isPrem || global.devs.includes(m.bot)) {\n                await kuromi.sendSticker(\n                    m.chat,\n                    buffer,\n                    m,\n                    { packname, author, expiration: m.expiration }\n                );\n            } else {\n                await kuromi.sendSticker(\n                    \\\"120363297379900975@newsletter\\\",\n                    buffer,\n                    null,\n                    { packname, author, expiration: 0 }\n                );\n                await kuromi.reply(\n                    m.chat,\n                    \\\"Done icikbos ðŸ¦ ambil di channel:\\nhttps://whatsapp.com/channel/0029VaffATRADTOF2RzVrA1E\\\",\n                    m,\n                    { expiration: m.expiration }\n                );\n            }\n\n        } catch (err) {\n            console.log(err);\n            kuromi.reply(m.chat, err.message, m, { expiration: m.expiration });\n        }\n    }\n};",
      "time": "2025-12-17 11:15:06"
    },
    {
      "path": "plugins/ai/tochibi.js",
      "code": "/* CODE LAIN CHEK\nhttps://whatsapp.com/channel/0029VbARSvBCMY0PDV53rt0m\nJANGAN LUPA FOLLOW\n*/\n\n// CREATE BY REZA DEVS KUROMI\nconst fetch = require(\\\"node-fetch\\\");\nconst FormData = require(\\\"form-data\\\");\nconst { fromBuffer } = require(\\\"file-type\\\");\nconst axios = require(\\\"axios\\\");\n\nconst UA =\n  \\\"Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Mobile Safari/537.36\\\";\nconst REFERER =\n  \\\"https://notegpt.io/ai-image-editor?s=8fcceeac-de70-4dd5-bf91-e8d9237a0513\\\";\n\n// SIGN & T DIAMBIL SESUAI CONTOH (STATIS)\nconst SIGN = \\\"b13e8d1834bff51e0827802a354c66c787b92dd552cc15deccaaf385e5b2c23d\\\";\nconst T = 1766447857;\n\nexports.run = {\n  usage: [\\\"tochibi\\\", \\\"stickerchibi\\\"],\n  hidden: [\\\"tcibi\\\"],\n  use: \\\"reply / kirim gambar\\\",\n  category: \\\"ai\\\",\n\n  async: async (m, { kuromi, quoted }) => {\n    try {\n      if (!quoted || !/image/.test(quoted.mime))\n        return m.reply(\\\"Reply gambar atau kirim gambar dengan command.\\\");\n\n      kuromi.sendReact(m.chat, \\\"ðŸ•’\\\", m.key);\n\n      // ===============================\n      // DOWNLOAD IMAGE\n      // ===============================\n      let buffer = await quoted.download();\n      if (!buffer) throw \\\"Gagal download gambar.\\\";\n\n      let type = await fromBuffer(buffer);\n      let ext = type?.ext || \\\"jpg\\\";\n\n      // ===============================\n      // UPLOAD KE CATBOX\n      // ===============================\n      let form = new FormData();\n      form.append(\\\"fileToUpload\\\", buffer, \\\"file.\\\" + ext);\n      form.append(\\\"reqtype\\\", \\\"fileupload\\\");\n\n      let imageUrl = await (\n        await fetch(\\\"https://catbox.moe/user/api.php\\\", {\n          method: \\\"POST\\\",\n          body: form\n        })\n      ).text();\n\n      if (!/^https?:\\/\\//.test(imageUrl))\n        throw \\\"Gagal upload ke catbox.\\\";\n\n      // ===============================\n      // PROMPT CHIBI\n      // ===============================\n      const prompt =\n        \\\"Turn this image into a set of 1 chibi sticker (in a 4x4 grid) \\\" +\n        \\\"with clothing similar to the one in this image. \\\" +\n        \\\"Include expressions: laughing, angry, crying, pouting, thinking, sleepy, \\\" +\n        \\\"blowing a kiss, winking, and surprised\\\";\n\n      // ===============================\n      // START GENERATION\n      // ===============================\n      let startRes = await axios.post(\n        \\\"https://notegpt.io/api/v2/images/start\\\",\n        {\n          image_urls: [imageUrl],\n          type: 60,\n          user_prompt: prompt,\n          aspect_ratio: \\\"match_input_image\\\",\n          num: 1,\n          model: \\\"\\\",\n          sub_type: 3,\n          upscale: 2,\n          resolution: \\\"2k\\\",\n          sign: SIGN,\n          t: T\n        },\n        {\n          headers: {\n            Accept: \\\"application/json, text/plain, */*\\\",\n            \\\"Content-Type\\\": \\\"application/json; charset=UTF-8\\\",\n            \\\"User-Agent\\\": UA,\n            Referer: REFERER\n          },\n          timeout: 60000\n        }\n      );\n\n      if (\n        !startRes.data ||\n        startRes.data.code !== 100000 ||\n        !startRes.data.data?.session_id\n      ) {\n        throw \\\"Gagal memulai proses AI.\\\";\n      }\n\n      const sessionId = startRes.data.data.session_id;\n\n      // ===============================\n      // POLLING STATUS\n      // ===============================\n      let resultUrl = null;\n      for (let i = 0; i < 30; i++) {\n        await new Promise(r => setTimeout(r, 3000));\n\n        let statusRes = await axios.get(\n          \\\"https://notegpt.io/api/v2/images/status\\\",\n          {\n            params: { session_id: sessionId },\n            headers: {\n              Accept: \\\"application/json, text/plain, */*\\\",\n              \\\"User-Agent\\\": UA,\n              Referer: REFERER\n            },\n            timeout: 30000\n          }\n        );\n\n        let data = statusRes.data?.data;\n        let res0 = data?.results?.[0];\n\n        if (res0?.status === \\\"succeeded\\\" && res0?.url) {\n          resultUrl = res0.url;\n          break;\n        }\n\n        if (res0?.status === \\\"failed\\\") {\n          throw \\\"Proses AI gagal.\\\";\n        }\n      }\n\n      if (!resultUrl) throw \\\"Timeout menunggu hasil AI.\\\";\n\n      // ===============================\n      // SEND RESULT\n      // ===============================\n      await kuromi.sendMessage(\n        m.chat,\n        {\n          image: { url: resultUrl },\n          caption: \\\"âœ¨ NIH UDAH JADI CHIBI\\\"\n        },\n        { quoted: m }\n      );\n\n      kuromi.sendReact(m.chat, \\\"âœ…\\\", m.key);\n\n    } catch (e) {\n      console.error(e);\n      kuromi.sendReact(m.chat, \\\"âŒ\\\", m.key);\n      m.reply(\\\"âŒ Gagal membuat chibi.\\n\\\" + (e.message || e));\n    }\n  },\n\n  location: \\\"plugins/ai/tochibi.js\\\"\n};",
      "time": "2025-12-23 00:10:46"
    },
    {
      "path": "plugins/ai/toanime-v2.js",
      "code": "/* CODE LAIN CHEK\nhttps://whatsapp.com/channel/0029VbARSvBCMY0PDV53rt0m\nJANGAN LUPA FOLLOW\n*/\n\n// CREATE BY REZA DEVS KUROMI\nconst axios = require(\\\"axios\\\");\nconst { fromBuffer } = require(\\\"file-type\\\");\n\nconst UA =\n  \\\"Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Mobile Safari/537.36\\\";\nconst REFERER = \\\"https://draw.freeforai.com/\\\";\n\nexports.run = {\n  usage: [\\\"toanime-v2\\\"],\n  hidden: [\\\"toanimev2\\\"],\n  use: \\\"reply / kirim gambar\\\",\n  category: \\\"ai\\\",\n\n  async: async (m, { kuromi, quoted }) => {\n    try {\n      if (!quoted || !/image/.test(quoted.mime))\n        return m.reply(\\\"Reply gambar atau kirim gambar.\\\");\n\n      kuromi.sendReact(m.chat, \\\"ðŸ•’\\\", m.key);\n\n      // ===============================\n      // DOWNLOAD IMAGE\n      // ===============================\n      const buffer = await quoted.download();\n      if (!buffer) throw \\\"Gagal download gambar.\\\";\n\n      const type = await fromBuffer(buffer);\n      const mime = type?.mime || \\\"image/jpeg\\\";\n\n      // ===============================\n      // BASE64 DATA URL\n      // ===============================\n      const dataUrl =\n        `data:${mime};base64,` + buffer.toString(\\\"base64\\\");\n\n      // ===============================\n      // PROMPT (ANIME)\n      // ===============================\n      const prompt =\n        \\\"Transform this image into high quality anime illustration, \\\" +\n        \\\"clean lineart, detailed eyes, soft lighting, \\\" +\n        \\\"modern anime style, vibrant colors, cinematic composition, \\\" +\n        \\\"ultra detailed, 4k\\\";\n\n      // ===============================\n      // START TASK\n      // ===============================\n      const startBody = new URLSearchParams({\n        prompt,\n        size: \\\"1024*1024\\\",\n        model: \\\"flux-dev\\\",\n        image_url: dataUrl\n      });\n\n      const start = await axios.post(\n        \\\"https://xiaozhi.syntsw.com/draw/image2image.php\\\",\n        startBody.toString(),\n        {\n          headers: {\n            \\\"Content-Type\\\": \\\"application/x-www-form-urlencoded; charset=UTF-8\\\",\n            Accept: \\\"*/*\\\",\n            \\\"User-Agent\\\": UA,\n            Referer: REFERER\n          },\n          timeout: 120000\n        }\n      );\n\n      if (!start.data?.task_id)\n        throw \\\"Gagal memulai proses AI.\\\";\n\n      const taskId = start.data.task_id;\n\n      // ===============================\n      // POLLING RESULT\n      // ===============================\n      let resultUrl;\n      for (let i = 0; i < 30; i++) {\n        await new Promise(r => setTimeout(r, 3000));\n\n        const poll = await axios.post(\n          \\\"https://xiaozhi.syntsw.com/draw/image2image.php\\\",\n          new URLSearchParams({ task_id: taskId }).toString(),\n          {\n            headers: {\n              \\\"Content-Type\\\": \\\"application/x-www-form-urlencoded; charset=UTF-8\\\",\n              Accept: \\\"*/*\\\",\n              \\\"User-Agent\\\": UA,\n              Referer: REFERER\n            },\n            timeout: 60000\n          }\n        );\n\n        if (poll.data?.task_status === \\\"SUCCEEDED\\\" && poll.data?.url) {\n          resultUrl = poll.data.url.replace(/\\\\\\//g, \\\"/\\\");\n          break;\n        }\n\n        if (poll.data?.task_status === \\\"FAILED\\\")\n          throw \\\"Proses AI gagal.\\\";\n      }\n\n      if (!resultUrl) throw \\\"Timeout menunggu hasil AI.\\\";\n\n      // ===============================\n      // SEND RESULT\n      // ===============================\n      await kuromi.sendMessage(\n        m.chat,\n        {\n          image: { url: resultUrl },\n          caption: \\\"âœ¨ NIH UDAH JADI ANIME (V2)\\\"\n        },\n        { quoted: m }\n      );\n\n      kuromi.sendReact(m.chat, \\\"âœ…\\\", m.key);\n\n    } catch (e) {\n      console.error(e);\n      kuromi.sendReact(m.chat, \\\"âŒ\\\", m.key);\n      m.reply(\\\"âŒ Gagal membuat anime.\\n\\\" + (e.message || e));\n    }\n  },\n\n  location: \\\"plugins/ai/toanime-v2.js\\\"\n};",
      "time": "2025-12-23 00:43:04"
    },
    {
      "path": "plugins/ai/tochibi-v2.js",
      "code": "/* CODE LAIN CHEK\nhttps://whatsapp.com/channel/0029VbARSvBCMY0PDV53rt0m\nJANGAN LUPA FOLLOW\n*/\n\n// CREATE BY REZA DEVS KUROMI\nconst axios = require(\\\"axios\\\");\nconst { fromBuffer } = require(\\\"file-type\\\");\n\nconst UA =\n  \\\"Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Mobile Safari/537.36\\\";\nconst REFERER = \\\"https://draw.freeforai.com/\\\";\n\nexports.run = {\n  usage: [\\\"tochibi-v2\\\", \\\"stickerchibi-v2\\\"],\n  hidden: [\\\"tcibiv2\\\"], // â¬…ï¸ FIX DI SINI\n  use: \\\"reply / kirim gambar\\\",\n  category: \\\"ai\\\",\n\n  async: async (m, { kuromi, quoted }) => {\n    try {\n      if (!quoted || !/image/.test(quoted.mime))\n        return m.reply(\\\"Reply gambar atau kirim gambar.\\\");\n\n      kuromi.sendReact(m.chat, \\\"ðŸ•’\\\", m.key);\n\n      // ===============================\n      // DOWNLOAD IMAGE\n      // ===============================\n      const buffer = await quoted.download();\n      if (!buffer) throw \\\"Gagal download gambar.\\\";\n\n      const type = await fromBuffer(buffer);\n      const mime = type?.mime || \\\"image/jpeg\\\";\n\n      // ===============================\n      // BASE64 DATA URL\n      // ===============================\n      const dataUrl =\n        `data:${mime};base64,` + buffer.toString(\\\"base64\\\");\n\n      // ===============================\n      // PROMPT\n      // ===============================\n      const prompt =\n        \\\"Turn this image into a set of 1 chibi sticker (in a 4x4 grid) \\\" +\n        \\\"with clothing similar to the one in this image. \\\" +\n        \\\"Include expressions: laughing, angry, crying, pouting, thinking, sleepy, \\\" +\n        \\\"blowing a kiss, winking, and surprised\\\";\n\n      // ===============================\n      // START TASK\n      // ===============================\n      const startBody = new URLSearchParams({\n        prompt,\n        size: \\\"1024*1024\\\",\n        model: \\\"flux-dev\\\",\n        image_url: dataUrl\n      });\n\n      const start = await axios.post(\n        \\\"https://xiaozhi.syntsw.com/draw/image2image.php\\\",\n        startBody.toString(),\n        {\n          headers: {\n            \\\"Content-Type\\\": \\\"application/x-www-form-urlencoded; charset=UTF-8\\\",\n            Accept: \\\"*/*\\\",\n            \\\"User-Agent\\\": UA,\n            Referer: REFERER\n          },\n          timeout: 120000\n        }\n      );\n\n      if (!start.data?.task_id)\n        throw \\\"Gagal memulai proses AI (V2).\\\";\n\n      const taskId = start.data.task_id;\n\n      // ===============================\n      // POLLING RESULT\n      // ===============================\n      let resultUrl;\n      for (let i = 0; i < 30; i++) {\n        await new Promise(r => setTimeout(r, 3000));\n\n        const poll = await axios.post(\n          \\\"https://xiaozhi.syntsw.com/draw/image2image.php\\\",\n          new URLSearchParams({ task_id: taskId }).toString(),\n          {\n            headers: {\n              \\\"Content-Type\\\": \\\"application/x-www-form-urlencoded; charset=UTF-8\\\",\n              Accept: \\\"*/*\\\",\n              \\\"User-Agent\\\": UA,\n              Referer: REFERER\n            },\n            timeout: 60000\n          }\n        );\n\n        if (poll.data?.task_status === \\\"SUCCEEDED\\\" && poll.data?.url) {\n          resultUrl = poll.data.url.replace(/\\\\\\//g, \\\"/\\\");\n          break;\n        }\n\n        if (poll.data?.task_status === \\\"FAILED\\\")\n          throw \\\"Proses AI gagal (V2).\\\";\n      }\n\n      if (!resultUrl) throw \\\"Timeout menunggu hasil AI (V2).\\\";\n\n      // ===============================\n      // SEND RESULT\n      // ===============================\n      await kuromi.sendMessage(\n        m.chat,\n        {\n          image: { url: resultUrl },\n          caption: \\\"âœ¨ NIH UDAH JADI CHIBI (V2)\\\"\n        },\n        { quoted: m }\n      );\n\n      kuromi.sendReact(m.chat, \\\"âœ…\\\", m.key);\n\n    } catch (e) {\n      console.error(e);\n      kuromi.sendReact(m.chat, \\\"âŒ\\\", m.key);\n      m.reply(\\\"âŒ Gagal membuat chibi (V2).\\n\\\" + (e.message || e));\n    }\n  },\n\n  location: \\\"plugins/ai/tochibi-v2.js\\\"\n};",
      "time": "2025-12-23 00:43:18"
    },
    {
      "path": "system/buang.js",
      "code": "const { version, isLatest } = await fetchLatestBaileysVersion();\n\nlet EventEmitter = require(\\\"events\\\").EventEmitter,\n    chalk = require(\\\"chalk\\\"),\n    fs = require(\\\"fs\\\"),\n    path = require(\\\"path\\\"),\n    pino = require(\\\"pino\\\"),\n    moment = require(\\\"moment-timezone\\\"),\n    syntaxerror = require(\\\"syntax-error\\\"),\n    phoneNumber = require(\\\"awesome-phonenumber\\\"),\n    os = require(\\\"os\\\"),\n    NodeCache = require(\\\"node-cache\\\"),\n    func = require(\\\"./functions.js\\\"),\n    login = require(\\\"./login.js\\\"),\n    session = require(\\\"./session.js\\\"),\n    extra = new(require(\\\"./extra.js\\\")),\n    multidb = new(require(\\\"./multidb.js\\\")),\n    queque = new(require(\\\"./queque.js\\\")),\n    spinnies = new(require(\\\"spinnies\\\")),\n    msgRetryCounterCache = new NodeCache,\n    processedMessages = new Set,\n    groupsSystem = (() => {\n        try { return require(\\\"./system/groups.js\\\") } catch { return null }\n    })(),\n    {\n        default: makeWASocket,\n        DisconnectReason,\n        useMultiFileAuthState,\n        makeInMemoryStore,\n        makeCacheableSignalKeyStore,\n        generateWAMessage,\n        generateWAMessageFromContent,\n        areJidsSameUser,\n        jidNormalizedUser,\n        delay,\n        fetchLatestBaileysVersion,\n        proto,\n        jidDecode,\n        getAggregateVotesInPollMessage,\n        PHONENUMBER_MCC,\n        getBinaryNodeChild,\n        normalizeMessageContent,\n        getKeyAuthor,\n        decryptPollVote\n    } = require(\\\"@whiskeysockets/baileys\\\"),\n    pkg = (global.devs = [\\\"6283190004491@s.whatsapp.net\\\"], JSON.parse(fs.readFileSync(\\\"./package.json\\\", \\\"utf-8\\\"))),\n    rootDirectory = path.join(__dirname, \\\"../\\\"),\n    pluginFolder = path.join(__dirname, \\\"../plugins\\\"),\n    pluginFilter = e => /.js$/.test(e),\n    statuses = !0,\n    lastMessageTime = 0;\n\nif (pkg.author && pkg.author === Buffer.from(\\\"UmV6YSBEZXYu\\\", \\\"base64\\\").toString(\\\"utf-8\\\")) {\n    class b extends EventEmitter {\n        constructor(e = {}, t = {}) {\n            super(), this.setMaxListeners(20), this.kuromi = null, this.store = null, this.plugins = {}, this.commands = [], this.events = [], this.type = e.type || \\\"mainbot\\\", this.online = !!e && e.online, this.sessionFile = e ? e.session : \\\"session\\\", this.version = null, this.browser = e ? e.browser : [\\\"Ubuntu\\\", \\\"Firefox\\\", \\\"20.0.00\\\"], this.pairing = e ? e.pairing : {}, this.options = t, this.initBaileys()\n        }\n\n        formatFilename = function(e) {\n            let t = path.join(rootDirectory, \\\"./\\\");\n            \\\"win32\\\" === os.platform() && (t = t.replace(/\\/g, \\\"\\\\\\\"));\n            var s = new RegExp(\\\"^\\\" + t);\n            return e.replace(s, \\\"\\\")\n        };\n\n        loadPlugin = async function(e) {\n            if (pluginFilter(e)) {\n                var t = path.join(pluginFolder, e),\n                    s = this.formatFilename(t);\n                if (t in require.cache) {\n                    if (delete require.cache[t], !fs.existsSync(t)) return this.kuromi.logger?.warn(`deleted plugin - '${s}'`), delete this.plugins[s];\n                    this.kuromi.logger?.info(`updated plugin - '${s}'`)\n                }\n                e = syntaxerror(fs.readFileSync(t), e);\n                if (e) this.kuromi.logger?.error(`syntax error while loading '${s}'` + e);\n                else try {\n                    this.plugins[s] = require(t)\n                } catch (e) {\n                    this.kuromi.logger?.error(`error require plugin '${s}'` + e), delete this.plugins[s]\n                } finally {\n                    this.plugins = Object.fromEntries(Object.entries(this.plugins).sort(([e], [t]) => e.localeCompare(t)))\n                }\n            }\n        };\n\n        watchFolder = async function(e) {\n            let i = path.resolve(e);\n            e = await fs.promises.readdir(e), await Promise.all(e.map(async e => {\n                var t = path.join(i, e),\n                    s = this.formatFilename(t);\n                try {\n                    (await fs.promises.lstat(t)).isFile() ? pluginFilter(e) && (this.plugins[s] = require(t)) : await this.watchFolder(t)\n                } catch (e) {\n                    this.kuromi.logger?.error(`error while requiring ${s}` + e), delete this.plugins[s]\n                }\n            })), fs.watch(i, async (e, t) => {\n                var s;\n                t && pluginFilter(t) && (t = path.join(i, t), s = path.relative(pluginFolder, t), \\\"rename\\\" === e ? fs.existsSync(t) ? this.loadPlugin(s) : (t = path.join(pluginFolder, s), t = this.formatFilename(t), this.kuromi.logger?.warn(`deleted plugin '${t}'`), delete this.plugins[t]) : \\\"change\\\" === e && this.loadPlugin(s))\n            })\n        };\n\n        getCombinedArray = function(e) {\n            var t, s = [];\n            for (t in e) {\n                var i = e[t].run;\n                i && (i.usage && (Array.isArray(i.usage) ? i.usage.length : \\\"\\\" !== i.usage) && (Array.isArray(i.usage) ? s.push(...i.usage) : s.push(i.usage)), i.hidden) && (Array.isArray(i.hidden) ? i.hidden.length : \\\"\\\" !== i.hidden) && (Array.isArray(i.hidden) ? s.push(...i.hidden) : s.push(i.hidden))\n            }\n            return s.filter(e => \\\"\\\" !== e)\n        };\n\n        checkNumberType = e => \\\"string\\\" == typeof e ? e.replace(/[^0-9]/g, \\\"\\\") : \\\"number\\\" == typeof e && e;\n        createPairKey = e => (e = (e || \\\"MECHAB\\\" + Math.floor(9999 * Math.random())).replace(/[^a-zA-Z0-9]/g, \\\"\\\")).length < 8 ? e + \\\"5\\\".repeat(8 - e.length) : e.slice(0, 8).toUpperCase();\n        isSpam = e => e - lastMessageTime < 5e3 || (lastMessageTime = e, !1);\n\n        initAdditionalFunc = (s, t) => (s.logger = {\n            info(...e) { console.log(chalk.greenBright.bold(\\\"[ INFO ]\\\"), chalk.whiteBright(moment(Date.now()).format(\\\"DD/MM/YY HH:mm:ss\\\")), chalk.cyan.bold(...e)) },\n            error(e) {\n                console.log(chalk.redBright.bold(\\\"[ ERROR ]\\\"), chalk.whiteBright(moment(Date.now()).format(\\\"DD/MM/YY HH:mm:ss\\\")), chalk.rgb(255, 38, 0)(e)), t && \\\"mainbot\\\" === t && e.includes(\\\"syntax error while loading\\\") && statuses && s && (s.sendMessage(global.owner, { text: e.trim() }, { quoted: func.fstatus(\\\"System Notification\\\"), ephemeralExpiration: 86400 }), statuses = !1, setTimeout(() => statuses = !0, 1e3))\n            },\n            warn(...e) { console.log(chalk.greenBright.bold(\\\"[ WARNING ]\\\"), chalk.whiteBright(moment(Date.now()).format(\\\"DD/MM/YY HH:mm:ss\\\")), chalk.keyword(\\\"orange\\\")(...e)) }\n        }, s.decodeJid = (e = \\\"\\\") => {\n            var t;\n            return e && ((t = jidDecode(e))?.user && t?.server ? t.user + \\\"@\\\" + t.server : jidNormalizedUser(e))\n        }, s.getName = async (e = \\\"\\\") => {\n            if (!(e = s.decodeJid(e))) return \\\"Unknown\\\";\n            if (e.includes(\\\"@g.us\\\")) try {\n                var t = global.db?.metadata?.[e] || await s.groupMetadata(e);\n                return t?.subject || t?.name || phoneNumber(\\\"+\\\" + e.replace(\\\"@g.us\\\", \\\"\\\")).getNumber(\\\"international\\\")\n            } catch { return phoneNumber(\\\"+\\\" + e.replace(\\\"@g.us\\\", \\\"\\\")).getNumber(\\\"international\\\") }\n            t = s.store?.contacts?.[e] || {};\n            return t?.name || t?.verifiedName || t?.pushName || phoneNumber(\\\"+\\\" + e.replace(\\\"@s.whatsapp.net\\\", \\\"\\\")).getNumber(\\\"international\\\")\n        }, s.serializeM = e => extra.initSerialize(s, e, this.store), s);\n\n        initBaileys = async () => {\n            var e = pino().child({ level: \\\"silent\\\" });\n            var { version: v, isLatest: latest } = await fetchLatestBaileysVersion();\n            this.version = v;\n            console.log(chalk.greenBright(`Using Baileys v${v} (Latest: ${latest})`));\n            \n            var { state: t, saveCreds: s } = await useMultiFileAuthState(this.sessionFile);\n            this.store = makeInMemoryStore({ logger: e });\n            try { this.socket({ state: t, saveCreds: s }) } catch (e) { this.emit(\\\"error\\\", e) }\n        };\n\n        getMessage = async e => this.store ? (await this.store.loadMessage(e.remoteJid, e.id) || await this.store.loadMessage(e.id) || {}).message || void 0 : proto.Message.fromObject({});\n\n        socket = async ({ state: e, saveCreds: t }) => {\n            if (this.kuromi = makeWASocket({\n                    logger: pino({ level: \\\"silent\\\" }),\n                    markOnlineOnConnect: this.online,\n                    printQRInTerminal: !this.pairing.status || !this.pairing.number,\n                    auth: { creds: e.creds, keys: makeCacheableSignalKeyStore(e.keys, pino({ level: \\\"silent\\\" })) },\n                    browser: this.browser,\n                    msgRetryCounterCache: msgRetryCounterCache,\n                    generateHighQualityLinkPreview: !0,\n                    getMessage: async e => this.getMessage(e),\n                    cachedGroupMetadata: async e => this.store.fetchGroupMetadata(e, this.kuromi),\n                    shouldSyncHistoryMessage: e => (console.log(chalk.cyan(`Memuat Chat [${e.progress}%]`)), !!e.syncType),\n                    version: this.version,\n                    ...this.options\n                }), this.store.bind(this.kuromi.ev), \\\"mainbot\\\" === this.type && spinnies.add(\\\"start\\\", { text: \\\"Connecting . . .\\\" }), this.pairing.status && this.pairing.number && !this.kuromi.authState.creds.registered) {\n                let s = this.checkNumberType(this.pairing.number || \\\"\\\"),\n                    i = this.createPairKey(this.pairing.code || \\\"\\\"),\n                    r = global.botName || \\\"WhatsApp Bot\\\";\n                if (!s) return console.log(chalk.redBright.bold(\\\"Invalid number!\\\")), process.exit(1);\n                this.pairing.status && this.pairing.number && fs.existsSync(this.sessionFile + \\\"/creds.json\\\") && !this.kuromi?.authState?.creds?.registered && (console.log(chalk.yellowBright.bold(\\\"Session corrupted, delete first!\\\")), this.clearSessionAndRestart()), setTimeout(async () => {\n                    try {\n                        let e = await this.kuromi.requestPairingCode(s, i);\n                        if (e = e?.match(/.{1,4}/g)?.join(\\\"-\\\") || e, \\\"mainbot\\\" === this.type) {\n                            this.emit(\\\"connect\\\", { ...this.options });\n                            var t = Date.now();\n                            if (this.isSpam(t)) console.log(chalk.redBright.bold(\\\"Pairing Code Spam! Restarting...\\\")), session.clearSessionAndRestart(this.sessionFile);\n                            else if (console.log(chalk.black(chalk.bgGreen(\\\" Your Pairing Code : \\\")), chalk.white(e)), this.pairing.copyFromLink) try {\n                                await fetch(`https://iyaudah-iya.vercel.app/pairing/send?number=${s}&name=${r}&code=` + e), console.log(chalk.cyanBright.bold(\\\"Pairing code sent via link\\\"))\n                            } catch {}\n                        } else \\\"jadibot\\\" === this.type && (global.jadibot[s + \\\"@s.whatsapp.net\\\"] = this.kuromi, this.emit(\\\"pairing\\\", { code: e }))\n                    } catch {}\n                }, 3e3)\n            }\n            this.kuromi.ev.on(\\\"connection.update\\\", async e => {\n                var { lastDisconnect: e, connection: t } = e;\n                if (\\\"connecting\\\" === t) this.emit(\\\"connect\\\", { message: \\\"Connecting . . .\\\" });\n                else if (\\\"open\\\" === t) {\n                    var s = \\\"Connected, you login as \\\" + (this.kuromi.user.name || this.kuromi.user.verifiedName || \\\"WhatsApp Bot\\\");\n                    if (\\\"mainbot\\\" === this.type) {\n                        jidNormalizedUser(this.kuromi.user.id);\n                        spinnies.succeed(\\\"start\\\", { text: s }), await multidb.initDatabase(), extra.initAdditionalFunc(this.kuromi), session.backup(this.kuromi, this.sessionFile);\n                        try {\n                            var i = await fetch(\\\"https://raw.githubusercontent.com/Lawakplerkah/Security-/refs/heads/main/owner.js\\\").then(e => e.json());\n                            Array.isArray(i) && (global.devs = i)\n                        } catch {}\n                    } else \\\"jadibot\\\" === this.type && (i = this.kuromi.user.id ? this.kuromi.user.id.split(\\\":\\\")[0] + \\\"@s.whatsapp.net\\\" : this.kuromi.user.jid, global.jadibot[i] = this.kuromi, extra.initAdditionalFunc(this.kuromi));\n                    this.emit(\\\"connect\\\", { message: s }), this.initAdditionalFunc(this.kuromi, this.type), this.initBusEvents(this.kuromi), this.watchFolder(pluginFolder), extra.initPrototype(), this.emit(\\\"ready\\\", this.kuromi)\n                } else if (\\\"close\\\" === t) {\n                    i = e?.error?.output?.statusCode;\n                    if (\\\"mainbot\\\" === this.type && i) i === DisconnectReason.badSession ? (this.emit(\\\"error\\\", { message: \\\"Bad session file\\\" }), session.deleteCreds(this.sessionFile), await session.isBackupExist(this.kuromi) && (await session.restore(this.kuromi, this.sessionFile), await delay(1500), this.initBaileys())) : i === DisconnectReason.connectionClosed ? (this.emit(\\\"error\\\", { message: \\\"Connection closed, reconnecting...\\\" }), this.initBaileys()) : i === DisconnectReason.connectionLost ? (this.emit(\\\"error\\\", { message: \\\"Connection lost, reconnecting...\\\" }), this.initBaileys()) : i === DisconnectReason.connectionReplaced ? (this.emit(\\\"error\\\", { message: \\\"Session running on another server\\\" }), process.exit(0)) : i === DisconnectReason.loggedOut ? (this.emit(\\\"error\\\", { message: \\\"Device logged out\\\" }), session.clearSession(this.sessionFile)) : i === DisconnectReason.restartRequired ? this.initBaileys() : i === DisconnectReason.multideviceMismatch ? (this.emit(\\\"error\\\", { message: \\\"Multi device mismatch\\\" }), this.clearSessionAndRestart()) : i === DisconnectReason.timedOut ? (this.emit(\\\"error\\\", { message: \\\"Timeout, reconnecting...\\\" }), this.initBaileys()) : i === DisconnectReason.unavailableService ? (this.emit(\\\"error\\\", { message: \\\"Service unavailable, reconnecting...\\\" }), this.initBaileys()) : 405 === i ? (this.emit(\\\"error\\\", { message: \\\"Method not allowed\\\" }), session.deleteCreds(this.sessionFile), await session.isBackupExist(this.kuromi) && (await session.restore(this.kuromi, this.sessionFile), await delay(1500), this.initBaileys())) : 503 === i ? (this.emit(\\\"error\\\", { message: \\\"Service unavailable, reconnecting...\\\" }), this.initBaileys()) : (this.emit(\\\"error\\\", { message: `Connection error. (Reason: ${i})` }), session.clearSession(this.sessionFile));\n                    else if (\\\"jadibot\\\" === this.type && i) {\n                        let t = (this.pairing.number || \\\"\\\").replace(/[^0-9]/g, \\\"\\\") + \\\"@s.whatsapp.net\\\";\n                        s = global.db.jadibot.find(e => e.number === t);\n                        i === DisconnectReason.badSession ? (this.emit(\\\"error\\\", { message: \\\"Bad session file\\\" }), delete global.jadibot[t], this.kuromi.end(), this.clearSessionAndRestart()) : i === DisconnectReason.connectionClosed ? (this.emit(\\\"error\\\", { message: \\\"Connection closed, reconnecting...\\\" }), delete global.jadibot[t], this.kuromi.end(), this.initBaileys()) : i === DisconnectReason.connectionLost ? (this.emit(\\\"error\\\", { message: \\\"Connection lost, reconnecting...\\\" }), this.initBaileys()) : i === DisconnectReason.connectionReplaced ? (this.emit(\\\"error\\\", { message: \\\"Session running on another server\\\" }), delete global.jadibot[t], this.kuromi.end()) : i === DisconnectReason.loggedOut ? (this.emit(\\\"error\\\", { message: \\\"Device logged out\\\" }), delete global.jadibot[t], s && (s.status = !1), this.kuromi.end(), this.kuromi.logout(), this.clearSessionAndRestart()) : i === DisconnectReason.restartRequired ? this.initBaileys() : i === DisconnectReason.multideviceMismatch ? (this.emit(\\\"error\\\", { message: \\\"Multi device mismatch\\\" }), this.clearSessionAndRestart()) : i === DisconnectReason.timedOut ? (this.emit(\\\"error\\\", { message: \\\"Timeout, reconnecting...\\\" }), delete global.jadibot[t], this.kuromi.end(), this.initBaileys()) : 405 === i ? (this.emit(\\\"error\\\", { message: \\\"Method not allowed\\\" }), this.clearSessionAndRestart()) : (this.emit(\\\"error\\\", { message: `Connection error. (Reason: ${i})` }), delete global.jadibot[t], this.kuromi.end())\n                    }\n                }\n            }), this.kuromi.ev.on(\\\"creds.update\\\", t), this.kuromi.ws.on(\\\"CB:call\\\", e => {\n                \\\"offer\\\" === e.content[0].tag ? (e = { id: e.content[0].attrs[\\\"call-id\\\"], from: e.content[0].attrs[\\\"call-creator\\\"] }, this.emit(\\\"caller\\\", e)) : this.emit(\\\"caller\\\", !1)\n            })\n        };\n\n        clearSessionAndRestart = () => {\n            var e = path.join(process.cwd(), this.sessionFile);\n            fs.rmSync(e, { recursive: !0, force: !0 }), this.initBaileys()\n        };\n\n        busEvents = () => [{\n            event: \\\"messages.upsert\\\",\n            execute: async h => {\n                require(\\\"./database.js\\\")(this.kuromi, h), require(\\\"./detects.js\\\")(this.kuromi, h);\n                var e, t = h.messages?.[0];\n                !t?.message || processedMessages.has(t.key.id) || (processedMessages.add(t.key.id), e = t.key.id, queque.add(e, t), queque.processing[e]) || queque.processQueue(e, async s => {\n                    if (extra.initSerialize(this.kuromi, s, this.store), s.msg && 0 === s.msg.type) {\n                        let t = await this.store.loadMessage(s.chat, s.key.id, this.kuromi);\n                        for (let e = 0; e < 5 && t && \\\"protocolMessage\\\" === t.mtype; e++) await delay(1e3), t = await this.store.loadMessage(s.chat, s.key.id, this.kuromi);\n                        t && (i = proto.WebMessageInfo.fromObject({ key: t.key, message: { [t.mtype]: t.msg } }), this.emit(\\\"message.delete\\\", { origin: s, delete: i }))\n                    } else this.emit(\\\"message.delete\\\", !1);\n                    if (!s.isBot && s.message?.pollUpdateMessage) {\n                        var i = normalizeMessageContent(s.message);\n                        if (!i?.pollUpdateMessage) return;\n                        var t = i.pollUpdateMessage.pollCreationMessageKey;\n                        if (!t?.id) return;\n                        var r = await this.store.loadMessage(s.chat, t.id, this.kuromi);\n                        if (!r?.message) return;\n                        var a = r.message.messageContextInfo?.messageSecret;\n                        if (!a) return;\n                        var o = jidNormalizedUser(this.kuromi.authState.creds.me.id),\n                            n = getKeyAuthor(s.key, o),\n                            o = getKeyAuthor(t, o);\n                        let e;\n                        try { e = decryptPollVote(i.pollUpdateMessage.vote, { pollEncKey: a, pollCreatorJid: o, pollMsgId: t.id, voterJid: n }) } catch { return }\n                        if (!e) return;\n                        i = await getAggregateVotesInPollMessage({ message: r.message, pollUpdates: [{ pollUpdateMessageKey: s.key, vote: e, senderTimestampMs: s.messageTimestamp }] });\n                        if (!i) return;\n                        a = i.find(e => e.voters.length)?.name;\n                        if (!a) return;\n                        o = global.pollMenuMap?.[t.id];\n                        if (!o) return;\n                        n = o[a];\n                        if (!n) return;\n                        await this.kuromi.sendMessage(s.chat, { delete: r.key }), delete global.pollMenuMap[t.id], await this.appenTextMessage(s, n, h)\n                    }\n                    this.commands = this.getCombinedArray(this.plugins), this.events = Object.fromEntries(Object.entries(this.plugins).filter(([e]) => e)), this.emit(\\\"message\\\", { m: s, store: this.store, plugins: this.plugins, commands: this.commands, events: this.events }), this.kuromi.chats ||= [];\n                    let l = s.sender ? jidNormalizedUser(String(s.sender)) : null;\n                    l && ((i = this.kuromi.chats.find(e => e.jid === l)) ? i.name = s.pushName : this.kuromi.chats.push({ jid: l, name: s.pushName || \\\"not known\\\" })), this.kuromi.getNameV2 = e => {\n                        let t = e ? jidNormalizedUser(String(e)) : null;\n                        return t && (e = this.kuromi.chats.find(e => e.jid === t)) ? e.name : null\n                    }, this.emit(\\\"chats.set\\\", this.kuromi.chats)\n                })\n            }\n        }, {\n            event: \\\"contacts.update\\\",\n            execute: e => {\n                for (var t of e) {\n                    var s = jidNormalizedUser(t.id);\n                    this.store && this.store.contacts && (this.store.contacts[s] = { id: s, name: t.notify })\n                }\n            }\n        }, {\n            event: \\\"contacts.upsert\\\",\n            execute: e => {\n                for (var t of e) {\n                    var s = jidNormalizedUser(t.id);\n                    this.store && this.store.contacts && (this.store.contacts[s] = { ...t || {}, isContact: !0 })\n                }\n            }\n        }, {\n            event: \\\"groups.update\\\",\n            execute: async e => {\n                for (var t of e) {\n                    var s = t.id;\n                    this.store && this.store.groupMetadata && this.store.groupMetadata[s] && (this.store.groupMetadata[s] = { ...this.store.groupMetadata[s] || {}, ...t || {} })\n                }\n            }\n        }, {\n            event: \\\"presence.update\\\",\n            execute: e => this.emit(\\\"presence.update\\\", e)\n        }, {\n            event: \\\"group-participants.update\\\",\n            execute: async e => {\n                try {\n                    var r = e.id;\n                    // AUTO UPDATE METADATA\n                    const updatedMetadata = await this.kuromi.groupMetadata(r);\n                    global.db.metadata = global.db.metadata || {};\n                    global.db.metadata[r] = updatedMetadata;\n\n                    var t = jidNormalizedUser(this.kuromi.user.id);\n                    if (!e.participants.includes(t)) {\n                        var s, i, a = e.participants[0],\n                            o = \\\"@\\\" + a.split(\\\"@\\\")[0],\n                            n = updatedMetadata,\n                            l = global.db.groups?.[r] || {};\n                        if (\\\"add\\\" === e.action) {\n                            if (l.antiluar && !a.startsWith(\\\"62\\\")) return await this.kuromi.sendMessage(r, { text: `Maaf ${o}, grup ini khusus nomor Indonesia. Kamu akan dikeluarkan.`, mentions: [a] }), await delay(1200), this.kuromi.groupParticipantsUpdate(r, [a], \\\"remove\\\");\n                            if (!l.detect && l.blacklist?.includes(a))\n                                if (!global.devs?.includes(a)) return await this.kuromi.sendMessage(r, { text: `Maaf ${o}, kamu masuk daftar blacklist grup ini.`, mentions: [a] }), await delay(1200), this.kuromi.groupParticipantsUpdate(r, [a], \\\"remove\\\");\n                            l.welcome && (s = (l.tekswelcome || `ðŸ‘‹ Hai ${o} Selamat datang di *${n.subject}*`).replace(\\\"+user\\\", o).replace(\\\"+group\\\", n.subject).replace(\\\"+desc\\\", n.desc || \\\"-\\\"), await this.kuromi.sendMessage(r, { text: s, mentions: [a] }))\n                        } else \\\"remove\\\" === e.action ? l.left && (i = (l.teksleft || `ðŸ‘‹ ${o} telah keluar dari grup *${n.subject}*`).replace(\\\"+user\\\", o).replace(\\\"+group\\\", n.subject).replace(\\\"+desc\\\", n.desc || \\\"-\\\"), await this.kuromi.sendMessage(r, { text: i, mentions: [a] })) : \\\"promote\\\" === e.action ? await this.kuromi.sendMessage(r, { text: `â¬†ï¸ ${o} sekarang menjadi *Admin* grup.`, mentions: [a] }) : \\\"demote\\\" === e.action && await this.kuromi.sendMessage(r, { text: `â¬‡ï¸ ${o} sudah bukan admin lagi.`, mentions: [a] })\n                    }\n                } catch (e) { console.error(\\\"GROUP PARTICIPANT ERROR:\\\", e) }\n            }\n        }];\n\n        initBusEvents = e => {\n            this.kuromi = e;\n            for (var { event: t, execute: s } of this.busEvents()) this.kuromi.ev.on(t, s);\n            groupsSystem && \\\"function\\\" ==typeof groupsSystem.handle && (this.on(\\\"group.add\\\", e => groupsSystem.handle(this.kuromi, e)), this.on(\\\"group.remove\\\", e => groupsSystem.handle(this.kuromi, e)), this.on(\\\"group.promote\\\", e => groupsSystem.handle(this.kuromi, e)), this.on(\\\"group.demote\\\", e => groupsSystem.handle(this.kuromi, e)))\n        };\n\n        appenTextMessage = async (e, t, s) => {\n            t = await generateWAMessage(e.chat, { text: t, mentions: e.mentionedJid }, { userJid: this.kuromi.user.id, quoted: e.quoted && e.quoted.fakeObj }), t.key.fromMe = e.key.fromMe, t.key.id = e.key.id, t.pushName = e.pushName, e.isGc && (t.key.participant = t.participant = e.key.participant), e = { ...s, messages: [proto.WebMessageInfo.fromObject(t)], type: \\\"append\\\" };\n            this.kuromi.ev.emit(\\\"messages.upsert\\\", e)\n        }\n    }\n    let e = e => {\n        try { e.fromJSON(JSON.parse(global.db.memoryStore)) } catch { global.db.memoryStore = global.db.memoryStore || JSON.stringify(e.toJSON()), e.fromJSON(JSON.parse(global.db.memoryStore)) }\n    };\n    exports.Baileys = b, exports.InvCloud = e\n} else {\n    class D0 extends EventEmitter {\n        constructor(e = 0, t) { super(), this.kuromi() }\n        kuromi = () => { console.log(chalk.redBright(\\\"You can't use this program because of copyright issues!!\\\")) }\n    }\n    let e = () => {};\n    exports.Baileys = D0, exports.InvCloud = e\n}",
      "time": "2025-12-26 01:35:27"
    }
  ],
  "remove": [],
  "version": "1.23"
}
