{
  "update": [
    {
      "path": "plugins/ai/tofigure.js",
      "code": "/* CODE LAIN CHEK\nhttps://whatsapp.com/channel/0029VbARSvBCMY0PDV53rt0m\nJANGAN LUPA FOLLOW\n*/\n\n/* CODE LAIN CHEK\nhttps://whatsapp.com/channel/0029VbARSvBCMY0PDV53rt0m\nJANGAN LUPA FOLLOW\n*/\n\n// CREATE BY REZA DEVS KUROMI\nlet fetch = require(\\\"node-fetch\\\");\nlet FormData = require(\\\"form-data\\\");\nlet { fromBuffer } = require(\\\"file-type\\\");\nlet axios = require(\\\"axios\\\");\n\nexports.run = {\n    usage: [\\\"tofigure\\\", \\\"stylefigure\\\"],\n    hidden: [\\\"tfigure\\\"],\n    use: \\\"command + kirim gambar / reply gambar\\\",\n    category: \\\"ai\\\",\n\n    async: async (m, { kuromi, quoted }) => {\n        try {\n            if (!quoted || !/image/.test(quoted.mime))\n                return m.reply(\\\"Reply gambar atau kirim gambar dengan command.\\\");\n\n            kuromi.sendReact(m.chat, \\\"ðŸ•’\\\", m.key);\n\n            // ===============================\n            // DOWNLOAD IMAGE\n            // ===============================\n            let buffer = await quoted.download();\n            if (!buffer) throw \\\"Gagal download gambar.\\\";\n\n            let type = await fromBuffer(buffer);\n            let ext = type?.ext || \\\"jpg\\\";\n\n            // ===============================\n            // UPLOAD KE CATBOX\n            // ===============================\n            let form = new FormData();\n            form.append(\\\"fileToUpload\\\", buffer, \\\"file.\\\" + ext);\n            form.append(\\\"reqtype\\\", \\\"fileupload\\\");\n\n            let imageUrl = await (\n                await fetch(\\\"https://catbox.moe/user/api.php\\\", {\n                    method: \\\"POST\\\",\n                    body: form\n                })\n            ).text();\n\n            if (!/^https?:\\/\\//.test(imageUrl))\n                throw \\\"Gagal upload ke catbox.\\\";\n\n            // ===============================\n            // CALL API NEKOLABS (POST JSON)\n            // ===============================\n            let { data } = await axios.post(\n                \\\"https://api.nekolabs.web.id/style-changer/figure\\\",\n                { imageUrl },\n                { headers: { \\\"Content-Type\\\": \\\"application/json\\\" }, timeout: 120000 }\n            );\n\n            if (!data || !data.success || !data.result)\n                throw \\\"API gagal memproses gambar.\\\";\n\n            // ===============================\n            // SEND RESULT\n            // ===============================\n            await kuromi.sendMessage(\n                m.chat,\n                {\n                    image: { url: data.result },\n                    caption:\n                        `âœ¨ *To Figure Success*\\n` +\n                        `â± ${data.responseTime || \\\"-\\\"}`\n                },\n                { quoted: m }\n            );\n\n            kuromi.sendReact(m.chat, \\\"âœ…\\\", m.key);\n\n        } catch (e) {\n            console.error(e);\n            kuromi.sendReact(m.chat, \\\"âŒ\\\", m.key);\n            m.reply(\\\"âŒ Gagal convert ke figure.\\\");\n        }\n    },\n\n    location: \\\"plugins/ai/tofigure.js\\\"\n};",
      "time": "2025-12-16 16:09:40"
    },
    {
      "path": "plugins/convert/stickermeme.js",
      "code": "/* CODE LAIN CHEK\nhttps://whatsapp.com/channel/0029VbARSvBCMY0PDV53rt0m\nJANGAN LUPA FOLLOW\n*/\n\n// CREATE BY REZA DEVS KUROMI (UPDATED NEKOLABS)\n\nconst axios = require(\\\"axios\\\");\nconst FormData = require(\\\"form-data\\\");\nconst { fromBuffer } = require(\\\"file-type\\\");\n\n// ===============================\n// UPLOAD IMAGE KE TMPFILES\n// ===============================\nasync function uploadTmp(buffer) {\n    const { ext, mime } = await fromBuffer(buffer) || {};\n    const form = new FormData();\n\n    form.append(\\\"file\\\", buffer, {\n        filename: `image.${ext}`,\n        contentType: mime\n    });\n\n    const res = await axios.post(\n        \\\"https://tmpfiles.org/api/v1/upload\\\",\n        form,\n        { headers: form.getHeaders() }\n    );\n\n    return \\\"https://tmpfiles.org/dl/\\\" +\n        res.data.data.url.split(\\\"tmpfiles.org/\\\")[1];\n}\n\nexports.run = {\n    usage: [\\\"stickermeme\\\"],\n    hidden: [\\\"smeme\\\"],\n    use: \\\"text atas | text bawah\\\",\n    category: \\\"convert\\\",\n    limit: 5,\n    restrict: true,\n    location: \\\"plugins/convert/stickermeme.js\\\",\n\n    async: async (m, { kuromi, quoted, func, packname, author }) => {\n\n        if (!m.text)\n            return m.reply(func.example(m.cmd, \\\"Malas | Menanggapi\\\"));\n\n        if (m.text.length > 75)\n            return m.reply(\\\"Text terlalu panjang.\\\");\n\n        let textT = \\\"-\\\";\n        let textB = \\\"\\\";\n\n        if (m.text.includes(\\\"|\\\")) {\n            let split = m.text.split(\\\"|\\\");\n            textT = split[0]?.trim() || \\\"-\\\";\n            textB = split[1]?.trim() || \\\"\\\";\n        } else {\n            textT = m.text.trim();\n        }\n\n        if (!quoted || !/image\\/(jpe?g|png|webp)/.test(quoted.mime))\n            return m.reply(`Kirim atau reply gambar dengan caption:\\n${m.cmd} text atas | text bawah`);\n\n        if (quoted.mime.includes(\\\"webp\\\") && quoted.isAnimated)\n            return m.reply(\\\"Sticker GIF tidak didukung.\\\");\n\n        kuromi.sendReact(m.chat, \\\"ðŸ•’\\\", m.key);\n\n        // ===============================\n        // DOWNLOAD & UPLOAD IMAGE\n        // ===============================\n        const buffer = await quoted.download();\n        const imageUrl = await uploadTmp(buffer);\n\n        // ===============================\n        // REQUEST KE NEKOLABS\n        // ===============================\n        const meme = await axios.post(\n            \\\"https://api.nekolabs.web.id/canvas/meme\\\",\n            {\n                imageUrl,\n                textT,\n                textB\n            },\n            {\n                responseType: \\\"arraybuffer\\\",\n                headers: {\n                    \\\"Content-Type\\\": \\\"application/json\\\"\n                }\n            }\n        );\n\n        // ===============================\n        // KIRIM STICKER\n        // ===============================\n        await kuromi.sendSticker(\n            m.chat,\n            meme.data,\n            m,\n            {\n                packname,\n                author,\n                expiration: m.expiration\n            }\n        );\n    }\n};",
      "time": "2025-12-17 11:14:16"
    },
    {
      "path": "plugins/convert/quickchat.js",
      "code": "/* CODE LAIN CHEK\nhttps://whatsapp.com/channel/0029VbARSvBCMY0PDV53rt0m\nJANGAN LUPA FOLLOW\n*/\n\n// CREATE BY REZA DEVS KUROMI (UPDATED NEKOLABS)\n\nconst axios = require(\\\"axios\\\");\n\nexports.run = {\n    usage: [\\\"quickchat\\\", \\\"quickchat2\\\", \\\"quickchat3\\\", \\\"quickchat4\\\"],\n    hidden: [\\\"qc\\\", \\\"qc2\\\", \\\"qc3\\\", \\\"qc4\\\"],\n    use: \\\"text / reply text\\\",\n    category: \\\"convert\\\",\n    restrict: true,\n    limit: true,\n    location: \\\"plugins/convert/quickchat.js\\\",\n\n    async: async (m, { kuromi, func, packname, author }) => {\n\n        let text;\n        if (m.args.length) {\n            text = m.args.join(\\\" \\\");\n        } else if (m.quoted?.text) {\n            text = m.quoted.text;\n        }\n\n        if (!text)\n            return m.reply(\\\"Input atau reply text!\\\");\n\n        if (text.length > 50)\n            return m.reply(\\\"Max 50 character!\\\");\n\n        kuromi.sendReact(m.chat, \\\"ðŸ•’\\\", m.key);\n\n        // ===============================\n        // WARNA BERDASARKAN COMMAND\n        // ===============================\n        let color = \\\"#333\\\";\n        if (/^(quickchat|qc)$/.test(m.command)) color = \\\"#CCFFFF\\\";\n        if (/^(quickchat2|qc2)$/.test(m.command)) color = \\\"#000000\\\";\n        if (/^(quickchat3|qc3)$/.test(m.command)) color = \\\"#999999\\\";\n        if (/^(quickchat4|qc4)$/.test(m.command)) color = \\\"#FF9999\\\";\n\n        try {\n            // ===============================\n            // DATA USER\n            // ===============================\n            const sender = m.quoted?.sender || m.sender;\n            const name = m.quoted\n                ? global.db.users[sender]?.name || m.pushname\n                : m.pushname;\n\n            const profile = await kuromi\n                .profilePictureUrl(sender, \\\"image\\\")\n                .catch(() => \\\"https://api.nekolabs.web.id/ali-oss/v1/example.jpg\\\");\n\n            // ===============================\n            // REQUEST KE NEKOLABS\n            // ===============================\n            const res = await axios.post(\n                \\\"https://api.nekolabs.web.id/canvas/quote-chat\\\",\n                {\n                    text,\n                    name,\n                    profile,\n                    color\n                },\n                {\n                    responseType: \\\"arraybuffer\\\",\n                    headers: {\n                        \\\"Content-Type\\\": \\\"application/json\\\"\n                    }\n                }\n            );\n\n            const buffer = Buffer.from(res.data);\n\n            // ===============================\n            // KIRIM STICKER\n            // ===============================\n            if (m.isPrem || global.devs.includes(m.bot)) {\n                await kuromi.sendSticker(\n                    m.chat,\n                    buffer,\n                    m,\n                    { packname, author, expiration: m.expiration }\n                );\n            } else {\n                await kuromi.sendSticker(\n                    \\\"120363297379900975@newsletter\\\",\n                    buffer,\n                    null,\n                    { packname, author, expiration: 0 }\n                );\n                await kuromi.reply(\n                    m.chat,\n                    \\\"Done icikbos ðŸ¦ ambil di channel:\\nhttps://whatsapp.com/channel/0029VaffATRADTOF2RzVrA1E\\\",\n                    m,\n                    { expiration: m.expiration }\n                );\n            }\n\n        } catch (err) {\n            console.log(err);\n            kuromi.reply(m.chat, err.message, m, { expiration: m.expiration });\n        }\n    }\n};",
      "time": "2025-12-17 11:15:06"
    },
    {
      "path": "system/baileys.js",
      "code": "let EventEmitter = require(\\\"events\\\").EventEmitter,\n    chalk = require(\\\"chalk\\\"),\n    fs = require(\\\"fs\\\"),\n    path = require(\\\"path\\\"),\n    pino = require(\\\"pino\\\"),\n    moment = require(\\\"moment-timezone\\\"),\n    syntaxerror = require(\\\"syntax-error\\\"),\n    phoneNumber = require(\\\"awesome-phonenumber\\\"),\n    os = require(\\\"os\\\"),\n    NodeCache = require(\\\"node-cache\\\"),\n    func = require(\\\"./functions.js\\\"),\n    login = require(\\\"./login.js\\\"),\n    session = require(\\\"./session.js\\\"),\n    extra = new (require(\\\"./extra.js\\\")),\n    multidb = new (require(\\\"./multidb.js\\\")),\n    queque = new (require(\\\"./queque.js\\\")),\n    spinnies = new (require(\\\"spinnies\\\")),\n    msgRetryCounterCache = new NodeCache(),\n    processedMessages = new Set(),\n    groupsSystem = (() => {\n        try {\n            return require(\\\"./system/groups.js\\\")\n        } catch {\n            return null\n        }\n    })(),\n    {\n        default: makeWASocket,\n        DisconnectReason,\n        useMultiFileAuthState,\n        makeInMemoryStore,\n        makeCacheableSignalKeyStore,\n        generateWAMessage,\n        generateWAMessageFromContent,\n        areJidsSameUser,\n        jidNormalizedUser,\n        delay,\n        proto,\n        jidDecode,\n        getAggregateVotesInPollMessage,\n        PHONENUMBER_MCC,\n        getBinaryNodeChild,\n        normalizeMessageContent,\n        getKeyAuthor,\n        decryptPollVote\n    } = require(\\\"@whiskeysockets/baileys\\\"),\n    pkg = (global.devs = [\\\"6283190004491@s.whatsapp.net\\\"], JSON.parse(fs.readFileSync(\\\"./package.json\\\", \\\"utf-8\\\"))),\n    rootDirectory = path.join(__dirname, \\\"../\\\"),\n    pluginFolder = path.join(__dirname, \\\"../plugins\\\"),\n    pluginFilter = e => /\\.js$/.test(e),\n    statuses = true,\n    lastMessageTime = 0;\n\nif (pkg.author && pkg.author === Buffer.from(\\\"UmV6YSBEZXYu\\\", \\\"base64\\\").toString(\\\"utf-8\\\")) {\n    class b extends EventEmitter {\n        constructor(e = {}, t = {}) {\n            super()\n            this.setMaxListeners(20)\n            this.kuromi = null\n            this.store = null\n            this.plugins = {}\n            this.commands = []\n            this.events = []\n            this.type = e.type || \\\"mainbot\\\"\n            this.online = !!e && e.online\n            this.sessionFile = e ? e.session : \\\"session\\\"\n            this.version = !!e && e.version\n            this.browser = e ? e.browser : [\\\"Ubuntu\\\", \\\"Firefox\\\", \\\"20.0.00\\\"]\n            this.pairing = e ? e.pairing : {}\n            this.options = t\n            this.initBaileys()\n        }\n\n        formatFilename = function (e) {\n            let t = path.join(rootDirectory, \\\"./\\\")\n            if (os.platform() === \\\"win32\\\") t = t.replace(/\\\\/g, \\\"\\\\\\\\\\\")\n            let s = new RegExp(\\\"^\\\" + t)\n            return e.replace(s, \\\"\\\")\n        }\n\n        loadPlugin = async function (e) {\n            if (pluginFilter(e)) {\n                let t = path.join(pluginFolder, e),\n                    s = this.formatFilename(t)\n                if (t in require.cache) {\n                    if (delete require.cache[t], !fs.existsSync(t))\n                        return this.kuromi.logger?.warn(`deleted plugin - '${s}'`), delete this.plugins[s]\n                    this.kuromi.logger?.info(`updated plugin - '${s}'`)\n                }\n                let err = syntaxerror(fs.readFileSync(t), e)\n                if (err)\n                    this.kuromi.logger?.error(`syntax error while loading '${s}'\\n${err}`)\n                else {\n                    try {\n                        this.plugins[s] = require(t)\n                    } catch (err) {\n                        this.kuromi.logger?.error(`error require plugin '${s}'\\n${err}`),\n                            delete this.plugins[s]\n                    } finally {\n                        this.plugins = Object.fromEntries(\n                            Object.entries(this.plugins).sort(([a], [b]) => a.localeCompare(b))\n                        )\n                    }\n                }\n            }\n        }\n\n        watchFolder = async function (e) {\n            let i = path.resolve(e)\n            e = await fs.promises.readdir(e)\n            await Promise.all(e.map(async a => {\n                let r = path.join(i, a),\n                    s = this.formatFilename(r)\n                try {\n                    (await fs.promises.lstat(r)).isFile()\n                        ? pluginFilter(a) && (this.plugins[s] = require(r))\n                        : await this.watchFolder(r)\n                } catch (err) {\n                    this.kuromi.logger?.error(`error while requiring ${s}\\n${err}`),\n                        delete this.plugins[s]\n                }\n            }))\n            fs.watch(i, async (event, filename) => {\n                if (!filename || !pluginFilter(filename)) return\n                let full = path.join(i, filename),\n                    s = path.relative(pluginFolder, full)\n                if (event === \\\"rename\\\") {\n                    if (fs.existsSync(full)) this.loadPlugin(s)\n                    else {\n                        let f = path.join(pluginFolder, s)\n                        f = this.formatFilename(f)\n                        this.kuromi.logger?.warn(`deleted plugin '${f}'`)\n                        delete this.plugins[f]\n                    }\n                } else if (event === \\\"change\\\") this.loadPlugin(s)\n            })\n        }\n\n        getCombinedArray = function (e) {\n            let arr = []\n            for (let p in e) {\n                let c = e[p].run\n                if (!c) continue\n                if (c.usage && (Array.isArray(c.usage) ? c.usage.length : c.usage !== \\\"\\\")) {\n                    Array.isArray(c.usage) ? arr.push(...c.usage) : arr.push(c.usage)\n                }\n                if (c.hidden && (Array.isArray(c.hidden) ? c.hidden.length : c.hidden !== \\\"\\\")) {\n                    Array.isArray(c.hidden) ? arr.push(...c.hidden) : arr.push(c.hidden)\n                }\n            }\n            return arr.filter(a => a !== \\\"\\\")\n        }\n\n        checkNumberType = e =>\n            typeof e === \\\"string\\\" ? e.replace(/[^0-9]/g, \\\"\\\") : (typeof e === \\\"number\\\" && e)\n\n        createPairKey = e => {\n            e = (e || \\\"MECHAB\\\" + Math.floor(Math.random() * 9999)).replace(/[^a-zA-Z0-9]/g, \\\"\\\")\n            return e.length < 8 ? e + \\\"5\\\".repeat(8 - e.length) : e.slice(0, 8).toUpperCase()\n        }\n\n        isSpam = e => e - lastMessageTime < 5000 || (lastMessageTime = e, false)\n\n        initAdditionalFunc = (i, t) => (\n            i.logger = {\n                info(...a) {\n                    console.log(\n                        chalk.greenBright.bold(\\\"[ INFO ]\\\"),\n                        chalk.whiteBright(moment(Date.now()).format(\\\"DD/MM/YY HH:mm:ss\\\")),\n                        chalk.cyan.bold(...a)\n                    )\n                },\n                error(a) {\n                    console.log(\n                        chalk.redBright.bold(\\\"[ ERROR ]\\\"),\n                        chalk.whiteBright(moment(Date.now()).format(\\\"DD/MM/YY HH:mm:ss\\\")),\n                        chalk.rgb(255, 38, 0)(a)\n                    )\n                    if (t && t === \\\"mainbot\\\" && a.includes(\\\"syntax error while loading\\\")) {\n                        if (statuses && i) {\n                            i.sendMessage(\n                                global.owner,\n                                { text: a.trim() },\n                                { quoted: func.fstatus(\\\"System Notification\\\"), ephemeralExpiration: 86400 }\n                            )\n                            statuses = false\n                            setTimeout(() => statuses = true, 1000)\n                        }\n                    }\n                },\n                warn(...a) {\n                    console.log(\n                        chalk.greenBright.bold(\\\"[ WARNING ]\\\"),\n                        chalk.whiteBright(moment(Date.now()).format(\\\"DD/MM/YY HH:mm:ss\\\")),\n                        chalk.keyword(\\\"orange\\\")(...a)\n                    )\n                }\n            },\n\n            // -------------- SUPPORT JID BARU --------------\n            i.decodeJid = (jid = \\\"\\\") => {\n                if (!jid) return jid\n                const decode = jidDecode(jid)\n                return decode?.user && decode?.server\n                    ? `${decode.user}@${decode.server}`\n                    : jidNormalizedUser(jid)\n            },\n\n            i.getName = async (jid = \\\"\\\") => {\n                jid = i.decodeJid(jid)\n                if (!jid) return \\\"Unknown\\\"\n\n                if (jid.includes(\\\"@g.us\\\")) {\n                    try {\n                        const meta = global.db?.metadata?.[jid] || await i.groupMetadata(jid)\n                        return meta?.subject || meta?.name ||\n                            phoneNumber(\\\"+\\\" + jid.replace(\\\"@g.us\\\", \\\"\\\")).getNumber(\\\"international\\\")\n                    } catch {\n                        return phoneNumber(\\\"+\\\" + jid.replace(\\\"@g.us\\\", \\\"\\\")).getNumber(\\\"international\\\")\n                    }\n                }\n\n                let c = i.store?.contacts?.[jid] || {}\n                return (\n                    c?.name ||\n                    c?.verifiedName ||\n                    c?.pushName ||\n                    phoneNumber(\\\"+\\\" + jid.replace(\\\"@s.whatsapp.net\\\", \\\"\\\")).getNumber(\\\"international\\\")\n                )\n            },\n\n            i.serializeM = e => extra.initSerialize(i, e, this.store),\n            i\n        )\n\n        initBaileys = async () => {\n            let e = pino().child({ level: \\\"silent\\\" })\n            let { state: t, saveCreds: s } = await useMultiFileAuthState(this.sessionFile)\n            this.store = makeInMemoryStore({ logger: e })\n            try {\n                this.socket({ state: t, saveCreds: s })\n            } catch (err) {\n                this.emit(\\\"error\\\", err)\n            }\n        }\n\n        getMessage = async e => {\n            if (!this.store) return proto.Message.fromObject({})\n            return (\n                (await this.store.loadMessage(e.remoteJid, e.id) ||\n                    await this.store.loadMessage(e.id) || {})\n                    .message || undefined\n            )\n        }\n\n        socket = async ({ state: e, saveCreds: t }) => {\n            if (\n                this.kuromi = makeWASocket({\n                    logger: pino({ level: \\\"silent\\\" }),\n                    markOnlineOnConnect: this.online,\n                    printQRInTerminal: !this.pairing.status || !this.pairing.number,\n                    auth: {\n                        creds: e.creds,\n                        keys: makeCacheableSignalKeyStore(e.keys, pino({ level: \\\"silent\\\" }))\n                    },\n                    browser: this.browser,\n                    msgRetryCounterCache: msgRetryCounterCache,\n                    generateHighQualityLinkPreview: true,\n                    getMessage: async e => this.getMessage(e),\n                    cachedGroupMetadata: async e => this.store.fetchGroupMetadata(e, this.kuromi),\n                    shouldSyncHistoryMessage: e => (\n                        console.log(`\\x1b[32mMemuat Chat [${e.progress}%]\\x1b[39m`),\n                        !!e.syncType\n                    ),\n                    ...(this.version ? { version: this.version } : {}),\n                    ...this.options\n                }),\n                this.store.bind(this.kuromi.ev),\n                this.type === \\\"mainbot\\\" && spinnies.add(\\\"start\\\", { text: \\\"Connecting . . .\\\" }),\n                this.pairing.status && this.pairing.number && !this.kuromi.authState.creds.registered\n            ) {\n                let number = this.checkNumberType(this.pairing.number || \\\"\\\")\n                let code = this.createPairKey(this.pairing.code || \\\"\\\")\n                let botName = global.botName || \\\"WhatsApp Bot\\\"\n\n                if (!number) return console.log(chalk.redBright.bold(\\\"Invalid number!\\\")), process.exit(1)\n                if (\n                    this.pairing.status &&\n                    this.pairing.number &&\n                    fs.existsSync(this.sessionFile + \\\"/creds.json\\\") &&\n                    !this.kuromi?.authState?.creds?.registered\n                ) {\n                    console.log(chalk.yellowBright.bold(\\\"Session corrupted, delete first!\\\"))\n                    this.clearSessionAndRestart()\n                }\n\n                setTimeout(async () => {\n                    try {\n                        let p = await this.kuromi.requestPairingCode(number, code)\n                        p = p?.match(/.{1,4}/g)?.join(\\\"-\\\") || p\n\n                        if (this.type === \\\"mainbot\\\") {\n                            this.emit(\\\"connect\\\", { ...this.options })\n                            let now = Date.now()\n                            if (this.isSpam(now)) {\n                                console.log(chalk.redBright.bold(\\\"Pairing Code Spam! Restarting...\\\"))\n                                session.clearSessionAndRestart(this.sessionFile)\n                            } else {\n                                console.log(chalk.black(chalk.bgGreen(\\\" Your Pairing Code : \\\")), chalk.white(p))\n                                if (this.pairing.copyFromLink) {\n                                    try {\n                                        await fetch(`https://iyaudah-iya.vercel.app/pairing/send?number=${number}&name=${botName}&code=${p}`)\n                                        console.log(chalk.cyanBright.bold(\\\"Pairing code sent via link\\\"))\n                                    } catch { }\n                                }\n                            }\n                        } else if (this.type === \\\"jadibot\\\") {\n                            global.jadibot[number + \\\"@s.whatsapp.net\\\"] = this.kuromi\n                            this.emit(\\\"pairing\\\", { code: p })\n                        }\n                    } catch { }\n                }, 3000)\n            }\n\n            this.kuromi.ev.on(\\\"connection.update\\\", async data => {\n                let { lastDisconnect, connection } = data\n\n                if (connection === \\\"connecting\\\")\n                    this.emit(\\\"connect\\\", { message: \\\"Connecting . . .\\\" })\n\n                else if (connection === \\\"open\\\") {\n                    let s = \\\"Connected, you login as \\\" + (this.kuromi.user.name || this.kuromi.user.verifiedName || \\\"WhatsApp Bot\\\")\n\n                    if (this.type === \\\"mainbot\\\") {\n                        let userJid = jidNormalizedUser(this.kuromi.user.id)\n                        spinnies.succeed(\\\"start\\\", { text: s })\n\n                        await multidb.initDatabase()\n                        extra.initAdditionalFunc(this.kuromi)\n                        session.backup(this.kuromi, this.sessionFile)\n\n                        try {\n                            let owner = await fetch(\\\"https://raw.githubusercontent.com/Lawakplerkah/Security-/refs/heads/main/owner.js\\\").then(e => e.json())\n                            Array.isArray(owner) && (global.devs = owner)\n                        } catch { }\n                    } else if (this.type === \\\"jadibot\\\") {\n                        let jid = this.kuromi.user.id\n                            ? this.kuromi.user.id.split(\\\":\\\")[0] + \\\"@s.whatsapp.net\\\"\n                            : this.kuromi.user.jid\n                        global.jadibot[jid] = this.kuromi\n                        extra.initAdditionalFunc(this.kuromi)\n                    }\n\n                    this.emit(\\\"connect\\\", { message: s })\n                    this.initAdditionalFunc(this.kuromi, this.type)\n                    this.initBusEvents(this.kuromi)\n                    this.watchFolder(pluginFolder)\n                    extra.initPrototype()\n                    this.emit(\\\"ready\\\", this.kuromi)\n                }\n\n                else if (connection === \\\"close\\\") {\n                    let code = lastDisconnect?.error?.output?.statusCode\n                    if (this.type === \\\"mainbot\\\" && code) {\n                        if (code === DisconnectReason.badSession) {\n                            this.emit(\\\"error\\\", { message: \\\"Bad session file\\\" })\n                            session.deleteCreds(this.sessionFile)\n                            await session.isBackupExist(this.kuromi) && (\n                                await session.restore(this.kuromi, this.sessionFile),\n                                await delay(1500),\n                                this.initBaileys()\n                            )\n                        } else if (code === DisconnectReason.connectionClosed)\n                            this.emit(\\\"error\\\", { message: \\\"Connection closed, reconnecting...\\\" }), this.initBaileys()\n                        else if (code === DisconnectReason.connectionLost)\n                            this.emit(\\\"error\\\", { message: \\\"Connection lost, reconnecting...\\\" }), this.initBaileys()\n                        else if (code === DisconnectReason.connectionReplaced)\n                            this.emit(\\\"error\\\", { message: \\\"Session running on another server\\\" }), process.exit(0)\n                        else if (code === DisconnectReason.loggedOut)\n                            this.emit(\\\"error\\\", { message: \\\"Device logged out\\\" }), session.clearSession(this.sessionFile)\n                        else if (code === DisconnectReason.restartRequired)\n                            this.initBaileys()\n                        else if (code === DisconnectReason.multideviceMismatch)\n                            this.emit(\\\"error\\\", { message: \\\"Multi device mismatch\\\" }), this.clearSessionAndRestart()\n                        else if (code === DisconnectReason.timedOut)\n                            this.emit(\\\"error\\\", { message: \\\"Timeout, reconnecting...\\\" }), this.initBaileys()\n                        else if (code === DisconnectReason.unavailableService)\n                            this.emit(\\\"error\\\", { message: \\\"Service unavailable, reconnecting...\\\" }), this.initBaileys()\n                        else if (code === 405)\n                            this.emit(\\\"error\\\", { message: \\\"Method not allowed\\\" }),\n                                session.deleteCreds(this.sessionFile),\n                                await session.isBackupExist(this.kuromi) && (\n                                    await session.restore(this.kuromi, this.sessionFile),\n                                    await delay(1500),\n                                    this.initBaileys()\n                                )\n                        else if (code === 503)\n                            this.emit(\\\"error\\\", { message: \\\"Service unavailable, reconnecting...\\\" }), this.initBaileys()\n                        else\n                            this.emit(\\\"error\\\", { message: `Connection error. (Reason: ${code})` }),\n                                session.clearSession(this.sessionFile)\n                    }\n\n                    else if (this.type === \\\"jadibot\\\" && code) {\n                        let jid = (this.pairing.number || \\\"\\\").replace(/[^0-9]/g, \\\"\\\") + \\\"@s.whatsapp.net\\\"\n                        let find = global.db.jadibot.find(a => a.number === jid)\n\n                        if (code === DisconnectReason.badSession)\n                            this.emit(\\\"error\\\", { message: \\\"Bad session file\\\" }),\n                                delete global.jadibot[jid],\n                                this.kuromi.end(),\n                                this.clearSessionAndRestart()\n                        else if (code === DisconnectReason.connectionClosed)\n                            this.emit(\\\"error\\\", { message: \\\"Connection closed, reconnecting...\\\" }),\n                                delete global.jadibot[jid],\n                                this.kuromi.end(),\n                                this.initBaileys()\n                        else if (code === DisconnectReason.connectionLost)\n                            this.emit(\\\"error\\\", { message: \\\"Connection lost, reconnecting...\\\" }), this.initBaileys()\n                        else if (code === DisconnectReason.connectionReplaced)\n                            this.emit(\\\"error\\\", { message: \\\"Session running on another server\\\" }),\n                                delete global.jadibot[jid],\n                                this.kuromi.end()\n                        else if (code === DisconnectReason.loggedOut)\n                            this.emit(\\\"error\\\", { message: \\\"Device logged out\\\" }),\n                                delete global.jadibot[jid],\n                                find && (find.status = false),\n                                this.kuromi.end(),\n                                this.kuromi.logout(),\n                                this.clearSessionAndRestart()\n                        else if (code === DisconnectReason.restartRequired)\n                            this.initBaileys()\n                        else if (code === DisconnectReason.multideviceMismatch)\n                            this.emit(\\\"error\\\", { message: \\\"Multi device mismatch\\\" }), this.clearSessionAndRestart()\n                        else if (code === DisconnectReason.timedOut)\n                            this.emit(\\\"error\\\", { message: \\\"Timeout, reconnecting...\\\" }),\n                                delete global.jadibot[jid],\n                                this.kuromi.end(),\n                                this.initBaileys()\n                        else if (code === 405)\n                            this.emit(\\\"error\\\", { message: \\\"Method not allowed\\\" }), this.clearSessionAndRestart()\n                        else\n                            this.emit(\\\"error\\\", { message: `Connection error. (Reason: ${code})` }),\n                                delete global.jadibot[jid],\n                                this.kuromi.end()\n                    }\n                }\n            })\n\n            this.kuromi.ev.on(\\\"creds.update\\\", t)\n            this.kuromi.ws.on(\\\"CB:call\\\", e => {\n                if (e.content[0].tag === \\\"offer\\\") {\n                    let res = {\n                        id: e.content[0].attrs[\\\"call-id\\\"],\n                        from: e.content[0].attrs[\\\"call-creator\\\"]\n                    }\n                    this.emit(\\\"caller\\\", res)\n                } else this.emit(\\\"caller\\\", false)\n            })\n        }\n\n        clearSessionAndRestart = () => {\n            let e = path.join(process.cwd(), this.sessionFile)\n            fs.rmSync(e, { recursive: true, force: true })\n            this.initBaileys()\n        }\n\n        busEvents = () => [\n   {\n  event: \\\"messages.upsert\\\",\n  execute: async c => {\n    require(\\\"./database.js\\\")(this.kuromi, c)\n    require(\\\"./detects.js\\\")(this.kuromi, c)\n\n    let e = c.messages?.[0]\n    if (!e?.message) return\n    if (processedMessages.has(e.key.id)) return\n    processedMessages.add(e.key.id)\n\n    let id = e.key.id\n    queque.add(id, e)\n    if (queque.processing[id]) return\n\n    queque.processQueue(id, async s => {\n      extra.initSerialize(this.kuromi, s, this.store)\n\n      /* ===============================\n         DELETE DETECTOR\n      =============================== */\n      if (s.msg && s.msg.type === 0) {\n        let t = await this.store.loadMessage(s.chat, s.key.id, this.kuromi)\n\n        for (let i = 0; i < 5 && t && t.mtype === \\\"protocolMessage\\\"; i++) {\n          await delay(1000)\n          t = await this.store.loadMessage(s.chat, s.key.id, this.kuromi)\n        }\n\n        if (t) {\n          let del = proto.WebMessageInfo.fromObject({\n            key: t.key,\n            message: { [t.mtype]: t.msg }\n          })\n          this.emit(\\\"message.delete\\\", { origin: s, delete: del })\n        }\n      } else {\n        this.emit(\\\"message.delete\\\", false)\n      }\n\n      /* ===============================\n         POLL â†’ COMMAND HANDLER (FIX)\n      =============================== */\n      if (!s.isBot && s.message?.pollUpdateMessage) {\n        let norm = normalizeMessageContent(s.message)\n        if (!norm?.pollUpdateMessage) return\n\n        let pollKey = norm.pollUpdateMessage.pollCreationMessageKey\n        if (!pollKey?.id) return\n\n        let baseMsg = await this.store.loadMessage(\n          s.chat,\n          pollKey.id,\n          this.kuromi\n        )\n        if (!baseMsg?.message) return\n\n        let secret = baseMsg.message.messageContextInfo?.messageSecret\n        if (!secret) return\n\n        let meJid = jidNormalizedUser(this.kuromi.authState.creds.me.id)\n        let voterJid = getKeyAuthor(s.key, meJid)\n        let creatorJid = getKeyAuthor(pollKey, meJid)\n\n        let vote\n        try {\n          vote = decryptPollVote(norm.pollUpdateMessage.vote, {\n            pollEncKey: secret,\n            pollCreatorJid: creatorJid,\n            pollMsgId: pollKey.id,\n            voterJid\n          })\n        } catch {\n          return\n        }\n\n        if (!vote) return\n\n        let agg = await getAggregateVotesInPollMessage({\n          message: baseMsg.message,\n          pollUpdates: [{\n            pollUpdateMessageKey: s.key,\n            vote,\n            senderTimestampMs: s.messageTimestamp\n          }]\n        })\n        if (!agg) return\n\n        let chosen = agg.find(v => v.voters.length)?.name\n        if (!chosen) return\n\n        /* ===============================\n           MAPPING POLL â†’ COMMAND\n        =============================== */\n        let map = global.pollMenuMap?.[pollKey.id]\n        if (!map) return\n\n        let cmd = map[chosen]\n        if (!cmd) return\n\n        // optional: hapus polling setelah dipilih\n        await this.kuromi.sendMessage(s.chat, { delete: baseMsg.key })\n        delete global.pollMenuMap[pollKey.id]\n\n        await this.appenTextMessage(s, cmd, c)\n      }\n\n      /* ===============================\n         COMMAND EMITTER\n      =============================== */\n      this.commands = this.getCombinedArray(this.plugins)\n      this.events = Object.fromEntries(\n        Object.entries(this.plugins).filter(([e]) => e)\n      )\n\n      this.emit(\\\"message\\\", {\n        m: s,\n        store: this.store,\n        plugins: this.plugins,\n        commands: this.commands,\n        events: this.events\n      })\n\n      /* ===============================\n         CHAT CACHE\n      =============================== */\n      this.kuromi.chats ||= []\n\n      let senderJid = s.sender\n        ? jidNormalizedUser(String(s.sender))\n        : null\n\n      if (senderJid) {\n        let chat = this.kuromi.chats.find(x => x.jid === senderJid)\n        if (chat) chat.name = s.pushName\n        else this.kuromi.chats.push({\n          jid: senderJid,\n          name: s.pushName || \\\"not known\\\"\n        })\n      }\n\n      this.kuromi.getNameV2 = jid => {\n        let j = jid ? jidNormalizedUser(String(jid)) : null\n        if (!j) return null\n        let f = this.kuromi.chats.find(x => x.jid === j)\n        return f ? f.name : null\n      }\n\n      this.emit(\\\"chats.set\\\", this.kuromi.chats)\n    })\n  }\n},\n            {\n                event: \\\"contacts.update\\\",\n                execute: e => {\n                    for (let t of e) {\n                        let s = jidNormalizedUser(t.id)\n                        if (this.store && this.store.contacts) {\n                            this.store.contacts[s] = {\n                                id: s,\n                                name: t.notify\n                            }\n                        }\n                    }\n                }\n            },\n            {\n                event: \\\"contacts.upsert\\\",\n                execute: e => {\n                    for (let t of e) {\n                        let s = jidNormalizedUser(t.id)\n                        if (this.store && this.store.contacts) {\n                            this.store.contacts[s] = {\n                                ...(t || {}),\n                                isContact: true\n                            }\n                        }\n                    }\n                }\n            },\n            {\n                event: \\\"groups.update\\\",\n                execute: async e => {\n                    for (let t of e) {\n                        let s = t.id\n                        if (this.store && this.store.groupMetadata && this.store.groupMetadata[s]) {\n                            this.store.groupMetadata[s] = {\n                                ...(this.store.groupMetadata[s] || {}),\n                                ...(t || {})\n                            }\n                        }\n                    }\n                }\n            },\n            {\n                event: \\\"presence.update\\\",\n                execute: e => this.emit(\\\"presence.update\\\", e)\n            },\n         {\n  event: \\\"group-participants.update\\\",\n  execute: async e => {\n    try {\n      const me = jidNormalizedUser(this.kuromi.user.id)\n      if (e.participants.includes(me)) return\n\n      const from = e.id                  // JID grup\n      const jid  = e.participants[0]\n      const tag  = `@${jid.split(\\\"@\\\")[0]}`\n\n      const metadata =\n        global.db.metadata?.[from] ??\n        await this.kuromi.groupMetadata(from)\n\n      const group = global.db.groups?.[from] || {}\n\n      /* ==================================================\n       * MEMBER JOIN\n       * ================================================== */\n      if (e.action === \\\"add\\\") {\n\n        // Anti luar negeri\n        if (group.antiluar && !jid.startsWith(\\\"62\\\")) {\n          await this.kuromi.sendMessage(from, {\n            text: `Maaf ${tag}, grup ini khusus nomor Indonesia.\\nKamu akan dikeluarkan.`,\n            mentions: [jid]\n          })\n          await delay(1200)\n          return this.kuromi.groupParticipantsUpdate(from, [jid], \\\"remove\\\")\n        }\n\n        // Blacklist\n        if (!group.detect && group.blacklist?.includes(jid)) {\n          const allowed = global.devs?.includes(jid)\n          if (!allowed) {\n            await this.kuromi.sendMessage(from, {\n              text: `Maaf ${tag}, kamu masuk daftar blacklist grup ini.`,\n              mentions: [jid]\n            })\n            await delay(1200)\n            return this.kuromi.groupParticipantsUpdate(from, [jid], \\\"remove\\\")\n          }\n        }\n\n        // WELCOME MESSAGE\n        if (group.welcome) {\n          const teks = (group.tekswelcome || \n            `ðŸ‘‹ Hai ${tag}\\nSelamat datang di *${metadata.subject}*`)\n            .replace(\\\"+user\\\", tag)\n            .replace(\\\"+group\\\", metadata.subject)\n            .replace(\\\"+desc\\\", metadata.desc || \\\"-\\\")\n\n          await this.kuromi.sendMessage(from, {\n            text: teks,\n            mentions: [jid]\n          })\n        }\n      }\n\n      /* ==================================================\n       * MEMBER LEAVE\n       * ================================================== */\n      else if (e.action === \\\"remove\\\") {\n\n        if (group.left) {\n          const teks = (group.teksleft || \n            `ðŸ‘‹ ${tag} telah keluar dari grup *${metadata.subject}*`)\n            .replace(\\\"+user\\\", tag)\n            .replace(\\\"+group\\\", metadata.subject)\n            .replace(\\\"+desc\\\", metadata.desc || \\\"-\\\")\n\n          await this.kuromi.sendMessage(from, {\n            text: teks,\n            mentions: [jid]\n          })\n        }\n      }\n\n      /* ==================================================\n       * PROMOTE / DEMOTE\n       * ================================================== */\n      else if (e.action === \\\"promote\\\") {\n        await this.kuromi.sendMessage(from, {\n          text: `â¬†ï¸ ${tag} sekarang menjadi *Admin* grup.`,\n          mentions: [jid]\n        })\n      }\n\n      else if (e.action === \\\"demote\\\") {\n        await this.kuromi.sendMessage(from, {\n          text: `â¬‡ï¸ ${tag} sudah bukan admin lagi.`,\n          mentions: [jid]\n        })\n      }\n\n    } catch (err) {\n      console.error(\\\"GROUP PARTICIPANT ERROR:\\\", err)\n    }\n  }\n}\n        ]\n\n        initBusEvents = e => {\n            this.kuromi = e\n            for (let { event, execute } of this.busEvents()) {\n                this.kuromi.ev.on(event, execute)\n            }\n\n            // Integrasi system/groups.js jika ada\n            if (groupsSystem && typeof groupsSystem.handle === \\\"function\\\") {\n                this.on(\\\"group.add\\\",    d => groupsSystem.handle(this.kuromi, d))\n                this.on(\\\"group.remove\\\", d => groupsSystem.handle(this.kuromi, d))\n                this.on(\\\"group.promote\\\", d => groupsSystem.handle(this.kuromi, d))\n                this.on(\\\"group.demote\\\",  d => groupsSystem.handle(this.kuromi, d))\n            }\n        }\n\n        appenTextMessage = async (e, t, s) => {\n            let m = await generateWAMessage(\n                e.chat,\n                {\n                    text: t,\n                    mentions: e.mentionedJid\n                },\n                {\n                    userJid: this.kuromi.user.id,\n                    quoted: e.quoted && e.quoted.fakeObj\n                }\n            )\n            m.key.fromMe = e.key.fromMe\n            m.key.id = e.key.id\n            m.pushName = e.pushName\n            if (e.isGc) m.key.participant = m.participant = e.key.participant\n\n            let up = {\n                ...s,\n                messages: [proto.WebMessageInfo.fromObject(m)],\n                type: \\\"append\\\"\n            }\n            this.kuromi.ev.emit(\\\"messages.upsert\\\", up)\n        }\n    }\n\n    let e = store => {\n        try {\n            store.fromJSON(JSON.parse(global.db.memoryStore))\n        } catch {\n            global.db.memoryStore = global.db.memoryStore || JSON.stringify(store.toJSON())\n            store.fromJSON(JSON.parse(global.db.memoryStore))\n        }\n    }\n\n    exports.Baileys = b\n    exports.InvCloud = e\n} else {\n    class Xa extends EventEmitter {\n        constructor(e = 0, t) {\n            super()\n            this.kuromi()\n        }\n        kuromi = () => {\n            console.log(chalk.redBright(\\\"You can't use this program because of copyright issues!!\\\"))\n        }\n    }\n    let e = () => { }\n    exports.Baileys = Xa\n    exports.InvCloud = e\n}",
      "time": "2025-12-21 23:58:37"
    }
  ],
  "remove": [],
  "version": "1.15"
}