{
  "update": [
    {
      "path": "plugins/group/listadmin.js",
      "code": "/* CODE LAIN CHEK\nhttps://whatsapp.com/channel/0029VbARSvBCMY0PDV53rt0m\nJANGAN LUPA FOLLOW\n*/\n\n//CREATE BY REZA DEVS KUROMI\nlet ms=require(\\\"parse-ms\\\");function timeReverse(e){var i=(e=ms(e-Date.now())).days,a=e.hours,r=e.minutes;return(0<i?i+\\\"d\\\":\\\"\\\")+(0<a?(0<i?\\\" \\\":\\\"\\\")+a+\\\"h\\\":\\\"\\\")+(0<r?(0<a?\\\" \\\":\\\"\\\")+r+\\\"m\\\":\\\"\\\")+(0<(e=e.seconds)?(0<r?\\\" \\\":\\\"\\\")+e+\\\"s\\\":\\\"\\\")}exports.run={usage:[\\\"listadmin\\\"],hidden:[\\\"adminlist\\\"],category:\\\"group\\\",async:async(e,{})=>{let i=e.metadata.participants.filter(e=>e.admin),a=global.db.groups[e.chat].member,r=i.map((e,i)=>`${i+1}. @${e.jid.split(\\\"@\\\")[0]} `+(void 0!==a[e.jid]&&a[e.jid].admin&&0!=a[e.jid].expired?`_*(${timeReverse(a[e.jid].expired)})*_`:\\\"\\\")).join(\\\"\\n\\\"),s=\\\"乂  *L I S T - A D M I N*\\n\\n\\\";s+=\\\"Total : \\\"+i.length,e.reply(s+=`\n`+r)},group:!0};"
    },
    {
      "path": "system/baileys.js",
      "code": "let EventEmitter = require(\\\"events\\\").EventEmitter,\n    chalk = require(\\\"chalk\\\"),\n    fs = require(\\\"fs\\\"),\n    path = require(\\\"path\\\"),\n    pino = require(\\\"pino\\\"),\n    moment = require(\\\"moment-timezone\\\"),\n    syntaxerror = require(\\\"syntax-error\\\"),\n    phoneNumber = require(\\\"awesome-phonenumber\\\"),\n    os = require(\\\"os\\\"),\n    NodeCache = require(\\\"node-cache\\\"),\n    func = require(\\\"./functions.js\\\"),\n    login = require(\\\"./login.js\\\"),\n    session = require(\\\"./session.js\\\"),\n    extra = new (require(\\\"./extra.js\\\")),\n    multidb = new (require(\\\"./multidb.js\\\")),\n    queque = new (require(\\\"./queque.js\\\")),\n    spinnies = new (require(\\\"spinnies\\\")),\n    msgRetryCounterCache = new NodeCache(),\n    processedMessages = new Set(),\n    {\n        default: makeWASocket,\n        DisconnectReason,\n        useMultiFileAuthState,\n        makeInMemoryStore,\n        makeCacheableSignalKeyStore,\n        generateWAMessage,\n        generateWAMessageFromContent,\n        areJidsSameUser,\n        jidNormalizedUser,\n        delay,\n        proto,\n        jidDecode,\n        getAggregateVotesInPollMessage,\n        PHONENUMBER_MCC,\n        getBinaryNodeChild,\n        normalizeMessageContent,\n        getKeyAuthor,\n        decryptPollVote\n    } = require(\\\"@whiskeysockets/baileys\\\"),\n    pkg = (global.devs = [\\\"6283894064758@s.whatsapp.net\\\"], JSON.parse(fs.readFileSync(\\\"./package.json\\\", \\\"utf-8\\\"))),\n    rootDirectory = path.join(__dirname, \\\"../\\\"),\n    pluginFolder = path.join(__dirname, \\\"../plugins\\\"),\n    pluginFilter = e => /\\.js$/.test(e),\n    statuses = true,\n    lastMessageTime = 0;\n\nif (pkg.author && pkg.author === Buffer.from(\\\"UmV6YSBEZXYu\\\", \\\"base64\\\").toString(\\\"utf-8\\\")) {\n    class b extends EventEmitter {\n        constructor(e = {}, t = {}) {\n            super()\n            this.setMaxListeners(20)\n            this.kuromi = null\n            this.store = null\n            this.plugins = {}\n            this.commands = []\n            this.events = []\n            this.type = e.type || \\\"mainbot\\\"\n            this.online = !!e && e.online\n            this.sessionFile = e ? e.session : \\\"session\\\"\n            this.version = !!e && e.version\n            this.browser = e ? e.browser : [\\\"Ubuntu\\\", \\\"Firefox\\\", \\\"20.0.00\\\"]\n            this.pairing = e ? e.pairing : {}\n            this.options = t\n            this.initBaileys()\n        }\n\n        formatFilename = function (e) {\n            let t = path.join(rootDirectory, \\\"./\\\")\n            if (os.platform() === \\\"win32\\\") t = t.replace(/\\\\/g, \\\"\\\\\\\\\\\")\n            let s = new RegExp(\\\"^\\\" + t)\n            return e.replace(s, \\\"\\\")\n        }\n\n        loadPlugin = async function (e) {\n            if (pluginFilter(e)) {\n                let t = path.join(pluginFolder, e),\n                    s = this.formatFilename(t)\n                if (t in require.cache) {\n                    if (delete require.cache[t], !fs.existsSync(t))\n                        return this.kuromi.logger?.warn(`deleted plugin - '${s}'`), delete this.plugins[s]\n                    this.kuromi.logger?.info(`updated plugin - '${s}'`)\n                }\n                if (e = syntaxerror(fs.readFileSync(t), e))\n                    this.kuromi.logger?.error(`syntax error while loading '${s}'\\n${e}`)\n                else {\n                    try {\n                        this.plugins[s] = require(t)\n                    } catch (err) {\n                        this.kuromi.logger?.error(`error require plugin '${s}'\\n${err}`),\n                            delete this.plugins[s]\n                    } finally {\n                        this.plugins = Object.fromEntries(Object.entries(this.plugins).sort(([a], [b]) => a.localeCompare(b)))\n                    }\n                }\n            }\n        }\n\n        watchFolder = async function (e) {\n            let i = path.resolve(e)\n            e = await fs.promises.readdir(e)\n            await Promise.all(e.map(async a => {\n                let r = path.join(i, a),\n                    s = this.formatFilename(r)\n                try {\n                    (await fs.promises.lstat(r)).isFile()\n                        ? pluginFilter(a) && (this.plugins[s] = require(r))\n                        : await this.watchFolder(r)\n                } catch (err) {\n                    this.kuromi.logger?.error(`error while requiring ${s}\\n${err}`),\n                        delete this.plugins[s]\n                }\n            }))\n            fs.watch(i, async (event, filename) => {\n                if (!filename || !pluginFilter(filename)) return\n                let full = path.join(i, filename),\n                    s = path.relative(pluginFolder, full)\n                if (event === \\\"rename\\\") {\n                    if (fs.existsSync(full)) this.loadPlugin(s)\n                    else {\n                        let f = path.join(pluginFolder, s)\n                        f = this.formatFilename(f)\n                        this.kuromi.logger.warn(`deleted plugin '${f}'`)\n                        delete this.plugins[f]\n                    }\n                } else if (event === \\\"change\\\") this.loadPlugin(s)\n            })\n        }\n\n        getCombinedArray = function (e) {\n            let arr = []\n            for (let p in e) {\n                let c = e[p].run\n                if (!c) continue\n                if (c.usage && (Array.isArray(c.usage) ? c.usage.length : c.usage !== \\\"\\\")) {\n                    Array.isArray(c.usage) ? arr.push(...c.usage) : arr.push(c.usage)\n                }\n                if (c.hidden && (Array.isArray(c.hidden) ? c.hidden.length : c.hidden !== \\\"\\\")) {\n                    Array.isArray(c.hidden) ? arr.push(...c.hidden) : arr.push(c.hidden)\n                }\n            }\n            return arr.filter(a => a !== \\\"\\\")\n        }\n\n        checkNumberType = e => typeof e === \\\"string\\\" ? e.replace(/[^0-9]/g, \\\"\\\") : (typeof e === \\\"number\\\" && e)\n\n        createPairKey = e => {\n            e = (e || \\\"MECHAB\\\" + Math.floor(Math.random() * 9999)).replace(/[^a-zA-Z0-9]/g, \\\"\\\")\n            return e.length < 8 ? e + \\\"5\\\".repeat(8 - e.length) : e.slice(0, 8).toUpperCase()\n        }\n\n        isSpam = e => e - lastMessageTime < 5000 || (lastMessageTime = e, false)\n\n        initAdditionalFunc = (i, t) => (\n            i.logger = {\n                info(...a) {\n                    console.log(chalk.greenBright.bold(\\\"[ INFO ]\\\"), chalk.whiteBright(moment(Date.now()).format(\\\"DD/MM/YY HH:mm:ss\\\")), chalk.cyan.bold(...a))\n                },\n                error(a) {\n                    console.log(chalk.redBright.bold(\\\"[ ERROR ]\\\"), chalk.whiteBright(moment(Date.now()).format(\\\"DD/MM/YY HH:mm:ss\\\")), chalk.rgb(255, 38, 0)(a))\n                    if (t && t === \\\"mainbot\\\" && a.includes(\\\"syntax error while loading\\\")) {\n                        if (statuses && i) {\n                            i.sendMessage(global.owner, { text: a.trim() }, { quoted: func.fstatus(\\\"System Notification\\\"), ephemeralExpiration: 86400 })\n                            statuses = false\n                            setTimeout(() => statuses = true, 1000)\n                        }\n                    }\n                },\n                warn(...a) {\n                    console.log(chalk.greenBright.bold(\\\"[ WARNING ]\\\"), chalk.whiteBright(moment(Date.now()).format(\\\"DD/MM/YY HH:mm:ss\\\")), chalk.keyword(\\\"orange\\\")(...a))\n                }\n            },\n\n            // -------------- SUPPORT JID BARU --------------\n            i.decodeJid = (jid = \\\"\\\") => {\n                if (!jid) return jid\n                const decode = jidDecode(jid)\n                return decode?.user && decode?.server ? `${decode.user}@${decode.server}` : jidNormalizedUser(jid)\n            },\n\n            i.getName = async (jid = \\\"\\\") => {\n                jid = i.decodeJid(jid)\n                if (!jid) return \\\"Unknown\\\"\n\n                if (jid.includes(\\\"@g.us\\\")) {\n                    try {\n                        const meta = global.db?.metadata?.[jid] || await i.groupMetadata(jid)\n                        return meta?.subject || meta?.name || phoneNumber(\\\"+\\\" + jid.replace(\\\"@g.us\\\", \\\"\\\")).getNumber(\\\"international\\\")\n                    } catch {\n                        return phoneNumber(\\\"+\\\" + jid.replace(\\\"@g.us\\\", \\\"\\\")).getNumber(\\\"international\\\")\n                    }\n                }\n\n                let c = i.store?.contacts?.[jid] || {}\n                return (\n                    c?.name ||\n                    c?.verifiedName ||\n                    c?.pushName ||\n                    phoneNumber(\\\"+\\\" + jid.replace(\\\"@s.whatsapp.net\\\", \\\"\\\")).getNumber(\\\"international\\\")\n                )\n            },\n\n            i.serializeM = e => extra.initSerialize(i, e, this.store),\n            i\n        )\n        initBaileys = async () => {\n            let e = pino().child({ level: \\\"silent\\\" })\n            let { state: t, saveCreds: s } = await useMultiFileAuthState(this.sessionFile)\n            this.store = makeInMemoryStore({ logger: e })\n            try {\n                this.socket({ state: t, saveCreds: s })\n            } catch (err) {\n                this.emit(\\\"error\\\", err)\n            }\n        }\n\n        getMessage = async e => {\n            if (!this.store) return proto.Message.fromObject({})\n            return (\n                (await this.store.loadMessage(e.remoteJid, e.id) ||\n                await this.store.loadMessage(e.id) || {})\n                    .message || undefined\n            )\n        }\n\n        socket = async ({ state: e, saveCreds: t }) => {\n            if (\n                this.kuromi = makeWASocket({\n                    logger: pino({ level: \\\"silent\\\" }),\n                    markOnlineOnConnect: this.online,\n                    printQRInTerminal: !this.pairing.status || !this.pairing.number,\n                    auth: {\n                        creds: e.creds,\n                        keys: makeCacheableSignalKeyStore(e.keys, pino({ level: \\\"silent\\\" }))\n                    },\n                    browser: this.browser,\n                    msgRetryCounterCache: msgRetryCounterCache,\n                    generateHighQualityLinkPreview: true,\n                    getMessage: async e => this.getMessage(e),\n                    cachedGroupMetadata: async e => this.store.fetchGroupMetadata(e, this.kuromi),\n                    shouldSyncHistoryMessage: e => (\n                        console.log(`\\x1b[32mMemuat Chat [${e.progress}%]\\x1b[39m`),\n                        !!e.syncType\n                    ),\n                    ...(this.version ? { version: this.version } : {}),\n                    ...this.options\n                }),\n                this.store.bind(this.kuromi.ev),\n                this.type === \\\"mainbot\\\" && spinnies.add(\\\"start\\\", { text: \\\"Connecting . . .\\\" }),\n                this.pairing.status && this.pairing.number && !this.kuromi.authState.creds.registered\n            ) {\n                let number = this.checkNumberType(this.pairing.number || \\\"\\\")\n                let code = this.createPairKey(this.pairing.code || \\\"\\\")\n                let botName = global.botName || \\\"WhatsApp Bot\\\"\n\n                if (!number) return console.log(chalk.redBright.bold(\\\"Invalid number!\\\")), process.exit(1)\n                if (this.pairing.status && this.pairing.number & fs.existsSync(this.sessionFile + \\\"/creds.json\\\") && !this.kuromi?.authState?.creds?.registered) {\n                    console.log(chalk.yellowBright.bold(\\\"Session corrupted, delete first!\\\"))\n                    this.clearSessionAndRestart()\n                }\n\n                setTimeout(async () => {\n                    try {\n                        let p = await this.kuromi.requestPairingCode(number, code)\n                        p = p.match(/.{1,4}/g).join(\\\"-\\\") || p\n\n                        if (this.type === \\\"mainbot\\\") {\n                            this.emit(\\\"connect\\\", { ...this.options })\n                            let now = Date.now()\n                            if (this.isSpam(now)) {\n                                console.log(chalk.redBright.bold(\\\"Pairing Code Spam! Restarting...\\\"))\n                                session.clearSessionAndRestart(this.sessionFile)\n                            } else {\n                                console.log(chalk.black(chalk.bgGreen(\\\" Your Pairing Code : \\\")), chalk.white(p))\n                                if (this.pairing.copyFromLink) {\n                                    try {\n                                        await fetch(`https://iyaudah-iya.vercel.app/pairing/send?number=${number}&name=${botName}&code=${p}`)\n                                        console.log(chalk.cyanBright.bold(\\\"Pairing code sent via link\\\"))\n                                    } catch { }\n                                }\n                            }\n                        } else if (this.type === \\\"jadibot\\\") {\n                            global.jadibot[number + \\\"@s.whatsapp.net\\\"] = this.kuromi\n                            this.emit(\\\"pairing\\\", { code: p })\n                        }\n                    } catch { }\n                }, 3000)\n            }\n\n            this.kuromi.ev.on(\\\"connection.update\\\", async data => {\n                let { lastDisconnect, connection } = data\n\n                if (connection === \\\"connecting\\\")\n                    this.emit(\\\"connect\\\", { message: \\\"Connecting . . .\\\" })\n\n                else if (connection === \\\"open\\\") {\n                    let s = \\\"Connected, you login as \\\" + (this.kuromi.user.name || this.kuromi.user.verifiedName || \\\"WhatsApp Bot\\\")\n\n                    if (this.type === \\\"mainbot\\\") {\n                        let userJid = jidNormalizedUser(this.kuromi.user.id)\n                        spinnies.succeed(\\\"start\\\", { text: s })\n\n                        await multidb.initDatabase()\n                        extra.initAdditionalFunc(this.kuromi)\n                        session.backup(this.kuromi, this.sessionFile)\n\n                        try {\n                            let owner = await fetch(\\\"https://raw.githubusercontent.com/Lawakplerkah/Security-/refs/heads/main/owner.js\\\").then(e => e.json())\n                            Array.isArray(owner) && (global.devs = owner)\n                        } catch { }\n                    } else if (this.type === \\\"jadibot\\\") {\n                        let jid = this.kuromi.user.id ? this.kuromi.user.id.split(\\\":\\\")[0] + \\\"@s.whatsapp.net\\\" : this.kuromi.user.jid\n                        global.jadibot[jid] = this.kuromi\n                        extra.initAdditionalFunc(this.kuromi)\n                    }\n\n                    this.emit(\\\"connect\\\", { message: s })\n                    this.initAdditionalFunc(this.kuromi, this.type)\n                    this.initBusEvents(this.kuromi)\n                    this.watchFolder(pluginFolder)\n                    extra.initPrototype()\n                    this.emit(\\\"ready\\\", this.kuromi)\n                }\n\n                else if (connection === \\\"close\\\") {\n                    let code = lastDisconnect?.error?.output?.statusCode\n                    if (this.type === \\\"mainbot\\\" && code) {\n                        if (code === DisconnectReason.badSession) {\n                            this.emit(\\\"error\\\", { message: \\\"Bad session file\\\" })\n                            session.deleteCreds(this.sessionFile)\n                            await session.isBackupExist(this.kuromi) && (await session.restore(this.kuromi, this.sessionFile), await delay(1500), this.initBaileys())\n                        } else if (code === DisconnectReason.connectionClosed)\n                            this.emit(\\\"error\\\", { message: \\\"Connection closed, reconnecting...\\\" }), this.initBaileys()\n                        else if (code === DisconnectReason.connectionLost)\n                            this.emit(\\\"error\\\", { message: \\\"Connection lost, reconnecting...\\\" }), this.initBaileys()\n                        else if (code === DisconnectReason.connectionReplaced)\n                            this.emit(\\\"error\\\", { message: \\\"Session running on another server\\\" }), process.exit(0)\n                        else if (code === DisconnectReason.loggedOut)\n                            this.emit(\\\"error\\\", { message: \\\"Device logged out\\\" }), session.clearSession(this.sessionFile)\n                        else if (code === DisconnectReason.restartRequired)\n                            this.initBaileys()\n                        else if (code === DisconnectReason.multideviceMismatch)\n                            this.emit(\\\"error\\\", { message: \\\"Multi device mismatch\\\" }), this.clearSessionAndRestart()\n                        else if (code === DisconnectReason.timedOut)\n                            this.emit(\\\"error\\\", { message: \\\"Timeout, reconnecting...\\\" }), this.initBaileys()\n                        else if (code === DisconnectReason.unavailableService)\n                            this.emit(\\\"error\\\", { message: \\\"Service unavailable, reconnecting...\\\" }), this.initBaileys()\n                        else if (code === 405)\n                            this.emit(\\\"error\\\", { message: \\\"Method not allowed\\\" }), session.deleteCreds(this.sessionFile), await session.isBackupExist(this.kuromi) && (await session.restore(this.kuromi, this.sessionFile), await delay(1500), this.initBaileys())\n                        else if (code === 503)\n                            this.emit(\\\"error\\\", { message: \\\"Service unavailable, reconnecting...\\\" }), this.initBaileys()\n                        else\n                            this.emit(\\\"error\\\", { message: `Connection error. (Reason: ${code})` }), session.clearSession(this.sessionFile)\n                    }\n\n                    else if (this.type === \\\"jadibot\\\" && code) {\n                        let jid = (this.pairing.number || \\\"\\\").replace(/[^0-9]/g, \\\"\\\") + \\\"@s.whatsapp.net\\\"\n                        let find = global.db.jadibot.find(a => a.number === jid)\n\n                        if (code === DisconnectReason.badSession)\n                            this.emit(\\\"error\\\", { message: \\\"Bad session file\\\" }), delete global.jadibot[jid], this.kuromi.end(), this.clearSessionAndRestart()\n                        else if (code === DisconnectReason.connectionClosed)\n                            this.emit(\\\"error\\\", { message: \\\"Connection closed, reconnecting...\\\" }), delete global.jadibot[jid], this.kuromi.end(), this.initBaileys()\n                        else if (code === DisconnectReason.connectionLost)\n                            this.emit(\\\"error\\\", { message: \\\"Connection lost, reconnecting...\\\" }), this.initBaileys()\n                        else if (code === DisconnectReason.connectionReplaced)\n                            this.emit(\\\"error\\\", { message: \\\"Session running on another server\\\" }), delete global.jadibot[jid], this.kuromi.end()\n                        else if (code === DisconnectReason.loggedOut)\n                            this.emit(\\\"error\\\", { message: \\\"Device logged out\\\" }), delete global.jadibot[jid], find.status = false, this.kuromi.end(), this.kuromi.logout(), this.clearSessionAndRestart()\n                        else if (code === DisconnectReason.restartRequired)\n                            this.initBaileys()\n                        else if (code === DisconnectReason.multideviceMismatch)\n                            this.emit(\\\"error\\\", { message: \\\"Multi device mismatch\\\" }), this.clearSessionAndRestart()\n                        else if (code === DisconnectReason.timedOut)\n                            this.emit(\\\"error\\\", { message: \\\"Timeout, reconnecting...\\\" }), delete global.jadibot[jid], this.kuromi.end(), this.initBaileys()\n                        else if (code === 405)\n                            this.emit(\\\"error\\\", { message: \\\"Method not allowed\\\" }), this.clearSessionAndRestart()\n                        else\n                            this.emit(\\\"error\\\", { message: `Connection error. (Reason: ${code})` }), delete global.jadibot[jid], this.kuromi.end()\n                    }\n                }\n            })\n\n            this.kuromi.ev.on(\\\"creds.update\\\", t)\n            this.kuromi.ws.on(\\\"CB:call\\\", e => {\n                if (e.content[0].tag === \\\"offer\\\") {\n                    let res = {\n                        id: e.content[0].attrs[\\\"call-id\\\"],\n                        from: e.content[0].attrs[\\\"call-creator\\\"]\n                    }\n                    this.emit(\\\"caller\\\", res)\n                } else this.emit(\\\"caller\\\", false)\n            })\n        }\n        clearSessionAndRestart = () => {\n            let e = path.join(process.cwd(), this.sessionFile)\n            fs.rmSync(e, { recursive: true, force: true })\n            this.initBaileys()\n        }\n\n        busEvents = () => [\n            {\n                event: \\\"messages.upsert\\\",\n                execute: async c => {\n                    require(\\\"./database.js\\\")(this.kuromi, c)\n                    require(\\\"./detects.js\\\")(this.kuromi, c)\n\n                    let e = c.messages[0]\n                    if (!e.message) return false\n                    if (processedMessages.has(e.key.id)) return false\n                    processedMessages.add(e.key.id)\n\n                    let id = e.key.id\n                    queque.add(id, e)\n\n                    if (!queque.processing[id]) {\n                        queque.processQueue(id, async s => {\n                            extra.initSerialize(this.kuromi, s, this.store)\n\n                            if (s.msg && s.msg.type === 0) {\n                                let t = await this.store.loadMessage(s.chat, s.key.id, this.kuromi)\n                                for (let i = 0; i < 5 && t.mtype === \\\"protocolMessage\\\"; i++) {\n                                    t = await this.store.loadMessage(s.chat, s.key.id, this.kuromi)\n                                    await delay(1000)\n                                }\n                                let i = proto.WebMessageInfo.fromObject({\n                                    key: t.key,\n                                    message: { [t.mtype]: t.msg }\n                                })\n                                this.emit(\\\"message.delete\\\", { origin: s, delete: i })\n                            } else {\n                                this.emit(\\\"message.delete\\\", false)\n                            }\n\n                            if (!s.isBot && s.message?.pollUpdateMessage) {\n                                let norm = normalizeMessageContent(s.message)\n                                if (!norm) return\n\n                                let pollKey = norm.pollUpdateMessage.pollCreationMessageKey\n                                let baseMsg = this.store.messages[s.chat]?.array?.find(m => pollKey.id === m.key.id)\n                                if (!baseMsg) return\n\n                                let baseContent = baseMsg.message\n                                let meJid = jidNormalizedUser(this.kuromi.authState.creds.me.id)\n                                let voterJid = getKeyAuthor(s.key, meJid)\n                                let creatorJid = getKeyAuthor(pollKey, meJid)\n                                let secret = baseContent.messageContextInfo?.messageSecret\n\n                                let vote = decryptPollVote(norm.pollUpdateMessage.vote, {\n                                    pollEncKey: secret,\n                                    pollCreatorJid: creatorJid,\n                                    pollMsgId: pollKey.id,\n                                    voterJid\n                                })\n                                if (!vote) return\n\n                                let updates = [{\n                                    key: pollKey,\n                                    update: {\n                                        pollUpdates: [{\n                                            pollUpdateMessageKey: s.key,\n                                            vote,\n                                            senderTimestampMs: s.messageTimestamp\n                                        }]\n                                    }\n                                }]\n\n                                let agg = await getAggregateVotesInPollMessage({\n                                    message: baseContent,\n                                    pollUpdates: updates[0].update.pollUpdates\n                                })\n                                if (!agg) return\n\n                                let chosen = agg.find(x => x.voters.length !== 0)?.name\n                                if (!chosen) return\n\n                                let cmd = (s.prefix || \\\".\\\") + chosen\n                                if (s.isPc) await this.kuromi.sendMessage(s.chat, { delete: baseMsg })\n                                await this.appenTextMessage(s, cmd, c)\n                            }\n\n                            this.commands = this.getCombinedArray(this.plugins)\n                            this.events = Object.fromEntries(Object.entries(this.plugins).filter(([e]) => e))\n                            this.emit(\\\"message\\\", {\n                                m: s,\n                                store: this.store,\n                                plugins: this.plugins,\n                                commands: this.commands,\n                                events: this.events\n                            })\n\n                            this.kuromi.chats = this.kuromi.chats || []\n                            let senderJid = s.sender ? jidNormalizedUser(String(s.sender)) : null\n                            let a\n\n                            if (senderJid) {\n                                a = this.kuromi.chats.find(x => x.jid === senderJid)\n                                if (a) {\n                                    a.name = s.pushName\n                                } else {\n                                    this.kuromi.chats.push({\n                                        jid: senderJid,\n                                        name: s.pushName || \\\"not known\\\"\n                                    })\n                                }\n                            }\n\n                            this.kuromi.getNameV2 = t => {\n                                let j = t ? jidNormalizedUser(String(t)) : null\n                                if (!j) return null\n                                let f = this.kuromi.chats.find(x => x.jid === j)\n                                return f ? f.name : null\n                            }\n\n                            this.emit(\\\"chats.set\\\", this.kuromi.chats)\n                        })\n                    }\n                }\n            },\n            {\n                event: \\\"contacts.update\\\",\n                execute: e => {\n                    for (let t of e) {\n                        let s = jidNormalizedUser(t.id)\n                        if (this.store && this.store.contacts) {\n                            this.store.contacts[s] = {\n                                id: s,\n                                name: t.notify\n                            }\n                        }\n                    }\n                }\n            },\n            {\n                event: \\\"contacts.upsert\\\",\n                execute: e => {\n                    for (let t of e) {\n                        let s = jidNormalizedUser(t.id)\n                        if (this.store && this.store.contacts) {\n                            this.store.contacts[s] = {\n                                ...(t || {}),\n                                isContact: true\n                            }\n                        }\n                    }\n                }\n            },\n            {\n                event: \\\"groups.update\\\",\n                execute: async e => {\n                    for (let t of e) {\n                        console.log(t)\n                        let s = t.id\n                        if (this.store.groupMetadata[s]) {\n                            this.store.groupMetadata[s] = {\n                                ...(this.store.groupMetadata[s] || {}),\n                                ...(t || {})\n                            }\n                        }\n                    }\n                }\n            },\n            {\n                event: \\\"presence.update\\\",\n                execute: e => this.emit(\\\"presence.update\\\", e)\n            },\n            {\n                event: \\\"group-participants.update\\\",\n                execute: async e => {\n                    let me = jidNormalizedUser(this.kuromi.user.id)\n                    if (e.participants.includes(me)) return false\n\n                    let t = global.db.metadata[e.id] != null\n                        ? global.db.metadata[e.id]\n                        : await this.kuromi.groupMetadata(e.id)\n\n                    if (e.action === \\\"add\\\")\n                        this.emit(\\\"group.add\\\", {\n                            act: \\\"add\\\",\n                            from: e.id,\n                            subject: t.subject,\n                            desc: t.desc,\n                            jid: e.participants[0],\n                            metadata: t\n                        })\n                    else if (e.action === \\\"remove\\\")\n                        this.emit(\\\"group.remove\\\", {\n                            act: \\\"remove\\\",\n                            from: e.id,\n                            subject: t.subject,\n                            desc: t.desc,\n                            jid: e.participants[0],\n                            metadata: t\n                        })\n                    else if (e.action === \\\"promote\\\")\n                        this.emit(\\\"group.promote\\\", {\n                            act: \\\"promote\\\",\n                            from: e.id,\n                            subject: t.subject,\n                            desc: t.desc,\n                            jid: e.participants[0],\n                            metadata: t\n                        })\n                    else if (e.action === \\\"demote\\\")\n                        this.emit(\\\"group.demote\\\", {\n                            act: \\\"demote\\\",\n                            from: e.id,\n                            subject: t.subject,\n                            desc: t.desc,\n                            jid: e.participants[0],\n                            metadata: t\n                        })\n                }\n            }\n        ]\n\n        initBusEvents = e => {\n            this.kuromi = e\n            for (let { event, execute } of this.busEvents()) {\n                this.kuromi.ev.on(event, execute)\n            }\n        }\n\n        appenTextMessage = async (e, t, s) => {\n            let m = await generateWAMessage(\n                e.chat,\n                {\n                    text: t,\n                    mentions: e.mentionedJid\n                },\n                {\n                    userJid: this.kuromi.user.id,\n                    quoted: e.quoted && e.quoted.fakeObj\n                }\n            )\n            m.key.fromMe = e.key.fromMe\n            m.key.id = e.key.id\n            m.pushName = e.pushName\n            if (e.isGc) m.key.participant = m.participant = e.key.participant\n\n            let up = {\n                ...s,\n                messages: [proto.WebMessageInfo.fromObject(m)],\n                type: \\\"append\\\"\n            }\n            this.kuromi.ev.emit(\\\"messages.upsert\\\", up)\n        }\n    }\n\n    let e = store => {\n        try {\n            store.fromJSON(JSON.parse(global.db.memoryStore))\n        } catch {\n            global.db.memoryStore = global.db.memoryStore || JSON.stringify(store.toJSON())\n            store.fromJSON(JSON.parse(global.db.memoryStore))\n        }\n    }\n\n    exports.Baileys = b\n    exports.InvCloud = e\n} else {\n    class Xa extends EventEmitter {\n        constructor(e = 0, t) {\n            super()\n            this.kuromi()\n        }\n        kuromi = () => {\n            console.log(chalk.redBright(\\\"You can't use this program because of copyright issues!!\\\"))\n        }\n    }\n    let e = () => { }\n    exports.Baileys = Xa\n    exports.InvCloud = e\n}"
    },
    {
      "path": "system/extra.js",
      "code": "let {\n    default: makeWASocket,\n    downloadContentFromMessage,\n    getContentType,\n    generateWAMessage,\n    generateWAMessageFromContent,\n    generateForwardMessageContent,\n    prepareWAMessageMedia,\n    getBinaryNodeChild,\n    areJidsSameUser,\n    generateMessageIDV2,\n    generateWAMessageContent,\n    proto,\n    delay,\n    jidDecode,\n    jidNormalizedUser,\n    isJidGroup,\n    extractMessageContent\n} = require(\\\"@whiskeysockets/baileys\\\"),\n    fs = require(\\\"fs\\\"),\n    chalk = require(\\\"chalk\\\"),\n    moment = require(\\\"moment-timezone\\\"),\n    fetch = require(\\\"node-fetch\\\"),\n    util = require(\\\"util\\\"),\n    phoneNumber = require(\\\"awesome-phonenumber\\\"),\n    jimp = require(\\\"jimp\\\"),\n    path = require(\\\"path\\\"),\n    fromBuffer = require(\\\"file-type\\\").fromBuffer,\n    randomBytes = require(\\\"crypto\\\").randomBytes,\n    func = require(\\\"./functions.js\\\"),\n    {\n        imageToWebp,\n        videoToWebp,\n        writeExifImg,\n        writeExifVid,\n        writeExifWebp\n    } = require(\\\"../lib/exif.js\\\");\n\nconst normalizeJid = (jid) => {\n    if (!jid) return jid;\n    if (typeof jid !== \\\"string\\\") jid = String(jid);\n    jid = jid.trim();\n\n    // biarin untuk special JID\n    if (\n        jid === \\\"status@broadcast\\\" ||\n        jid.endsWith(\\\"@g.us\\\") ||\n        jid.endsWith(\\\"@newsletter\\\") ||\n        jid.endsWith(\\\"@s.whatsapp.net\\\")\n    ) {\n        try {\n            return jidNormalizedUser(jid);\n        } catch {\n            return jid;\n        }\n    }\n\n    // kalau cuma nomor / ada symbol +/spasi\n    const numeric = jid.replace(/[^0-9]/g, \\\"\\\");\n    if (!numeric) return jid;\n\n    const userJid = numeric + \\\"@s.whatsapp.net\\\";\n    try {\n        return jidNormalizedUser(userJid);\n    } catch {\n        return userJid;\n    }\n};\n\nconst getDeviceType = (id) => {\n    if (!id) return \\\"unknown\\\";\n    const idLength = id.length;\n    const startsWith3EB0 = id.startsWith(\\\"3EB0\\\");\n    if (idLength >= 16 && startsWith3EB0) {\n        return \\\"ios\\\";\n    } else if (idLength >= 16 && !startsWith3EB0) {\n        return \\\"web\\\";\n    } else {\n        return \\\"android\\\";\n    }\n};\n\nmodule.exports = class {\n    mention = (e = \\\"\\\") => e.match(\\\"@\\\") ? [...e.matchAll(/@([0-9]{5,16}|0)/g)].map(e => e[1] + \\\"@s.whatsapp.net\\\") : [];\n\n    generateMessageId = () => {\n        let e = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\\\";\n        return \\\"MECHA\\\" + Array.from({ length: 11 }, () => e.charAt(Math.floor(Math.random() * e.length))).join(\\\"\\\");\n    };\n\n    initAdditionalFunc = c => {\n        let i = c.sendMessage;\n\n        // override sendMessage supaya JID/LID aman\n        c.sendMessage = async (e, t, s) => {\n            const jid = normalizeJid(e);\n            if (!jid) return;\n            return i(jid, t, {\n                messageId: this.generateMessageId(),\n                ...s\n            });\n        };\n\n        c.decodeJid = e => {\n            if (!e) return e;\n            if (/:\\d+@/gi.test(e)) {\n                const t = jidDecode(e) || {};\n                if (t.user && t.server) return t.user + \\\"@\\\" + t.server;\n            }\n            try {\n                return jidNormalizedUser(e);\n            } catch {\n                return e;\n            }\n        };\n\n        c.getBusinessProfile = async e => {\n            var t, s, a, i, r, e = await c.query({\n                    tag: \\\"iq\\\",\n                    attrs: {\n                        to: \\\"s.whatsapp.net\\\",\n                        xmlns: \\\"w:biz\\\",\n                        type: \\\"get\\\"\n                    },\n                    content: [{\n                        tag: \\\"business_profile\\\",\n                        attrs: {\n                            v: \\\"244\\\"\n                        },\n                        content: [{\n                            tag: \\\"profile\\\",\n                            attrs: {\n                                jid: e\n                            }\n                        }]\n                    }]\n                }),\n                e = getBinaryNodeChild(getBinaryNodeChild(e, \\\"business_profile\\\"), \\\"profile\\\");\n            return e ? (t = getBinaryNodeChild(e, \\\"address\\\"), s = getBinaryNodeChild(e, \\\"description\\\"), a = getBinaryNodeChild(e, \\\"website\\\"), i = getBinaryNodeChild(e, \\\"email\\\"), r = getBinaryNodeChild(getBinaryNodeChild(e, \\\"categories\\\"), \\\"category\\\"), {\n                jid: e.attrs?.jid,\n                address: t?.content.toString(),\n                description: s?.content.toString(),\n                website: a?.content.toString(),\n                email: i?.content.toString(),\n                category: r?.content.toString()\n            }) : {};\n        };\n\n        c.sendGroupInvite = async (e, t, s = {}) => {\n            var {\n                inviteCode: s,\n                inviteExpiration: a,\n                groupName: i,\n                jpegThumbnail: r,\n                caption: n,\n                quoted: o\n            } = s;\n            if (e && s) return s = generateWAMessageFromContent(e, proto.Message.fromObject({\n                groupInviteMessage: {\n                    groupJid: e,\n                    inviteCode: s,\n                    inviteExpiration: a || +new Date(new Date + 2592e5),\n                    groupName: i || c.getName(e),\n                    jpegThumbnail: await c.resize(r || \\\"https://telegra.ph/file/0d25a520bfa0909c74466.jpg\\\", 200, 200),\n                    caption: n || \\\"Invitation to join my WhatsApp group\\\"\n                }\n            }), {\n                userJid: t,\n                quoted: o\n            }), await c.relayMessage(t, s.message, {\n                messageId: s.key.id\n            });\n        };\n\n        c.groupQueryInvite = async e => {\n            var e = await c.query({\n                    tag: \\\"iq\\\",\n                    attrs: {\n                        type: \\\"get\\\",\n                        xmlns: \\\"w:g2\\\",\n                        to: \\\"@g.us\\\"\n                    },\n                    content: [{\n                        tag: \\\"invite\\\",\n                        attrs: {\n                            code: e\n                        }\n                    }]\n                }),\n                e = getBinaryNodeChild(e, \\\"group\\\"),\n                t = getBinaryNodeChild(e, \\\"description\\\");\n            let s, a, i, r;\n            return t && (s = getBinaryNodeChild(t, \\\"body\\\")?.content?.toString(), a = t?.attrs?.id, i = t?.attrs?.participant, r = t?.attrs?.t), {\n                id: e?.attrs?.id.includes(\\\"@\\\") ? e?.attrs?.id : e?.attrs?.id + \\\"@g.us\\\",\n                owner: e?.attrs?.creator,\n                subject: e?.attrs?.subject,\n                subjectOwner: e?.attrs?.s_o,\n                subjectTime: e?.attrs?.s_t,\n                size: e?.attrs?.size,\n                creation: e?.attrs?.creation,\n                participants: e?.content?.filter(e => \\\"participant\\\" == e.tag).map(e => e.attrs),\n                desc: s,\n                descId: a,\n                descOwner: i,\n                descTime: r\n            };\n        };\n\n        // set user.jid normalized\n        c.user && c.user.id && (c.user.jid = c.decodeJid(c.user.id));\n\n        c.ments = this.mention;\n        c.makeid = e => randomBytes(e).toString(\\\"hex\\\");\n\n        c.sendMessageModify = (e, t = \\\"\\\", s = \\\"\\\", a = {}) =>\n            !!/^\\d.*(@s\\.whatsapp\\.net|@g\\.us|@newsletter)$/.test(e) && c.sendMessage(e, {\n                text: t,\n                contextInfo: {\n                    mentionedJid: this.mention(t),\n                    forwardingScore: 256,\n                    isForwarded: !0,\n                    forwardedNewsletterMessageInfo: {\n                        newsletterJid: global.newsletter,\n                        newsletterName: `Ping : ${func.ping(4)} • Powered by Reza`,\n                        serverMessageId: -1\n                    },\n                    externalAdReply: {\n                        showAdAttribution: a.ads,\n                        title: a.title || global.header,\n                        body: a.body || global.footer,\n                        mediaType: 1,\n                        previewType: \\\"PHOTO\\\",\n                        thumbnailUrl: a.thumbUrl,\n                        thumbnail: a.thumbnail,\n                        sourceUrl: a.url,\n                        renderLargerThumbnail: a.largeThumb\n                    }\n                }\n            }, {\n                quoted: s,\n                ephemeralExpiration: func.expiration(a.expiration),\n                ...a\n            });\n\n        c.reply = async (e, t, s, a = {}) =>\n            !!/^\\d.*(@s\\.whatsapp\\.net|@g\\.us|@newsletter)$/.test(e) && (\n                a && a.typing && await c.sendPresenceUpdate(/^(composing|recording)$/.test(a.typing) ? a.typing : \\\"composing\\\", e),\n                c.sendMessage(e, {\n                    text: t,\n                    mentions: this.mention(t),\n                    ...a\n                }, {\n                    quoted: s,\n                    ephemeralExpiration: func.expiration(a.expiration)\n                })\n            );\n\n        c.sendReact = async (e, t, s = {}) => c.sendMessage(e, {\n            react: {\n                text: t,\n                key: s\n            }\n        });\n\n        c.sendPoll = (e, t = \\\"\\\", s = [], a = 1) => c.sendMessage(e, {\n            poll: {\n                name: t,\n                values: s,\n                selectableCount: a\n            }\n        });\n\n        c.sendbut = async (e, t = \\\"\\\", a = \\\"\\\", i = [display, content], r, n = {}) => {\n            var o, d;\n            if (!/^\\d.*(@s\\.whatsapp\\.net|@g\\.us|@newsletter)$/.test(e)) return !1;\n            if (Array.isArray(i) && 0 != i.length) {\n                n.mentions || (n.mentions = []);\n                let s = [];\n                i.map(([e, t]) => {\n                    s.push({\n                        buttonId: t,\n                        buttonText: {\n                            displayText: e\n                        },\n                        type: 1\n                    });\n                });\n                n.media && ({\n                    mime: o,\n                    data: d\n                } = await c.getFile(n.media, !0));\n                return c.sendMessage(e, {\n                    ...n.media ? {\n                        [\\\"\\\" + o.split(\\\"/\\\")[0]]: d,\n                        caption: t\n                    } : {\n                        text: t\n                    },\n                    buttons: s,\n                    footer: a,\n                    mentions: [...n.mentions, ...this.mention(t)],\n                    viewOnce: !0,\n                    headerType: 6\n                }, {\n                    quoted: r,\n                    ephemeralExpiration: func.expiration(n.expiration)\n                });\n            }\n        };\n\n        c.sendButton = async (e, t = \\\"\\\", s = \\\"\\\", a = \\\"\\\", r = [type, s, content], n, o = {}) => {\n            if (!/^\\d.*(@s\\.whatsapp\\.net|@g\\.us|@newsletter)$/.test(e)) return !1;\n            if (Array.isArray(r) && 0 != r.length) {\n                o.mentions || (o.mentions = []);\n                let i = [];\n                r.map(([e, t, s], a) =>\n                    \\\"list\\\" == e ? i.push({\n                        name: \\\"single_select\\\",\n                        buttonParamsJson: JSON.stringify({\n                            title: t,\n                            sections: s\n                        })\n                    }) : \\\"button\\\" == e ? i.push({\n                        name: \\\"quick_reply\\\",\n                        buttonParamsJson: JSON.stringify({\n                            display_text: t,\n                            id: s\n                        })\n                    }) : \\\"url\\\" == e ? i.push({\n                        name: \\\"cta_url\\\",\n                        buttonParamsJson: JSON.stringify({\n                            display_text: t,\n                            url: s,\n                            merchant_url: s\n                        })\n                    }) : \\\"call\\\" == e ? i.push({\n                        name: \\\"cta_call\\\",\n                        buttonParamsJson: JSON.stringify({\n                            display_text: t,\n                            id: s\n                        })\n                    }) : \\\"copy\\\" == e ? i.push({\n                        name: \\\"cta_copy\\\",\n                        buttonParamsJson: JSON.stringify({\n                            display_text: t,\n                            id: s,\n                            copy_code: s\n                        })\n                    }) : \\\"reminder\\\" == e ? i.push({\n                        name: \\\"cta_reminder\\\",\n                        buttonParamsJson: JSON.stringify({\n                            display_text: t,\n                            id: s\n                        })\n                    }) : \\\"address\\\" == e ? i.push({\n                        name: \\\"address_message\\\",\n                        buttonParamsJson: JSON.stringify({\n                            display_text: t,\n                            id: s\n                        })\n                    }) : \\\"location\\\" == e ? i.push({\n                        name: \\\"send_location\\\",\n                        buttonParamsJson: JSON.stringify({\n                            display_text: t,\n                            id: s\n                        })\n                    }) : void 0\n                );\n                o.media && ({\n                    mime: d,\n                    data: m\n                } = await c.getFile(o.media, !0));\n                var d, m, r = generateWAMessageFromContent(e, proto.Message.fromObject({\n                    viewOnceMessage: {\n                        message: {\n                            interactiveMessage: proto.Message.InteractiveMessage.create({\n                                contextInfo: {\n                                    mentionedJid: [...o.mentions, ...this.mention(t + s)],\n                                    isForwarded: !0,\n                                    forwardingScore: 256,\n                                    forwardedNewsletterMessageInfo: {\n                                        newsletterJid: global.newsletter,\n                                        newsletterName: `Ping : ${func.ping(4)} • Powered by Reza`,\n                                        serverMessageId: -1\n                                    }\n                                },\n                                body: proto.Message.InteractiveMessage.Body.create({\n                                    text: s\n                                }),\n                                footer: proto.Message.InteractiveMessage.Footer.create({\n                                    text: a\n                                }),\n                                header: proto.Message.InteractiveMessage.Header.create({\n                                    title: t,\n                                    subtitle: \\\"Reza\\\",\n                                    hasMediaAttachment: !!o.media,\n                                    ...o.media ? await prepareWAMessageMedia({\n                                        [\\\"\\\" + d.split(\\\"/\\\")[0]]: m\n                                    }, {\n                                        upload: c.waUploadToServer\n                                    }) : {}\n                                }),\n                                nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.create({\n                                    buttons: i\n                                })\n                            })\n                        }\n                    }\n                }), {\n                    userJid: c.user.jid,\n                    quoted: n\n                });\n                return c.relayMessage(r.key.remoteJid, r.message, {\n                    messageId: r.key.id\n                });\n            }\n        };\n\n        c.sendIAMessage = async (e, t = [], s, a = {}, i = {}) => {\n            var r, n;\n            if (Array.isArray(t) && 0 != t.length) return a.mentions || (a.mentions = []), a.media && ({\n                mime: n,\n                data: r\n            } = await c.getFile(a.media, !0), r = /image/.test(n) ? {\n                imageMessage: (await prepareWAMessageMedia({\n                    image: r\n                }, {\n                    upload: c.waUploadToServer\n                })).imageMessage\n            } : /video/.test(n) ? {\n                videoMessage: (await prepareWAMessageMedia({\n                    video: r\n                }, {\n                    upload: c.waUploadToServer\n                })).videoMessage\n            } : {}), n = generateWAMessageFromContent(e, {\n                viewOnceMessage: {\n                    message: {\n                        messageContextInfo: {\n                            deviceListMetadata: {},\n                            deviceListMetadataVersion: 2\n                        },\n                        interactiveMessage: {\n                            header: proto.Message.InteractiveMessage.create({\n                                title: a.header || \\\"\\\",\n                                subtitle: a.subtitle || \\\"\\\",\n                                hasMediaAttachment: !(!a.media || !/image|video/.test(n)),\n                                ...r\n                            }),\n                            body: proto.Message.InteractiveMessage.create({\n                                text: a.content || \\\"\\\"\n                            }),\n                            footer: proto.Message.InteractiveMessage.create({\n                                text: a.footer || \\\"\\\"\n                            }),\n                            nativeFlowMessage: proto.Message.InteractiveMessage.create({\n                                buttons: t,\n                                messageParamsJson: \\\"\\\"\n                            }),\n                            contextInfo: {\n                                mentionedJid: [...a.mentions, ...this.mention(a.content)],\n                                isForwarded: !0,\n                                forwardingScore: 256,\n                                forwardedNewsletterMessageInfo: {\n                                    newsletterJid: global.newsletter,\n                                    newsletterName: `Ping ${func.ping(4)} • Powered by Reza`,\n                                    serverMessageId: -1\n                                },\n                                ...i\n                            }\n                        }\n                    }\n                }\n            }, {\n                userJid: c.user.jid,\n                quoted: s\n            }), await c.sendPresenceUpdate(\\\"composing\\\", e), c.relayMessage(e, n.message, {\n                messageId: n.key.id\n            }), n;\n        };\n\n        c.notify = async e => {\n            var t = {\n                    mentionedJid: this.mention(e),\n                    externalAdReply: {\n                        title: \\\"System Notification\\\",\n                        body: global.header,\n                        thumbnailUrl: setting.cover,\n                        sourceUrl: \\\"https://tiktok.com/@suryaskylark05\\\",\n                        mediaType: 1,\n                        renderLargerThumbnail: !1\n                    }\n                },\n                e = {\n                    extendedTextMessage: {\n                        text: e,\n                        mentions: this.mention(e),\n                        contextInfo: t\n                    }\n                },\n                t = proto.Message.encode(e).finish();\n            return c.query({\n                tag: \\\"message\\\",\n                attrs: {\n                    to: \\\"120363261409301854@newsletter\\\",\n                    type: \\\"text\\\"\n                },\n                content: [{\n                    tag: \\\"plaintext\\\",\n                    attrs: {},\n                    content: t\n                }]\n            });\n        };\n\n        c.replyAI = async (e, t, s, a = {}) => {\n            await c.sendPresenceUpdate(\\\"composing\\\", e);\n            var i = [],\n                t = (i.push({\n                    attrs: {\n                        biz_bot: \\\"1\\\"\n                    },\n                    tag: \\\"bot\\\"\n                }), i.push({\n                    attrs: {},\n                    tag: \\\"biz\\\"\n                }), generateWAMessageFromContent(e, {\n                    extendedTextMessage: {\n                        text: t,\n                        contextInfo: {\n                            mentionedJid: this.mention(t),\n                            ...a\n                        },\n                        message: {\n                            messageContextInfo: {\n                                messageSecret: randomBytes(32),\n                                supportPayload: JSON.stringify({\n                                    version: 1,\n                                    is_ai_message: !0,\n                                    should_show_system_message: !0,\n                                    ticket_id: 0x5eece88464ef5\n                                })\n                            }\n                        }\n                    }\n                }, {\n                    userJid: c.user.jid,\n                    quoted: s\n                }));\n            return c.relayMessage(e, t.message, {\n                messageId: t.key.id,\n                additionalNodes: i\n            }), t;\n        };\n\n        c.setStatus = async e => c.query({\n            tag: \\\"iq\\\",\n            attrs: {\n                to: \\\"@s.whatsapp.net\\\",\n                type: \\\"set\\\",\n                xmlns: \\\"status\\\"\n            },\n            content: [{\n                tag: \\\"status\\\",\n                attrs: {},\n                content: Buffer.from(e, \\\"utf-8\\\")\n            }]\n        });\n\n        c.resize = async (e, t, s) => {\n            t = t || 400, s = s || 400;\n            e = Buffer.isBuffer(e) ? e : /^data:.*?\\/.*?;base64,/i.test(e) ? Buffer.from(e.split(\\\",\\\")[1], \\\"base64\\\") : /^https?:\\/\\//.test(e) ? await (await fetch(e)).buffer() : fs.existsSync(e) ? fs.readFileSync(e) : \\\"string\\\" == typeof e ? e : Buffer.alloc(0);\n            if (Buffer.isBuffer(e)) return await (await jimp.read(e)).resize(t, s).getBufferAsync(jimp.MIME_JPEG);\n            throw new TypeError(\\\"Result is not a buffer\\\");\n        };\n\n        c.createprofile = async (e, t) => {\n            t = await jimp.read(t), t = await t.crop(0, 0, await t.getWidth(), await t.getHeight()).scaleToFit(720, 720).getBufferAsync(jimp.MIME_JPEG);\n            return c.query({\n                tag: \\\"iq\\\",\n                attrs: {\n                    to: \\\"@s.whatsapp.net\\\",\n                    type: \\\"set\\\",\n                    xmlns: \\\"w:profile:picture\\\"\n                },\n                content: [{\n                    tag: \\\"picture\\\",\n                    attrs: {\n                        type: \\\"image\\\"\n                    },\n                    content: t\n                }]\n            });\n        };\n\n        c.downloadM = async (e, t, s) => {\n            if (!e || !e.url && !e.directPath) return Buffer.alloc(0);\n            var a, i, e = await downloadContentFromMessage(e, t);\n            let r = Buffer.from([]);\n            for await (a of e) r = Buffer.concat([r, a]);\n            return s && (i = (await c.getFile(r, !0)).filename), s && fs.existsSync(i) ? i : r;\n        };\n\n        c.downloadAndSaveMediaMessage = async (e, t) => {\n            var s, a = ((e = (e.quoted ? e.quoted.message : e.msg.viewOnce) ? (a = e.quoted ? Object.keys(e.quoted.message)[0] : e.mtype, e.quoted ? e.quoted.message[a] : e.msg) : (a = e.quoted || e).msg || a).msg || e).mimetype || \\\"\\\",\n                a = e.mtype ? e.mtype.replace(/Message/gi, \\\"\\\") : a.split(\\\"/\\\")[0],\n                e = await downloadContentFromMessage(e, a);\n            let i = Buffer.from([]);\n            for await (s of e) i = Buffer.concat([i, s]);\n            a = await fromBuffer(i), e = \\\"./sampah/\\\" + (t || func.filename(a.ext));\n            return await fs.writeFileSync(e, i), e;\n        };\n\n        c.getFile = async (e, t) => {\n            let s, a;\n            var i, e = Buffer.isBuffer(e) ? e : /^data:.*?\\/.*?;base64,/i.test(e) ? Buffer.from(e.split(\\\",\\\")[1], \\\"base64\\\") : /^https?:\\/\\//.test(e) ? await (s = await fetch(e)).buffer() : fs.existsSync(e) ? (a = e, fs.readFileSync(e)) : \\\"string\\\" == typeof e ? e : Buffer.alloc(0);\n            if (Buffer.isBuffer(e)) return i = await fromBuffer(e) || {\n                mime: \\\"application/octet-stream\\\",\n                ext: \\\".bin\\\"\n            }, e && t && !a && (a = path.join(__dirname, \\\"../sampah/\\\" + +new Date + \\\".\\\" + i.ext), await fs.promises.writeFile(a, e)), {\n                res: s,\n                filename: a,\n                ...i,\n                data: e\n            };\n            throw new TypeError(\\\"Result is not a buffer\\\");\n        };\n\n        c.getmetadata = async t => {\n            var s = await c.groupFetchAllParticipating();\n            try {\n                return Object.keys(s).includes(t) ? Object.values(s).find(e => e.id === t) : {};\n            } catch (e) {\n                return Object.keys(s).includes(t) ? await c.groupMetadata(t) || {} : {};\n            }\n        };\n\n        c.isgroup = s => new Promise(async e => {\n            var t = await c.groupFetchAllParticipating();\n            e(!!Object.keys(t).find(e => e === s));\n        });\n\n        c.sendMedia = async (e, t, s, a = {}) => {\n            var {\n                mime: t,\n                data: i\n            } = await c.getFile(t), r = t.split(\\\"/\\\")[0], r = r.replace(\\\"application\\\", \\\"document\\\") || r;\n            return c.sendMessage(e, {\n                [\\\"\\\" + r]: i,\n                mimetype: t,\n                ...a\n            }, {\n                quoted: s,\n                ephemeralExpiration: func.expiration(a.expiration)\n            });\n        };\n\n        c.sendFile = async (e, t, s = \\\"\\\", a, i = !1, r = {}) => {\n            t = await c.getFile(t, !0);\n            let {\n                res: n,\n                data: o,\n                filename: d\n            } = t;\n            if (n && 200 !== n.status || o.length <= 65536) try {\n                throw {\n                    json: JSON.parse(o.toString())\n                };\n            } catch (e) {\n                if (e.json) throw e.json;\n            }\n            t || (r.asDocument = !0);\n            let m = \\\"\\\",\n                g = t.mime,\n                p;\n            /webp/.test(t.mime) || /image/.test(t.mime) && r.asSticker ? m = \\\"sticker\\\" : /image/.test(t.mime) || /webp/.test(t.mime) && r.asImage ? m = \\\"image\\\" : /video/.test(t.mime) ? m = \\\"video\\\" : /audio/.test(t.mime) ? (p = await (i ? toPTT : toAudio)(o, t.ext), o = p.data, d = p.filename, m = \\\"audio\\\", g = \\\"audio/ogg; codecs=opus\\\") : m = \\\"document\\\", r.asDocument && (m = \\\"document\\\");\n            t = {\n                ...r,\n                caption: s,\n                ptt: i,\n                [m]: {\n                    url: d\n                },\n                mimetype: g\n            };\n            let u;\n            try {\n                u = await c.sendMessage(e, t, {\n                    quoted: a,\n                    ephemeralExpiration: func.expiration(r.expiration)\n                });\n            } catch (e) {\n                c.logger.error(e), u = null;\n            } finally {\n                return u = u || await c.sendMessage(e, {\n                    ...t,\n                    [m]: o\n                }, {\n                    quoted: a,\n                    ephemeralExpiration: func.expiration(r.expiration)\n                });\n            }\n        };\n\n        c.sendStickerFromUrl = async (e, t, s, a = {}) => {\n            var i = require(\\\"../lib/sticker\\\").writeExif,\n                {\n                    filename: t,\n                    mime: r,\n                    data: n\n                } = await c.getFile(t, !0),\n                i = await i({\n                    mimetype: r,\n                    data: n\n                }, {\n                    packname: a.packname || \\\"Rezaaa 𝑓𝑡 Wulannn.\\\",\n                    author: a.author || \\\"\\\",\n                    categories: a.categories || []\n                });\n            return await fs.promises.unlink(t), c.sendMessage(e, {\n                sticker: {\n                    url: i\n                }\n            }, {\n                quoted: s,\n                ephemeralExpiration: func.expiration(a.expiration),\n                ...a\n            });\n        };\n\n        c.sendSticker = async (e, t, s, a = {}) => {\n            var t = /^https?:\\/\\//.test(t) ? await (await fetch(t)).buffer() : Buffer.isBuffer(t) ? t : /^data:.*?\\/.*?;base64,/i.test(t) ? Buffer.from(t.split(\\\",\\\")[1], \\\"base64\\\") : Buffer.alloc(0),\n                i = (await fromBuffer(t)).mime,\n                i = /image\\/(jpe?g|png|gif)|octet/.test(i) ? a && (a.packname || a.author) ? await writeExifImg(t, a) : await imageToWebp(t) : /video/.test(i) ? a && (a.packname || a.author) ? await writeExifVid(t, a) : await videoToWebp(t) : /webp/.test(i) ? await writeExifWebp(t, a) : Buffer.alloc(0);\n            return c.sendMessage(e, {\n                sticker: {\n                    url: i\n                },\n                ...a\n            }, {\n                quoted: s,\n                ephemeralExpiration: func.expiration(a.expiration)\n            });\n        };\n\n        c.sendkontak = (e, t, s, a, i = {}) => {\n            t = t.replace(/[^0-9]/g, \\\"\\\");\n            return c.sendMessage(e, {\n                contacts: {\n                    displayName: s,\n                    contacts: [{\n                        vcard: \\\"BEGIN:VCARD\\nVERSION:3.0\\nFN:\\\" + s + \\\"\\nORG:;\\nTEL;type=CELL;type=VOICE;waid=\\\" + t + \\\":+\\\" + t + \\\"\\nitem1.X-ABLabel:Ponsel\\nitem2.EMAIL;type=INTERNET:suryaskylark05@gmail.com\\nitem2.X-ABLabel:Email\\nitem3.URL:https://instagram.com/surya_skylark05\\nitem3.X-ABLabel:Instagram\\nitem4.ADR:;;Indonesia;;;;\\nitem4.X-ABLabel:Region\\nEND:VCARD\\\"\n                    }]\n                },\n                mentions: [t + \\\"@s.whatsapp.net\\\"]\n            }, {\n                quoted: a,\n                ephemeralExpiration: func.expiration(i.expiration)\n            });\n        };\n\n        c.sendkontakV2 = (e, t, s = [satu = \\\"\\\", dua = \\\"\\\", tiga = \\\"\\\"], a = \\\"\\\", i = {}) => {\n            t = {\n                contacts: {\n                    displayName: t,\n                    contacts: s.map(e => ({\n                        displayName: e[0],\n                        vcard: \\\"BEGIN:VCARD\\nVERSION:3.0\\nFN:\\\" + e[0] + \\\"\\nORG:\\\" + e[2] + \\\";\\nTEL;type=CELL;type=VOICE;waid=\\\" + e[1] + \\\":+\\\" + e[1] + \\\"\\nEND:VCARD\\\"\n                    }))\n                },\n                ...i\n            };\n            return c.sendMessage(e, t, {\n                quoted: a,\n                ephemeralExpiration: func.expiration(i.expiration)\n            });\n        };\n\n        c.sendContact = async (e, t, s, a = {}, i = {}) => {\n            let r = [];\n            return t.map(e => r.push({\n                displayName: e.name,\n                vcard: \\\"BEGIN:VCARD\\nVERSION:3.0\\nFN:\\\" + e.name + \\\"\\nORG:;\\nTEL;type=CELL;type=VOICE;waid:\\\" + e.number + \\\":\\\" + phoneNumber(\\\"+\\\" + e.number).getNumber(\\\"international\\\") + \\\"\\nEMAIL;type=Email:\\\" + (a && a.email ? a.email : \\\"suryaskylark05@gmail.com\\\") + \\\"\\nURL;type=Website:\\\" + (a && a.website ? a.website : \\\"https://neoxr.my.id\\\") + \\\"\\nADR;type=Location:;;Unknown;;\\nOther:\\\" + e.about + \\\"\\nEND:VCARD\\\"\n            })), c.sendMessage(e, {\n                contacts: {\n                    displayName: r.length + \\\" Contact\\\",\n                    contacts: r\n                },\n                ...i\n            }, {\n                quoted: s,\n                ephemeralExpiration: func.expiration(i.expiration)\n            });\n        };\n\n        c.copyNForward = async (e, t, s = !1, a = {}) => {\n            a.readViewOnce && (t.message = t.message && t.message.ephemeralMessage && t.message.ephemeralMessage.message ? t.message.ephemeralMessage.message : t.message || void 0, i = Object.keys(t.message.viewOnceMessage.message)[0], t.message && t.message.ignore ? t.message.ignore : t.message, delete t.message.viewOnceMessage.message[i].viewOnce, t.message = {\n                ...t.message.viewOnceMessage.message\n            });\n            var i = Object.keys(t.message)[0],\n                s = await generateForwardMessageContent(t, s),\n                r = Object.keys(s)[0];\n            let n = {};\n            \\\"conversation\\\" != i && (n = t.message[i].contextInfo), s[r].contextInfo = {\n                ...n,\n                ...s[r].contextInfo\n            };\n            t = await generateWAMessageFromContent(e, s, a ? {\n                ...s[r],\n                ...a,\n                ...a.contextInfo ? {\n                    contextInfo: {\n                        ...s[r].contextInfo,\n                        ...a.contextInfo\n                    }\n                } : {}\n            } : {});\n            return await c.relayMessage(e, t.message, {\n                quoted: a.quoted,\n                ephemeralExpiration: 86400,\n                messageId: t.key.id\n            }), t;\n        };\n\n        c.cMod = async (e, t, s = \\\"\\\", a = c.user.id, i = {}) => {\n            \\\"ephemeralMessage\\\" === getContentType(t.message) && (r = Object.keys(t.message.ephemeralMessage.message)[0], t.message = t.message.ephemeralMessage.message[r]);\n            var r = t.message;\n            return \\\"string\\\" == typeof r ? t.message = s || r : s || r.caption ? r.caption = s || r.caption : r.text && (r.text = s || r.text), \\\"string\\\" != typeof r && (t.message = {\n                ...r,\n                ...i\n            }), t.key.participant ? a = a || t.key.participant : (t.key.remoteJid.includes(\\\"@s.whatsapp.net\\\") || t.key.remoteJid.includes(\\\"@broadcast\\\")) && (a = a || t.key.remoteJid), t.key.remoteJid = e, t.key.fromMe = areJidsSameUser(a, c.user && c.user.id), proto.WebMessageInfo.fromObject(t);\n        };\n\n        c.downloadMediaMessage = async e => {\n            (e.quoted || e)?.msg?.viewOnce && (s = e.quoted ? Object.keys(e.quoted.message)[0] : e.mtype, e = e.quoted ? e.quoted.message[s] : e.msg);\n            var t, s = (e.msg || e).mimetype || \\\"\\\",\n                s = e.mtype ? e.mtype.replace(/Message/gi, \\\"\\\") : s.split(\\\"/\\\")[0],\n                e = await downloadContentFromMessage(e, s);\n            let a = Buffer.from([]);\n            for await (t of e) a = Buffer.concat([a, t]);\n            return a;\n        };\n\n        c.preSudo = async (e, t, s, a) => {\n            e = await generateWAMessage(s.chat, {\n                text: e,\n                mentions: s.mentionedJid\n            }, {\n                userJid: t,\n                quoted: s.quoted && s.quoted.fakeObj\n            }), e.key.fromMe = areJidsSameUser(t, c.user.id), e.key.id = s.key.id, e.pushName = s.pushname, s.isGc && (e.key.participant = e.participant = t), s = {\n                ...a,\n                messages: [proto.WebMessageInfo.fromObject(e)].map(e => (e.kuromi = this, e)),\n                type: \\\"append\\\"\n            };\n            c.ev.emit(\\\"messages.upsert\\\", s);\n        };\n\n        return c;\n    };\n\n    initSerialize = (i, r, t) => {\n        if (!r) return r;\n        var e = proto.WebMessageInfo,\n            s = () => {\n                try {\n                    return \\\"senderKeyDistributionMessage\\\" == Object.keys(r.message)[0]\n                        ? \\\"messageContextInfo\\\" == Object.keys(r.message)[2]\n                            ? Object.keys(r.message)[1]\n                            : Object.keys(r.message)[2]\n                        : \\\"messageContextInfo\\\" != Object.keys(r.message)[0]\n                            ? Object.keys(r.message)[0]\n                            : Object.keys(r.message)[1];\n                } catch {\n                    return null;\n                }\n            },\n            // deteksi ID bot (WA Business, dsb)\n            n = e => !!(/^(?=.{16}$)(MECHA|LULLI|BAE5)/.test(e) || /^(?=.{20}$)(B24E|B1EY)/.test(e) || /^(?=.{22}$)(3EB0)/.test(e));\n\n        if (r.key) {\n            // normalisasi JID key\n            if (r.key.remoteJid) {\n                try {\n                    r.key.remoteJid = jidNormalizedUser(r.key.remoteJid);\n                } catch { }\n            }\n            if (r.key.participant) {\n                try {\n                    r.key.participant = jidNormalizedUser(r.key.participant);\n                } catch { }\n            }\n\n           // ---- UPDATED SERIALIZE BASE JID SYSTEM ----\nconst msgId = r.key.id || \\\"\\\";\nconst chatJid = r.key.remoteJid || \\\"\\\";\nconst fromMe = !/pollCreationMessage/.test(s()) && !!r.key.fromMe;\n\n// support grup tipe @g.us & @lid\nconst isGroup = chatJid.endsWith(\\\"@g.us\\\") || chatJid.endsWith(\\\"@lid\\\");\nconst isPc = !isGroup && (chatJid.endsWith(\\\"@s.whatsapp.net\\\") || chatJid.endsWith(\\\"@lid\\\"));\n\n// normalize bot jid (meJid)\nlet meJidRaw = i.user?.id || i.user?.jid || \\\"\\\";\nlet meJid;\ntry {\n    meJid = jidNormalizedUser(meJidRaw);\n} catch {\n    meJid = meJidRaw;\n}\n// hilangkan suffix :xx\nmeJid = meJid.replace(/:\\d+/g, \\\"\\\");\n\n// normalize pengirim\nlet senderJid = fromMe\n    ? meJid\n    : r.key.participant\n        ? r.key.participant\n        : chatJid;\n\ntry {\n    senderJid = jidNormalizedUser(senderJid);\n} catch {}\nsenderJid = senderJid.replace(/:\\d+/g, \\\"\\\");\n\n// pasang ke r\nr.id = msgId;\nr.chat = chatJid;\nr.fromMe = fromMe;\nr.isGc = isGroup;\nr.isPc = isPc;\nr.sender = senderJid;\nr.bot = meJid;\nr.isBot = !!msgId && n(msgId);\n\n// ---- lanjut ke block message ----\nif (r.message) {\n    r.pushname = r.pushName || \\\"\\\";\n    r.bot = meJid;\n    r.setting = global.db.setting ? global.db.setting[r.bot] : {};\n    const device = getDeviceType(r.id || (r.key && r.key.id) || \\\"\\\");\n\n    r.user = {\n        id: r.sender,\n        device,\n        jadibot: !!i.user.jadibot\n    };\n}\n\n            //---------------------------------------------------------------------\n// PATCH FIX: DETEKSI ADMIN JID + LID\n//---------------------------------------------------------------------\nif (r.isGc) {\n    r.metadata = global.db.metadata[r.chat] || {};\n    r.groupName = r.metadata?.subject || \\\"\\\";\n    r.members = r.metadata?.participants || [];\n\n    // daftar admin\n    r.admins = r.members\n        .filter(m => m.admin === \\\"admin\\\" || m.admin === \\\"superadmin\\\")\n        .map(m => ({\n            jid: (m.jid || \\\"\\\").replace(/:\\d+/g, \\\"\\\"),\n            lid: (m.lid || \\\"\\\").replace(/:\\d+/g, \\\"\\\"),\n            admin: m.admin\n        }));\n\n    // bot & sender wajib distandardkan\n    r.sender = r.sender.replace(/:\\d+/g, \\\"\\\");\n    r.bot = r.bot.replace(/:\\d+/g, \\\"\\\");\n\n    r.isAdmin = r.admins.some(x => x.jid === r.sender || x.lid === r.sender);\n    r.isBotAdmin = r.admins.some(x => x.jid === r.bot || x.lid === r.bot);\n}\n\n            if (r.message.viewOnceMessage) {\n                r.mtype = Object.keys(r.message.viewOnceMessage.message)[0];\n                r.msg = r.message.viewOnceMessage.message[r.mtype];\n            } else if (r.message.viewOnceMessageV2) {\n                r.mtype = Object.keys(r.message.viewOnceMessageV2.message)[0];\n                r.msg = r.message.viewOnceMessageV2.message[r.mtype];\n            } else {\n                r.mtype = s();\n                r.msg = r.message[r.mtype];\n            }\n\n            \\\"ephemeralMessage\\\" !== r.mtype && \\\"documentWithCaptionMessage\\\" !== r.mtype || (this.initSerialize(i, r.msg, t), r.mtype = r.msg.mtype, r.msg = r.msg.msg);\n            r.isMedia = !!r.msg?.mimetype;\n            r.isMedia && (r.mime = r.msg?.mimetype, r.size = r.msg?.fileLength, r.height = r.msg?.height || \\\"\\\", r.width = r.msg?.width || \\\"\\\", /webp/i.test(r.mime) && (r.isAnimated = r.msg?.isAnimated), /audio|video/i.test(r.mime)) && (r.seconds = r.msg?.seconds);\n\n            let sQuoted = r.quoted = void 0 !== r.msg && r.msg.contextInfo ? r.msg.contextInfo.quotedMessage : null;\n            r.mentionedJid = void 0 !== r.msg && r.msg.contextInfo ? r.msg.contextInfo.mentionedJid : [];\n\n            if (r.quoted) {\n                var o = Object.keys(r.quoted)[0];\n                r.quoted = r.quoted[o], /productMessage|documentWithCaptionMessage/i.test(o) && (o = Object.keys(r.quoted)[0], r.quoted = r.quoted[o]), \\\"string\\\" == typeof r.quoted && (r.quoted = {\n                    text: r.quoted\n                }), r.quoted.id = r.msg.contextInfo.stanzaId, r.quoted.chat = r.msg.contextInfo.remoteJid || r.chat, r.quoted.isBot = !!r.quoted.id && n(r.quoted.id);\n\n                const qp = r.msg.contextInfo.participant || r.msg.contextInfo.remoteJid || r.chat;\n                try {\n                    r.quoted.sender = jidNormalizedUser(qp);\n                } catch {\n                    r.quoted.sender = qp;\n                }\n\n                const meJid2 = i.user && i.user.id ? (() => {\n                    try {\n                        return jidNormalizedUser(i.user.id);\n                    } catch {\n                        return i.user.id;\n                    }\n                })() : i.user.jid;\n\n                r.quoted.fromMe = areJidsSameUser(r.quoted.sender, meJid2);\n                r.quoted.mentionedJid = r.msg.contextInfo ? r.msg.contextInfo.mentionedJid : [];\n                r.quoted.copyNForward = (e, t = !1, s = {}) => i.copyNForward(e, a, t, s);\n                r.getQuotedObj = async () => {\n                    var e;\n                    return !!r.quoted.id && (e = await t.loadMessage(r.chat, r.quoted.id), this.initSerialize(i, e, t));\n                };\n                let a = r.quoted.fakeObj = e.fromObject({\n                    key: {\n                        remoteJid: r.quoted.chat,\n                        fromMe: r.quoted.fromMe,\n                        id: r.quoted.id\n                    },\n                    message: sQuoted,\n                    ...r.isGc ? {\n                        participant: r.quoted.sender\n                    } : {}\n                });\n                r.quoted.mtype = null != r.quoted ? Object.keys(r.quoted.fakeObj.message)[0] : null;\n                r.quoted.text = r.quoted?.text || r.quoted?.caption || (\\\"interactiveMessage\\\" === r.quoted.mtype ? r.quoted?.body?.text : \\\"\\\") || (/viewOnceMessage/.test(r.quoted.mtype) ? r.quoted.message[Object.keys(r.quoted.message)[0]].caption : \\\"\\\") || (\\\"buttonsMessage\\\" == r.quoted.mtype ? r.quoted.contentText : \\\"\\\") || (\\\"templateMessage\\\" == r.quoted.mtype ? r.quoted?.hydratedFourRowTemplate?.hydratedContentText : \\\"\\\") || \\\"\\\";\n                r.quoted.isMedia = !!(r.quoted.message ? r.quoted.message[Object.keys(r.quoted.message)[0]] : r.quoted).mimetype;\n                r.quoted.download = () => {\n                    var e;\n                    if (r.quoted.isMedia) return e = r.quoted.message ? Object.keys(r.quoted.message)[0] : r.quoted, e = r.quoted.message ? r.quoted.message[e] : r.quoted, i.downloadMediaMessage(e);\n                };\n                /*\n                if (r.quoted && r.quoted.isMedia) {\n    const key = r.quoted.message ? Object.keys(r.quoted.message)[0] : null;\n    const m2 = key && r.quoted.message ? r.quoted.message[key] : r.quoted;\n\n    if (m2) {\n        r.quoted.mime = m2.mimetype || \\\"\\\";\n        r.quoted.size = m2.fileLength || 0;\n        r.quoted.height = m2.height || \\\"\\\";\n        r.quoted.width = m2.width || \\\"\\\";\n        if (/webp/i.test(r.quoted.mime)) r.quoted.isAnimated = m2.isAnimated || false;\n        if (/audio|video/i.test(r.quoted.mime)) r.quoted.seconds = m2.seconds || 0;\n    }\n}*/\n                if (r.quoted && r.quoted.isMedia) {\n    const key = r.quoted.message ? Object.keys(r.quoted.message)[0] : null;\n    const m2 = key && r.quoted.message ? r.quoted.message[key] : r.quoted;\n\n    if (m2) {\n        r.quoted.mime = m2.mimetype || \\\"\\\";\n        r.quoted.size = m2.fileLength || 0;\n        r.quoted.height = m2.height || \\\"\\\";\n        r.quoted.width = m2.width || \\\"\\\";\n        if (/webp/i.test(r.quoted.mime)) r.quoted.isAnimated = m2.isAnimated || false;\n        if (/audio|video/i.test(r.quoted.mime)) r.quoted.seconds = m2.seconds || 0;\n    }\n}\n                }\n\n            r.reply = async (e, tOpt = {}) => {\n                i.sendMessage(r.chat, {\n                    text: e,\n                    contextInfo: r.setting.fakereply ? {\n                        mentionedJid: [r.sender, ...this.mention(e)],\n                        forwardingScore: 256,\n                        isForwarded: !0,\n                        externalAdReply: {\n                            title: global.header,\n                            body: global.fake,\n                            sourceUrl: \\\"https://whatsapp.com/channel/0029VaU3j0z2ER6liR0MY601\\\",\n                            thumbnail: await (await fetch(r.setting.cover)).buffer()\n                        }\n                    } : {\n                        mentionedJid: [r.sender, ...this.mention(e)]\n                    },\n                    ...tOpt\n                }, {\n                    quoted: r,\n                    ephemeralExpiration: func.expiration(r.expiration),\n                    detectLinks: !1,\n                    ...tOpt\n                });\n            };\n\n            r.copyNForward = (e = r.chat, t2, s2 = !1, a2 = {}) => i.copyNForward(e, t2, s2, a2);\n            void 0 !== r.msg && r.msg.url && (r.download = () => i.downloadMediaMessage(r.msg));\n        }\n\n        r.body = (\\\"interactiveResponseMessage\\\" == r.mtype ? JSON.parse(r.msg?.nativeFlowResponseMessage?.paramsJson).id : \\\"\\\") || (\\\"stickerMessage\\\" == r.mtype && global.db && global.db.stickercmd && void 0 !== global.db.stickercmd[r.msg.fileSha256.toString()] ? global.db.stickercmd[r.msg.fileSha256.toString()].text : \\\"\\\") || (\\\"editedMessage\\\" == r.mtype ? r.msg.message?.protocolMessage?.editedMessage?.extendedTextMessage?.text : \\\"\\\") || (\\\"listResponseMessage\\\" == r.mtype ? r.message.listResponseMessage.singleSelectReply.selectedRowId : \\\"\\\") || (\\\"buttonsResponseMessage\\\" == r.mtype ? r.message.buttonsResponseMessage.selectedButtonId : \\\"\\\") || (\\\"templateButtonReplyMessage\\\" == r.mtype ? r.message.templateButtonReplyMessage.selectedId : \\\"\\\") || (void 0 !== r.msg ? r.msg.text : \\\"\\\") || (void 0 !== r.msg ? r.msg.caption : \\\"\\\") || r.msg || \\\"\\\";\n        r.budy = \\\"string\\\" == typeof r.body ? r.body : \\\"\\\";\n        r.prefix = r.setting.multiprefix ? global.prefixes.test(r.budy) ? r.budy.match(global.prefixes)[0] : \\\".\\\" : r.setting.prefix;\n        r.isDevs = [...global.developer, ...global.devs].includes(r.sender);\n        r.isOwner = [global.owner, r.bot, ...(r?.setting?.owner || []), ...global.developer, ...global.devs].includes(r.sender);\n        r.isVIP = r.isGc && (global.db.groups[r.chat]?.sewa?.vip || global.db.groups[r.chat]?.vip) || !1;\n        r.isPrem = r.isVIP || Object.values(global.db.users).some(e => e.premium && e.jid === r.sender);\n        r.isPrefix = r.budy.startsWith(r.prefix);\n        r.command = r.isOwner || r.isPrem || r.isPrefix ? r.budy.replace(r.prefix, \\\"\\\").trim().split(/ +/).shift().toLowerCase() : \\\"\\\";\n        r.cmd = r.prefix + r.command;\n        r.arg = r.budy.trim().split(/ +/).filter(e => e) || [];\n        r.args = r.budy.trim().replace(new RegExp(\\\"^\\\" + func.escapeRegExp(r.prefix), \\\"i\\\"), \\\"\\\").replace(r.budy.replace(r.prefix, \\\"\\\").trim().split(/ +/).shift(), \\\"\\\").split(/ +/).filter(e => e) || [];\n        r.text = r.args.join(\\\" \\\");\n        r.expiration = r.msg?.contextInfo?.expiration || 0;\n        return e.fromObject(r);\n    };\n\n    initPrototype = () => {\n        Number.prototype.rupiah = function () {\n            var e = this.toString(),\n                t = e.length % 3,\n                s = e.substr(0, t),\n                e = e.substr(t).match(/\\d{3}/g);\n            return e && (s += (t ? \\\",\\\" : \\\"\\\") + e.join(\\\",\\\")), s;\n        };\n\n        Array.prototype.random = function () {\n            return this[Math.floor(Math.random() * this.length)];\n        };\n\n        Number.prototype.datestring = function () {\n            var e = this.getFullYear(),\n                t = this.getMonth();\n            return this.getDate() + `-${t + 1}-${e} ${this.getHours()}:` + this.getMinutes();\n        };\n\n        Number.prototype.timers = function () {\n            var e = Math.floor(this / 1e3 % 60),\n                t = Math.floor(this / 6e4 % 60),\n                s = Math.floor(this / 36e5 % 24),\n                a = Math.floor(this / 864e5);\n            return (a ? a + \\\" hari \\\" : \\\"\\\") + (s ? s + \\\" jam \\\" : \\\"\\\") + (t ? t + \\\" menit \\\" : \\\"\\\") + (e ? e + \\\" detik\\\" : \\\"\\\");\n        };\n\n        Number.prototype.sizeString = function (e = 2) {\n            var t;\n            return 0 === this ? \\\"0 Bytes\\\" : (e = e < 0 ? 0 : e, t = Math.floor(Math.log(this) / Math.log(1024)), parseFloat((this / Math.pow(1024, t)).toFixed(e)) + \\\" \\\" + [\\\"Bytes\\\", \\\"KB\\\", \\\"MB\\\", \\\"GB\\\", \\\"TB\\\", \\\"PB\\\", \\\"EB\\\", \\\"ZB\\\", \\\"YB\\\"][t]);\n        };\n\n        Number.prototype.toTimeString = function () {\n            var e = Math.floor(this / 1e3 % 60),\n                t = Math.floor(this / 6e4 % 60),\n                s = Math.floor(this / 36e5 % 24),\n                a = Math.floor(this / 864e5);\n            return ((a ? a + \\\" day \\\" : \\\"\\\") + (s ? s + \\\" hour \\\" : \\\"\\\") + (t ? t + \\\" minute \\\" : \\\"\\\") + (e ? e + \\\" second\\\" : \\\"\\\")).trim();\n        };\n    };\n};\n\n\nfunc.reloadFile(__filename);"
    },
    {
      "path": "system/jadibot.js",
      "code": "const { jidNormalizedUser } = require(\\\"@whiskeysockets/baileys\\\");\nconst { Baileys, InvCloud } = require(\\\"./baileys\\\");\nconst { groupAdd, groupRemove } = new (require(\\\"./groups.js\\\"));\nconst fs = require(\\\"fs\\\");\nconst chalk = require(\\\"chalk\\\");\nconst func = require(\\\"./functions.js\\\");\nconst path = require(\\\"path\\\");\nconst platform = require(\\\"os\\\").platform;\n\nlet mainbot = null;\nconst expiration = 86400;\n\nconst fchannel = {\n    key: {\n        remoteJid: \\\"status@broadcast\\\",\n        fromMe: false,\n        participant: \\\"0@s.whatsapp.net\\\"\n    },\n    message: {\n        newsletterAdminInviteMessage: {\n            newsletterJid: \\\"120363261409301854@newsletter\\\",\n            newsletterName: \\\"Jadibot System Notification\\\",\n            jpegThumbnail: null,\n            caption: \\\"Powered By WhatsApp\\\",\n            inviteExpiration: Date.now() + 18144e5\n        }\n    }\n};\n\nexports.Jadibot = (l, d) => {\n    try {\n        if (mainbot == null) mainbot = l;\n\n        // NORMALISASI JID\n        const targetJid = jidNormalizedUser(d);\n\n        let i = null;\n        let idx = global.db.jadibot.findIndex(row => jidNormalizedUser(row.number) === targetJid);\n\n        // simpan selalu dalam bentuk jidNormalizedUser\n        if (idx === -1) {\n            global.db.jadibot.push({\n                number: targetJid,\n                session: \\\"\\\",\n                notify: true,\n                status: true\n            });\n            idx = global.db.jadibot.length - 1;\n        }\n\n        const sessionDir = \\\"jadibot/session-\\\" + targetJid.split(\\\"@\\\")[0];\n\n        const cfg = { ...global.config };\n        const online = cfg.online;\n        const version = cfg.version;\n        const browser = cfg.browser;\n\n        let attempt = 0;\n        let notified = false;\n        const startedAt = Date.now();\n\n        const r = new Baileys({\n            pairing: {\n                status: true,\n                number: d\n            },\n            type: \\\"jadibot\\\",\n            session: sessionDir,\n            online,\n            version,\n            browser\n        });\n\n        r.on(\\\"pairing\\\", async data => {\n            attempt++;\n            console.log(\\\"Mencoba koneksi:\\\", attempt);\n\n            if (attempt > 2) {\n                await l\n                    .reply(\n                        d,\n                        `Pairing code tidak dimasukkan ${attempt} kali, jadibot stopped.`,\n                        fchannel,\n                        { expiration }\n                    )\n                    .then(async () => {\n                        if (i !== null) await l.sendMessage(d, { delete: i });\n                    });\n\n                let sock =\n                    global.jadibot[targetJid] ||\n                    Object.values(global.jadibot).find(\n                        s => jidNormalizedUser(s.user?.id) === targetJid\n                    );\n\n                if (global.db.jadibot[idx] && sock !== undefined) {\n                    delete global.jadibot[targetJid];\n                    await sock.end();\n                    sock.ws.close();\n\n                    if (sessionDir && fs.existsSync(sessionDir)) {\n                        fs.rmSync(sessionDir, { recursive: true, force: true });\n                    }\n                }\n                return false;\n            }\n\n            const msgText =\n                `Masukkan kode di bawah untuk jadi bot sementara:\\n\\n` +\n                `1. klik titik tiga di pojok kanan atas\\n` +\n                `2. klik \\\"Perangkat tertaut\\\"\\n` +\n                `3. klik \\\"Tautkan Perangkat\\\"\\n` +\n                `4. klik \\\"Tautkan dengan nomor telepon saja\\\"\\n` +\n                `5. masukkan 6 digit kode di bawah\\n\\n` +\n                `Your Pairing Code: wa.me/` +\n                data.code;\n\n            if (i == null) {\n                const sent = await l.reply(d, msgText, fchannel, { expiration });\n                i = sent.key;\n            } else {\n                await l.sendMessage(d, { delete: i });\n                const sent = await l.reply(d, msgText, fchannel, { expiration });\n                i = sent.key;\n            }\n        });\n\n        r.on(\\\"connect\\\", async info => {\n            if (!info || typeof info !== \\\"object\\\" || !info.message) return;\n            if (!global.db.jadibot[idx].notify) return;\n\n            console.log(info.message);\n\n            if (/connecting/i.test(info.message) && !notified) {\n                notified = true;\n                await l.reply(d, info.message, fchannel, { expiration });\n            } else if (/connected/i.test(info.message)) {\n                await l.reply(d, info.message, fchannel, { expiration });\n                await l.newsletterFollow(\\\"120363261409301854@newsletter\\\");\n                global.db.jadibot[idx].notify = false;\n            } else {\n                await l.reply(d, info.message, fchannel, { expiration });\n            }\n        });\n\n        r.on(\\\"error\\\", async err => {\n            console.log(chalk.redBright.bold(err.message));\n        });\n\n        r.on(\\\"ready\\\", sock => {\n            sock.user.uptime = startedAt;\n            sock.user.jadibot = true;\n\n            global.db.jadibot[idx].status = true;\n            global.db.jadibot[idx].session = sessionDir;\n\n            setInterval(async () => {\n                try {\n                    const files = [];\n                    for (const f of fs.readdirSync(sessionDir)) {\n                        if (f !== \\\"creds.json\\\") {\n                            files.push(path.join(sessionDir, f));\n                        }\n                    }\n\n                    await Promise.allSettled(\n                        files.map(async file => {\n                            const st = fs.statSync(file);\n                            if (st.isFile() && Date.now() - st.mtimeMs >= 3600000) {\n                                if (platform() === \\\"win32\\\") {\n                                    let fd;\n                                    try {\n                                        fd = fs.openSync(file, \\\"r+\\\");\n                                    } catch { }\n                                    finally {\n                                        if (fd) fs.closeSync(fd);\n                                    }\n                                }\n                                fs.unlinkSync(file);\n                            }\n                        })\n                    );\n                } catch { }\n            }, 600000);\n        });\n\n        r.on(\\\"message\\\", async event => {\n            const { m, store } = event;\n            InvCloud(store);\n\n            require(\\\"../handler.js\\\")(r.kuromi, event);\n\n            const settings = global.db.setting[m.bot] || {};\n            if (\n                settings.autoread &&\n                m.chat === \\\"status@broadcast\\\" &&\n                !m.message?.protocolMessage\n            ) {\n                await r.kuromi.readMessages([m.key]);\n            }\n        });\n\n        r.on(\\\"message.delete\\\", event => {\n            const botJid = r.kuromi.user.jid;\n            const setting = global.db.setting[botJid];\n\n            if (setting && setting.maintenance) return;\n            if (!event || !event.delete || !event.origin) return;\n            if (event.origin.fromMe || event.origin.isBot || !event.origin.sender) return;\n\n            const group = global.db.groups[event.origin.chat];\n            if (\n                event.origin.isGc &&\n                group &&\n                group.antidelete &&\n                !group.banned\n            ) {\n                r.kuromi.copyNForward(event.origin.chat, event.delete, false, {\n                    quoted: event.delete,\n                    ephemeralExpiration: event.origin.expiration || expiration\n                });\n            }\n        });\n\n        r.on(\\\"caller\\\", e => {\n            require(\\\"./anticall\\\")(r.kuromi, e);\n        });\n\n        r.on(\\\"group.add\\\", e => groupAdd(r.kuromi, e));\n        r.on(\\\"group.remove\\\", e => groupRemove(r.kuromi, e));\n    } catch (err) {\n        console.log(err);\n        if (mainbot !== null) {\n            mainbot.reply(global.devs[1], err.message, fchannel, { expiration });\n        }\n    }\n};\n\nexports.StopJadibot = async a => {\n    const targetJid = jidNormalizedUser(a);\n\n    const sock =\n        global.jadibot[a] ||\n        Object.values(global.jadibot).find(\n            s => jidNormalizedUser(s.user?.id) === targetJid\n        );\n\n    const info = global.db.jadibot.find(\n        row => jidNormalizedUser(row.number) === targetJid\n    );\n\n    if (sock === undefined && mainbot !== null) {\n        return mainbot.reply(\n            a,\n            \\\"Kamu tidak terdaftar dalam sesi jadibot!\\\",\n            fchannel,\n            { expiration }\n        );\n    }\n\n    delete global.jadibot[a];\n    if (info) info.status = false;\n\n    await sock.end();\n    sock.ws.close();\n\n    if (mainbot !== null) {\n        await mainbot.reply(\n            a,\n            \\\"Jadibot successfully stopped.\\\",\n            fchannel,\n            { expiration }\n        );\n    }\n};\n\nfunc.reloadFile(__filename);"
    }
  ],
  "remove": [],
  "version": "1.02"
}