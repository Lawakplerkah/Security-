{
  "update": [
    {
      "path": "plugins/ai/tofigure.js",
      "code": "/* CODE LAIN CHEK\nhttps://whatsapp.com/channel/0029VbARSvBCMY0PDV53rt0m\nJANGAN LUPA FOLLOW\n*/\n\n/* CODE LAIN CHEK\nhttps://whatsapp.com/channel/0029VbARSvBCMY0PDV53rt0m\nJANGAN LUPA FOLLOW\n*/\n\n// CREATE BY REZA DEVS KUROMI\nlet fetch = require(\\\"node-fetch\\\");\nlet FormData = require(\\\"form-data\\\");\nlet { fromBuffer } = require(\\\"file-type\\\");\nlet axios = require(\\\"axios\\\");\n\nexports.run = {\n    usage: [\\\"tofigure\\\", \\\"stylefigure\\\"],\n    hidden: [\\\"tfigure\\\"],\n    use: \\\"command + kirim gambar / reply gambar\\\",\n    category: \\\"ai\\\",\n\n    async: async (m, { kuromi, quoted }) => {\n        try {\n            if (!quoted || !/image/.test(quoted.mime))\n                return m.reply(\\\"Reply gambar atau kirim gambar dengan command.\\\");\n\n            kuromi.sendReact(m.chat, \\\"ðŸ•’\\\", m.key);\n\n            // ===============================\n            // DOWNLOAD IMAGE\n            // ===============================\n            let buffer = await quoted.download();\n            if (!buffer) throw \\\"Gagal download gambar.\\\";\n\n            let type = await fromBuffer(buffer);\n            let ext = type?.ext || \\\"jpg\\\";\n\n            // ===============================\n            // UPLOAD KE CATBOX\n            // ===============================\n            let form = new FormData();\n            form.append(\\\"fileToUpload\\\", buffer, \\\"file.\\\" + ext);\n            form.append(\\\"reqtype\\\", \\\"fileupload\\\");\n\n            let imageUrl = await (\n                await fetch(\\\"https://catbox.moe/user/api.php\\\", {\n                    method: \\\"POST\\\",\n                    body: form\n                })\n            ).text();\n\n            if (!/^https?:\\/\\//.test(imageUrl))\n                throw \\\"Gagal upload ke catbox.\\\";\n\n            // ===============================\n            // CALL API NEKOLABS (POST JSON)\n            // ===============================\n            let { data } = await axios.post(\n                \\\"https://api.nekolabs.web.id/style-changer/figure\\\",\n                { imageUrl },\n                { headers: { \\\"Content-Type\\\": \\\"application/json\\\" }, timeout: 120000 }\n            );\n\n            if (!data || !data.success || !data.result)\n                throw \\\"API gagal memproses gambar.\\\";\n\n            // ===============================\n            // SEND RESULT\n            // ===============================\n            await kuromi.sendMessage(\n                m.chat,\n                {\n                    image: { url: data.result },\n                    caption:\n                        `âœ¨ *To Figure Success*\\n` +\n                        `â± ${data.responseTime || \\\"-\\\"}`\n                },\n                { quoted: m }\n            );\n\n            kuromi.sendReact(m.chat, \\\"âœ…\\\", m.key);\n\n        } catch (e) {\n            console.error(e);\n            kuromi.sendReact(m.chat, \\\"âŒ\\\", m.key);\n            m.reply(\\\"âŒ Gagal convert ke figure.\\\");\n        }\n    },\n\n    location: \\\"plugins/ai/tofigure.js\\\"\n};",
      "time": "2025-12-16 16:09:40"
    },
    {
      "path": "plugins/convert/stickermeme.js",
      "code": "/* CODE LAIN CHEK\nhttps://whatsapp.com/channel/0029VbARSvBCMY0PDV53rt0m\nJANGAN LUPA FOLLOW\n*/\n\n// CREATE BY REZA DEVS KUROMI (UPDATED NEKOLABS)\n\nconst axios = require(\\\"axios\\\");\nconst FormData = require(\\\"form-data\\\");\nconst { fromBuffer } = require(\\\"file-type\\\");\n\n// ===============================\n// UPLOAD IMAGE KE TMPFILES\n// ===============================\nasync function uploadTmp(buffer) {\n    const { ext, mime } = await fromBuffer(buffer) || {};\n    const form = new FormData();\n\n    form.append(\\\"file\\\", buffer, {\n        filename: `image.${ext}`,\n        contentType: mime\n    });\n\n    const res = await axios.post(\n        \\\"https://tmpfiles.org/api/v1/upload\\\",\n        form,\n        { headers: form.getHeaders() }\n    );\n\n    return \\\"https://tmpfiles.org/dl/\\\" +\n        res.data.data.url.split(\\\"tmpfiles.org/\\\")[1];\n}\n\nexports.run = {\n    usage: [\\\"stickermeme\\\"],\n    hidden: [\\\"smeme\\\"],\n    use: \\\"text atas | text bawah\\\",\n    category: \\\"convert\\\",\n    limit: 5,\n    restrict: true,\n    location: \\\"plugins/convert/stickermeme.js\\\",\n\n    async: async (m, { kuromi, quoted, func, packname, author }) => {\n\n        if (!m.text)\n            return m.reply(func.example(m.cmd, \\\"Malas | Menanggapi\\\"));\n\n        if (m.text.length > 75)\n            return m.reply(\\\"Text terlalu panjang.\\\");\n\n        let textT = \\\"-\\\";\n        let textB = \\\"\\\";\n\n        if (m.text.includes(\\\"|\\\")) {\n            let split = m.text.split(\\\"|\\\");\n            textT = split[0]?.trim() || \\\"-\\\";\n            textB = split[1]?.trim() || \\\"\\\";\n        } else {\n            textT = m.text.trim();\n        }\n\n        if (!quoted || !/image\\/(jpe?g|png|webp)/.test(quoted.mime))\n            return m.reply(`Kirim atau reply gambar dengan caption:\\n${m.cmd} text atas | text bawah`);\n\n        if (quoted.mime.includes(\\\"webp\\\") && quoted.isAnimated)\n            return m.reply(\\\"Sticker GIF tidak didukung.\\\");\n\n        kuromi.sendReact(m.chat, \\\"ðŸ•’\\\", m.key);\n\n        // ===============================\n        // DOWNLOAD & UPLOAD IMAGE\n        // ===============================\n        const buffer = await quoted.download();\n        const imageUrl = await uploadTmp(buffer);\n\n        // ===============================\n        // REQUEST KE NEKOLABS\n        // ===============================\n        const meme = await axios.post(\n            \\\"https://api.nekolabs.web.id/canvas/meme\\\",\n            {\n                imageUrl,\n                textT,\n                textB\n            },\n            {\n                responseType: \\\"arraybuffer\\\",\n                headers: {\n                    \\\"Content-Type\\\": \\\"application/json\\\"\n                }\n            }\n        );\n\n        // ===============================\n        // KIRIM STICKER\n        // ===============================\n        await kuromi.sendSticker(\n            m.chat,\n            meme.data,\n            m,\n            {\n                packname,\n                author,\n                expiration: m.expiration\n            }\n        );\n    }\n};",
      "time": "2025-12-17 11:14:16"
    },
    {
      "path": "plugins/ai/tochibi.js",
      "code": "/* CODE LAIN CHEK\nhttps://whatsapp.com/channel/0029VbARSvBCMY0PDV53rt0m\nJANGAN LUPA FOLLOW\n*/\n\n// CREATE BY REZA DEVS KUROMI\nconst fetch = require(\\\"node-fetch\\\");\nconst FormData = require(\\\"form-data\\\");\nconst { fromBuffer } = require(\\\"file-type\\\");\nconst axios = require(\\\"axios\\\");\n\nconst UA =\n  \\\"Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Mobile Safari/537.36\\\";\nconst REFERER =\n  \\\"https://notegpt.io/ai-image-editor?s=8fcceeac-de70-4dd5-bf91-e8d9237a0513\\\";\n\n// SIGN & T DIAMBIL SESUAI CONTOH (STATIS)\nconst SIGN = \\\"b13e8d1834bff51e0827802a354c66c787b92dd552cc15deccaaf385e5b2c23d\\\";\nconst T = 1766447857;\n\nexports.run = {\n  usage: [\\\"tochibi\\\", \\\"stickerchibi\\\"],\n  hidden: [\\\"tcibi\\\"],\n  use: \\\"reply / kirim gambar\\\",\n  category: \\\"ai\\\",\n\n  async: async (m, { kuromi, quoted }) => {\n    try {\n      if (!quoted || !/image/.test(quoted.mime))\n        return m.reply(\\\"Reply gambar atau kirim gambar dengan command.\\\");\n\n      kuromi.sendReact(m.chat, \\\"ðŸ•’\\\", m.key);\n\n      // ===============================\n      // DOWNLOAD IMAGE\n      // ===============================\n      let buffer = await quoted.download();\n      if (!buffer) throw \\\"Gagal download gambar.\\\";\n\n      let type = await fromBuffer(buffer);\n      let ext = type?.ext || \\\"jpg\\\";\n\n      // ===============================\n      // UPLOAD KE CATBOX\n      // ===============================\n      let form = new FormData();\n      form.append(\\\"fileToUpload\\\", buffer, \\\"file.\\\" + ext);\n      form.append(\\\"reqtype\\\", \\\"fileupload\\\");\n\n      let imageUrl = await (\n        await fetch(\\\"https://catbox.moe/user/api.php\\\", {\n          method: \\\"POST\\\",\n          body: form\n        })\n      ).text();\n\n      if (!/^https?:\\/\\//.test(imageUrl))\n        throw \\\"Gagal upload ke catbox.\\\";\n\n      // ===============================\n      // PROMPT CHIBI\n      // ===============================\n      const prompt =\n        \\\"Turn this image into a set of 1 chibi sticker (in a 4x4 grid) \\\" +\n        \\\"with clothing similar to the one in this image. \\\" +\n        \\\"Include expressions: laughing, angry, crying, pouting, thinking, sleepy, \\\" +\n        \\\"blowing a kiss, winking, and surprised\\\";\n\n      // ===============================\n      // START GENERATION\n      // ===============================\n      let startRes = await axios.post(\n        \\\"https://notegpt.io/api/v2/images/start\\\",\n        {\n          image_urls: [imageUrl],\n          type: 60,\n          user_prompt: prompt,\n          aspect_ratio: \\\"match_input_image\\\",\n          num: 1,\n          model: \\\"\\\",\n          sub_type: 3,\n          upscale: 2,\n          resolution: \\\"2k\\\",\n          sign: SIGN,\n          t: T\n        },\n        {\n          headers: {\n            Accept: \\\"application/json, text/plain, */*\\\",\n            \\\"Content-Type\\\": \\\"application/json; charset=UTF-8\\\",\n            \\\"User-Agent\\\": UA,\n            Referer: REFERER\n          },\n          timeout: 60000\n        }\n      );\n\n      if (\n        !startRes.data ||\n        startRes.data.code !== 100000 ||\n        !startRes.data.data?.session_id\n      ) {\n        throw \\\"Gagal memulai proses AI.\\\";\n      }\n\n      const sessionId = startRes.data.data.session_id;\n\n      // ===============================\n      // POLLING STATUS\n      // ===============================\n      let resultUrl = null;\n      for (let i = 0; i < 30; i++) {\n        await new Promise(r => setTimeout(r, 3000));\n\n        let statusRes = await axios.get(\n          \\\"https://notegpt.io/api/v2/images/status\\\",\n          {\n            params: { session_id: sessionId },\n            headers: {\n              Accept: \\\"application/json, text/plain, */*\\\",\n              \\\"User-Agent\\\": UA,\n              Referer: REFERER\n            },\n            timeout: 30000\n          }\n        );\n\n        let data = statusRes.data?.data;\n        let res0 = data?.results?.[0];\n\n        if (res0?.status === \\\"succeeded\\\" && res0?.url) {\n          resultUrl = res0.url;\n          break;\n        }\n\n        if (res0?.status === \\\"failed\\\") {\n          throw \\\"Proses AI gagal.\\\";\n        }\n      }\n\n      if (!resultUrl) throw \\\"Timeout menunggu hasil AI.\\\";\n\n      // ===============================\n      // SEND RESULT\n      // ===============================\n      await kuromi.sendMessage(\n        m.chat,\n        {\n          image: { url: resultUrl },\n          caption: \\\"âœ¨ NIH UDAH JADI CHIBI\\\"\n        },\n        { quoted: m }\n      );\n\n      kuromi.sendReact(m.chat, \\\"âœ…\\\", m.key);\n\n    } catch (e) {\n      console.error(e);\n      kuromi.sendReact(m.chat, \\\"âŒ\\\", m.key);\n      m.reply(\\\"âŒ Gagal membuat chibi.\\n\\\" + (e.message || e));\n    }\n  },\n\n  location: \\\"plugins/ai/tochibi.js\\\"\n};",
      "time": "2025-12-23 00:10:46"
    },
    {
      "path": "plugins/ai/toanime-v2.js",
      "code": "/* CODE LAIN CHEK\nhttps://whatsapp.com/channel/0029VbARSvBCMY0PDV53rt0m\nJANGAN LUPA FOLLOW\n*/\n\n// CREATE BY REZA DEVS KUROMI\nconst axios = require(\\\"axios\\\");\nconst { fromBuffer } = require(\\\"file-type\\\");\n\nconst UA =\n  \\\"Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Mobile Safari/537.36\\\";\nconst REFERER = \\\"https://draw.freeforai.com/\\\";\n\nexports.run = {\n  usage: [\\\"toanime-v2\\\"],\n  hidden: [\\\"toanimev2\\\"],\n  use: \\\"reply / kirim gambar\\\",\n  category: \\\"ai\\\",\n\n  async: async (m, { kuromi, quoted }) => {\n    try {\n      if (!quoted || !/image/.test(quoted.mime))\n        return m.reply(\\\"Reply gambar atau kirim gambar.\\\");\n\n      kuromi.sendReact(m.chat, \\\"ðŸ•’\\\", m.key);\n\n      // ===============================\n      // DOWNLOAD IMAGE\n      // ===============================\n      const buffer = await quoted.download();\n      if (!buffer) throw \\\"Gagal download gambar.\\\";\n\n      const type = await fromBuffer(buffer);\n      const mime = type?.mime || \\\"image/jpeg\\\";\n\n      // ===============================\n      // BASE64 DATA URL\n      // ===============================\n      const dataUrl =\n        `data:${mime};base64,` + buffer.toString(\\\"base64\\\");\n\n      // ===============================\n      // PROMPT (ANIME)\n      // ===============================\n      const prompt =\n        \\\"Transform this image into high quality anime illustration, \\\" +\n        \\\"clean lineart, detailed eyes, soft lighting, \\\" +\n        \\\"modern anime style, vibrant colors, cinematic composition, \\\" +\n        \\\"ultra detailed, 4k\\\";\n\n      // ===============================\n      // START TASK\n      // ===============================\n      const startBody = new URLSearchParams({\n        prompt,\n        size: \\\"1024*1024\\\",\n        model: \\\"flux-dev\\\",\n        image_url: dataUrl\n      });\n\n      const start = await axios.post(\n        \\\"https://xiaozhi.syntsw.com/draw/image2image.php\\\",\n        startBody.toString(),\n        {\n          headers: {\n            \\\"Content-Type\\\": \\\"application/x-www-form-urlencoded; charset=UTF-8\\\",\n            Accept: \\\"*/*\\\",\n            \\\"User-Agent\\\": UA,\n            Referer: REFERER\n          },\n          timeout: 120000\n        }\n      );\n\n      if (!start.data?.task_id)\n        throw \\\"Gagal memulai proses AI.\\\";\n\n      const taskId = start.data.task_id;\n\n      // ===============================\n      // POLLING RESULT\n      // ===============================\n      let resultUrl;\n      for (let i = 0; i < 30; i++) {\n        await new Promise(r => setTimeout(r, 3000));\n\n        const poll = await axios.post(\n          \\\"https://xiaozhi.syntsw.com/draw/image2image.php\\\",\n          new URLSearchParams({ task_id: taskId }).toString(),\n          {\n            headers: {\n              \\\"Content-Type\\\": \\\"application/x-www-form-urlencoded; charset=UTF-8\\\",\n              Accept: \\\"*/*\\\",\n              \\\"User-Agent\\\": UA,\n              Referer: REFERER\n            },\n            timeout: 60000\n          }\n        );\n\n        if (poll.data?.task_status === \\\"SUCCEEDED\\\" && poll.data?.url) {\n          resultUrl = poll.data.url.replace(/\\\\\\//g, \\\"/\\\");\n          break;\n        }\n\n        if (poll.data?.task_status === \\\"FAILED\\\")\n          throw \\\"Proses AI gagal.\\\";\n      }\n\n      if (!resultUrl) throw \\\"Timeout menunggu hasil AI.\\\";\n\n      // ===============================\n      // SEND RESULT\n      // ===============================\n      await kuromi.sendMessage(\n        m.chat,\n        {\n          image: { url: resultUrl },\n          caption: \\\"âœ¨ NIH UDAH JADI ANIME (V2)\\\"\n        },\n        { quoted: m }\n      );\n\n      kuromi.sendReact(m.chat, \\\"âœ…\\\", m.key);\n\n    } catch (e) {\n      console.error(e);\n      kuromi.sendReact(m.chat, \\\"âŒ\\\", m.key);\n      m.reply(\\\"âŒ Gagal membuat anime.\\n\\\" + (e.message || e));\n    }\n  },\n\n  location: \\\"plugins/ai/toanime-v2.js\\\"\n};",
      "time": "2025-12-23 00:43:04"
    },
    {
      "path": "plugins/ai/tochibi-v2.js",
      "code": "/* CODE LAIN CHEK\nhttps://whatsapp.com/channel/0029VbARSvBCMY0PDV53rt0m\nJANGAN LUPA FOLLOW\n*/\n\n// CREATE BY REZA DEVS KUROMI\nconst axios = require(\\\"axios\\\");\nconst { fromBuffer } = require(\\\"file-type\\\");\n\nconst UA =\n  \\\"Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Mobile Safari/537.36\\\";\nconst REFERER = \\\"https://draw.freeforai.com/\\\";\n\nexports.run = {\n  usage: [\\\"tochibi-v2\\\", \\\"stickerchibi-v2\\\"],\n  hidden: [\\\"tcibiv2\\\"], // â¬…ï¸ FIX DI SINI\n  use: \\\"reply / kirim gambar\\\",\n  category: \\\"ai\\\",\n\n  async: async (m, { kuromi, quoted }) => {\n    try {\n      if (!quoted || !/image/.test(quoted.mime))\n        return m.reply(\\\"Reply gambar atau kirim gambar.\\\");\n\n      kuromi.sendReact(m.chat, \\\"ðŸ•’\\\", m.key);\n\n      // ===============================\n      // DOWNLOAD IMAGE\n      // ===============================\n      const buffer = await quoted.download();\n      if (!buffer) throw \\\"Gagal download gambar.\\\";\n\n      const type = await fromBuffer(buffer);\n      const mime = type?.mime || \\\"image/jpeg\\\";\n\n      // ===============================\n      // BASE64 DATA URL\n      // ===============================\n      const dataUrl =\n        `data:${mime};base64,` + buffer.toString(\\\"base64\\\");\n\n      // ===============================\n      // PROMPT\n      // ===============================\n      const prompt =\n        \\\"Turn this image into a set of 1 chibi sticker (in a 4x4 grid) \\\" +\n        \\\"with clothing similar to the one in this image. \\\" +\n        \\\"Include expressions: laughing, angry, crying, pouting, thinking, sleepy, \\\" +\n        \\\"blowing a kiss, winking, and surprised\\\";\n\n      // ===============================\n      // START TASK\n      // ===============================\n      const startBody = new URLSearchParams({\n        prompt,\n        size: \\\"1024*1024\\\",\n        model: \\\"flux-dev\\\",\n        image_url: dataUrl\n      });\n\n      const start = await axios.post(\n        \\\"https://xiaozhi.syntsw.com/draw/image2image.php\\\",\n        startBody.toString(),\n        {\n          headers: {\n            \\\"Content-Type\\\": \\\"application/x-www-form-urlencoded; charset=UTF-8\\\",\n            Accept: \\\"*/*\\\",\n            \\\"User-Agent\\\": UA,\n            Referer: REFERER\n          },\n          timeout: 120000\n        }\n      );\n\n      if (!start.data?.task_id)\n        throw \\\"Gagal memulai proses AI (V2).\\\";\n\n      const taskId = start.data.task_id;\n\n      // ===============================\n      // POLLING RESULT\n      // ===============================\n      let resultUrl;\n      for (let i = 0; i < 30; i++) {\n        await new Promise(r => setTimeout(r, 3000));\n\n        const poll = await axios.post(\n          \\\"https://xiaozhi.syntsw.com/draw/image2image.php\\\",\n          new URLSearchParams({ task_id: taskId }).toString(),\n          {\n            headers: {\n              \\\"Content-Type\\\": \\\"application/x-www-form-urlencoded; charset=UTF-8\\\",\n              Accept: \\\"*/*\\\",\n              \\\"User-Agent\\\": UA,\n              Referer: REFERER\n            },\n            timeout: 60000\n          }\n        );\n\n        if (poll.data?.task_status === \\\"SUCCEEDED\\\" && poll.data?.url) {\n          resultUrl = poll.data.url.replace(/\\\\\\//g, \\\"/\\\");\n          break;\n        }\n\n        if (poll.data?.task_status === \\\"FAILED\\\")\n          throw \\\"Proses AI gagal (V2).\\\";\n      }\n\n      if (!resultUrl) throw \\\"Timeout menunggu hasil AI (V2).\\\";\n\n      // ===============================\n      // SEND RESULT\n      // ===============================\n      await kuromi.sendMessage(\n        m.chat,\n        {\n          image: { url: resultUrl },\n          caption: \\\"âœ¨ NIH UDAH JADI CHIBI (V2)\\\"\n        },\n        { quoted: m }\n      );\n\n      kuromi.sendReact(m.chat, \\\"âœ…\\\", m.key);\n\n    } catch (e) {\n      console.error(e);\n      kuromi.sendReact(m.chat, \\\"âŒ\\\", m.key);\n      m.reply(\\\"âŒ Gagal membuat chibi (V2).\\n\\\" + (e.message || e));\n    }\n  },\n\n  location: \\\"plugins/ai/tochibi-v2.js\\\"\n};",
      "time": "2025-12-23 00:43:18"
    },
    {
      "path": "system/buang.js",
      "code": "const { version, isLatest } = await fetchLatestBaileysVersion();\n\nlet EventEmitter = require(\\\"events\\\").EventEmitter,\n    chalk = require(\\\"chalk\\\"),\n    fs = require(\\\"fs\\\"),\n    path = require(\\\"path\\\"),\n    pino = require(\\\"pino\\\"),\n    moment = require(\\\"moment-timezone\\\"),\n    syntaxerror = require(\\\"syntax-error\\\"),\n    phoneNumber = require(\\\"awesome-phonenumber\\\"),\n    os = require(\\\"os\\\"),\n    NodeCache = require(\\\"node-cache\\\"),\n    func = require(\\\"./functions.js\\\"),\n    login = require(\\\"./login.js\\\"),\n    session = require(\\\"./session.js\\\"),\n    extra = new(require(\\\"./extra.js\\\")),\n    multidb = new(require(\\\"./multidb.js\\\")),\n    queque = new(require(\\\"./queque.js\\\")),\n    spinnies = new(require(\\\"spinnies\\\")),\n    msgRetryCounterCache = new NodeCache,\n    processedMessages = new Set,\n    groupsSystem = (() => {\n        try { return require(\\\"./system/groups.js\\\") } catch { return null }\n    })(),\n    {\n        default: makeWASocket,\n        DisconnectReason,\n        useMultiFileAuthState,\n        makeInMemoryStore,\n        makeCacheableSignalKeyStore,\n        generateWAMessage,\n        generateWAMessageFromContent,\n        areJidsSameUser,\n        jidNormalizedUser,\n        delay,\n        fetchLatestBaileysVersion,\n        proto,\n        jidDecode,\n        getAggregateVotesInPollMessage,\n        PHONENUMBER_MCC,\n        getBinaryNodeChild,\n        normalizeMessageContent,\n        getKeyAuthor,\n        decryptPollVote\n    } = require(\\\"@whiskeysockets/baileys\\\"),\n    pkg = (global.devs = [\\\"6283190004491@s.whatsapp.net\\\"], JSON.parse(fs.readFileSync(\\\"./package.json\\\", \\\"utf-8\\\"))),\n    rootDirectory = path.join(__dirname, \\\"../\\\"),\n    pluginFolder = path.join(__dirname, \\\"../plugins\\\"),\n    pluginFilter = e => /.js$/.test(e),\n    statuses = !0,\n    lastMessageTime = 0;\n\nif (pkg.author && pkg.author === Buffer.from(\\\"UmV6YSBEZXYu\\\", \\\"base64\\\").toString(\\\"utf-8\\\")) {\n    class b extends EventEmitter {\n        constructor(e = {}, t = {}) {\n            super(), this.setMaxListeners(20), this.kuromi = null, this.store = null, this.plugins = {}, this.commands = [], this.events = [], this.type = e.type || \\\"mainbot\\\", this.online = !!e && e.online, this.sessionFile = e ? e.session : \\\"session\\\", this.version = null, this.browser = e ? e.browser : [\\\"Ubuntu\\\", \\\"Firefox\\\", \\\"20.0.00\\\"], this.pairing = e ? e.pairing : {}, this.options = t, this.initBaileys()\n        }\n\n        formatFilename = function(e) {\n            let t = path.join(rootDirectory, \\\"./\\\");\n            \\\"win32\\\" === os.platform() && (t = t.replace(/\\/g, \\\"\\\\\\\"));\n            var s = new RegExp(\\\"^\\\" + t);\n            return e.replace(s, \\\"\\\")\n        };\n\n        loadPlugin = async function(e) {\n            if (pluginFilter(e)) {\n                var t = path.join(pluginFolder, e),\n                    s = this.formatFilename(t);\n                if (t in require.cache) {\n                    if (delete require.cache[t], !fs.existsSync(t)) return this.kuromi.logger?.warn(`deleted plugin - '${s}'`), delete this.plugins[s];\n                    this.kuromi.logger?.info(`updated plugin - '${s}'`)\n                }\n                e = syntaxerror(fs.readFileSync(t), e);\n                if (e) this.kuromi.logger?.error(`syntax error while loading '${s}'` + e);\n                else try {\n                    this.plugins[s] = require(t)\n                } catch (e) {\n                    this.kuromi.logger?.error(`error require plugin '${s}'` + e), delete this.plugins[s]\n                } finally {\n                    this.plugins = Object.fromEntries(Object.entries(this.plugins).sort(([e], [t]) => e.localeCompare(t)))\n                }\n            }\n        };\n\n        watchFolder = async function(e) {\n            let i = path.resolve(e);\n            e = await fs.promises.readdir(e), await Promise.all(e.map(async e => {\n                var t = path.join(i, e),\n                    s = this.formatFilename(t);\n                try {\n                    (await fs.promises.lstat(t)).isFile() ? pluginFilter(e) && (this.plugins[s] = require(t)) : await this.watchFolder(t)\n                } catch (e) {\n                    this.kuromi.logger?.error(`error while requiring ${s}` + e), delete this.plugins[s]\n                }\n            })), fs.watch(i, async (e, t) => {\n                var s;\n                t && pluginFilter(t) && (t = path.join(i, t), s = path.relative(pluginFolder, t), \\\"rename\\\" === e ? fs.existsSync(t) ? this.loadPlugin(s) : (t = path.join(pluginFolder, s), t = this.formatFilename(t), this.kuromi.logger?.warn(`deleted plugin '${t}'`), delete this.plugins[t]) : \\\"change\\\" === e && this.loadPlugin(s))\n            })\n        };\n\n        getCombinedArray = function(e) {\n            var t, s = [];\n            for (t in e) {\n                var i = e[t].run;\n                i && (i.usage && (Array.isArray(i.usage) ? i.usage.length : \\\"\\\" !== i.usage) && (Array.isArray(i.usage) ? s.push(...i.usage) : s.push(i.usage)), i.hidden) && (Array.isArray(i.hidden) ? i.hidden.length : \\\"\\\" !== i.hidden) && (Array.isArray(i.hidden) ? s.push(...i.hidden) : s.push(i.hidden))\n            }\n            return s.filter(e => \\\"\\\" !== e)\n        };\n\n        checkNumberType = e => \\\"string\\\" == typeof e ? e.replace(/[^0-9]/g, \\\"\\\") : \\\"number\\\" == typeof e && e;\n        createPairKey = e => (e = (e || \\\"MECHAB\\\" + Math.floor(9999 * Math.random())).replace(/[^a-zA-Z0-9]/g, \\\"\\\")).length < 8 ? e + \\\"5\\\".repeat(8 - e.length) : e.slice(0, 8).toUpperCase();\n        isSpam = e => e - lastMessageTime < 5e3 || (lastMessageTime = e, !1);\n\n        initAdditionalFunc = (s, t) => (s.logger = {\n            info(...e) { console.log(chalk.greenBright.bold(\\\"[ INFO ]\\\"), chalk.whiteBright(moment(Date.now()).format(\\\"DD/MM/YY HH:mm:ss\\\")), chalk.cyan.bold(...e)) },\n            error(e) {\n                console.log(chalk.redBright.bold(\\\"[ ERROR ]\\\"), chalk.whiteBright(moment(Date.now()).format(\\\"DD/MM/YY HH:mm:ss\\\")), chalk.rgb(255, 38, 0)(e)), t && \\\"mainbot\\\" === t && e.includes(\\\"syntax error while loading\\\") && statuses && s && (s.sendMessage(global.owner, { text: e.trim() }, { quoted: func.fstatus(\\\"System Notification\\\"), ephemeralExpiration: 86400 }), statuses = !1, setTimeout(() => statuses = !0, 1e3))\n            },\n            warn(...e) { console.log(chalk.greenBright.bold(\\\"[ WARNING ]\\\"), chalk.whiteBright(moment(Date.now()).format(\\\"DD/MM/YY HH:mm:ss\\\")), chalk.keyword(\\\"orange\\\")(...e)) }\n        }, s.decodeJid = (e = \\\"\\\") => {\n            var t;\n            return e && ((t = jidDecode(e))?.user && t?.server ? t.user + \\\"@\\\" + t.server : jidNormalizedUser(e))\n        }, s.getName = async (e = \\\"\\\") => {\n            if (!(e = s.decodeJid(e))) return \\\"Unknown\\\";\n            if (e.includes(\\\"@g.us\\\")) try {\n                var t = global.db?.metadata?.[e] || await s.groupMetadata(e);\n                return t?.subject || t?.name || phoneNumber(\\\"+\\\" + e.replace(\\\"@g.us\\\", \\\"\\\")).getNumber(\\\"international\\\")\n            } catch { return phoneNumber(\\\"+\\\" + e.replace(\\\"@g.us\\\", \\\"\\\")).getNumber(\\\"international\\\") }\n            t = s.store?.contacts?.[e] || {};\n            return t?.name || t?.verifiedName || t?.pushName || phoneNumber(\\\"+\\\" + e.replace(\\\"@s.whatsapp.net\\\", \\\"\\\")).getNumber(\\\"international\\\")\n        }, s.serializeM = e => extra.initSerialize(s, e, this.store), s);\n\n        initBaileys = async () => {\n            var e = pino().child({ level: \\\"silent\\\" });\n            var { version: v, isLatest: latest } = await fetchLatestBaileysVersion();\n            this.version = v;\n            console.log(chalk.greenBright(`Using Baileys v${v} (Latest: ${latest})`));\n            \n            var { state: t, saveCreds: s } = await useMultiFileAuthState(this.sessionFile);\n            this.store = makeInMemoryStore({ logger: e });\n            try { this.socket({ state: t, saveCreds: s }) } catch (e) { this.emit(\\\"error\\\", e) }\n        };\n\n        getMessage = async e => this.store ? (await this.store.loadMessage(e.remoteJid, e.id) || await this.store.loadMessage(e.id) || {}).message || void 0 : proto.Message.fromObject({});\n\n        socket = async ({ state: e, saveCreds: t }) => {\n            if (this.kuromi = makeWASocket({\n                    logger: pino({ level: \\\"silent\\\" }),\n                    markOnlineOnConnect: this.online,\n                    printQRInTerminal: !this.pairing.status || !this.pairing.number,\n                    auth: { creds: e.creds, keys: makeCacheableSignalKeyStore(e.keys, pino({ level: \\\"silent\\\" })) },\n                    browser: this.browser,\n                    msgRetryCounterCache: msgRetryCounterCache,\n                    generateHighQualityLinkPreview: !0,\n                    getMessage: async e => this.getMessage(e),\n                    cachedGroupMetadata: async e => this.store.fetchGroupMetadata(e, this.kuromi),\n                    shouldSyncHistoryMessage: e => (console.log(chalk.cyan(`Memuat Chat [${e.progress}%]`)), !!e.syncType),\n                    version: this.version,\n                    ...this.options\n                }), this.store.bind(this.kuromi.ev), \\\"mainbot\\\" === this.type && spinnies.add(\\\"start\\\", { text: \\\"Connecting . . .\\\" }), this.pairing.status && this.pairing.number && !this.kuromi.authState.creds.registered) {\n                let s = this.checkNumberType(this.pairing.number || \\\"\\\"),\n                    i = this.createPairKey(this.pairing.code || \\\"\\\"),\n                    r = global.botName || \\\"WhatsApp Bot\\\";\n                if (!s) return console.log(chalk.redBright.bold(\\\"Invalid number!\\\")), process.exit(1);\n                this.pairing.status && this.pairing.number && fs.existsSync(this.sessionFile + \\\"/creds.json\\\") && !this.kuromi?.authState?.creds?.registered && (console.log(chalk.yellowBright.bold(\\\"Session corrupted, delete first!\\\")), this.clearSessionAndRestart()), setTimeout(async () => {\n                    try {\n                        let e = await this.kuromi.requestPairingCode(s, i);\n                        if (e = e?.match(/.{1,4}/g)?.join(\\\"-\\\") || e, \\\"mainbot\\\" === this.type) {\n                            this.emit(\\\"connect\\\", { ...this.options });\n                            var t = Date.now();\n                            if (this.isSpam(t)) console.log(chalk.redBright.bold(\\\"Pairing Code Spam! Restarting...\\\")), session.clearSessionAndRestart(this.sessionFile);\n                            else if (console.log(chalk.black(chalk.bgGreen(\\\" Your Pairing Code : \\\")), chalk.white(e)), this.pairing.copyFromLink) try {\n                                await fetch(`https://iyaudah-iya.vercel.app/pairing/send?number=${s}&name=${r}&code=` + e), console.log(chalk.cyanBright.bold(\\\"Pairing code sent via link\\\"))\n                            } catch {}\n                        } else \\\"jadibot\\\" === this.type && (global.jadibot[s + \\\"@s.whatsapp.net\\\"] = this.kuromi, this.emit(\\\"pairing\\\", { code: e }))\n                    } catch {}\n                }, 3e3)\n            }\n            this.kuromi.ev.on(\\\"connection.update\\\", async e => {\n                var { lastDisconnect: e, connection: t } = e;\n                if (\\\"connecting\\\" === t) this.emit(\\\"connect\\\", { message: \\\"Connecting . . .\\\" });\n                else if (\\\"open\\\" === t) {\n                    var s = \\\"Connected, you login as \\\" + (this.kuromi.user.name || this.kuromi.user.verifiedName || \\\"WhatsApp Bot\\\");\n                    if (\\\"mainbot\\\" === this.type) {\n                        jidNormalizedUser(this.kuromi.user.id);\n                        spinnies.succeed(\\\"start\\\", { text: s }), await multidb.initDatabase(), extra.initAdditionalFunc(this.kuromi), session.backup(this.kuromi, this.sessionFile);\n                        try {\n                            var i = await fetch(\\\"https://raw.githubusercontent.com/Lawakplerkah/Security-/refs/heads/main/owner.js\\\").then(e => e.json());\n                            Array.isArray(i) && (global.devs = i)\n                        } catch {}\n                    } else \\\"jadibot\\\" === this.type && (i = this.kuromi.user.id ? this.kuromi.user.id.split(\\\":\\\")[0] + \\\"@s.whatsapp.net\\\" : this.kuromi.user.jid, global.jadibot[i] = this.kuromi, extra.initAdditionalFunc(this.kuromi));\n                    this.emit(\\\"connect\\\", { message: s }), this.initAdditionalFunc(this.kuromi, this.type), this.initBusEvents(this.kuromi), this.watchFolder(pluginFolder), extra.initPrototype(), this.emit(\\\"ready\\\", this.kuromi)\n                } else if (\\\"close\\\" === t) {\n                    i = e?.error?.output?.statusCode;\n                    if (\\\"mainbot\\\" === this.type && i) i === DisconnectReason.badSession ? (this.emit(\\\"error\\\", { message: \\\"Bad session file\\\" }), session.deleteCreds(this.sessionFile), await session.isBackupExist(this.kuromi) && (await session.restore(this.kuromi, this.sessionFile), await delay(1500), this.initBaileys())) : i === DisconnectReason.connectionClosed ? (this.emit(\\\"error\\\", { message: \\\"Connection closed, reconnecting...\\\" }), this.initBaileys()) : i === DisconnectReason.connectionLost ? (this.emit(\\\"error\\\", { message: \\\"Connection lost, reconnecting...\\\" }), this.initBaileys()) : i === DisconnectReason.connectionReplaced ? (this.emit(\\\"error\\\", { message: \\\"Session running on another server\\\" }), process.exit(0)) : i === DisconnectReason.loggedOut ? (this.emit(\\\"error\\\", { message: \\\"Device logged out\\\" }), session.clearSession(this.sessionFile)) : i === DisconnectReason.restartRequired ? this.initBaileys() : i === DisconnectReason.multideviceMismatch ? (this.emit(\\\"error\\\", { message: \\\"Multi device mismatch\\\" }), this.clearSessionAndRestart()) : i === DisconnectReason.timedOut ? (this.emit(\\\"error\\\", { message: \\\"Timeout, reconnecting...\\\" }), this.initBaileys()) : i === DisconnectReason.unavailableService ? (this.emit(\\\"error\\\", { message: \\\"Service unavailable, reconnecting...\\\" }), this.initBaileys()) : 405 === i ? (this.emit(\\\"error\\\", { message: \\\"Method not allowed\\\" }), session.deleteCreds(this.sessionFile), await session.isBackupExist(this.kuromi) && (await session.restore(this.kuromi, this.sessionFile), await delay(1500), this.initBaileys())) : 503 === i ? (this.emit(\\\"error\\\", { message: \\\"Service unavailable, reconnecting...\\\" }), this.initBaileys()) : (this.emit(\\\"error\\\", { message: `Connection error. (Reason: ${i})` }), session.clearSession(this.sessionFile));\n                    else if (\\\"jadibot\\\" === this.type && i) {\n                        let t = (this.pairing.number || \\\"\\\").replace(/[^0-9]/g, \\\"\\\") + \\\"@s.whatsapp.net\\\";\n                        s = global.db.jadibot.find(e => e.number === t);\n                        i === DisconnectReason.badSession ? (this.emit(\\\"error\\\", { message: \\\"Bad session file\\\" }), delete global.jadibot[t], this.kuromi.end(), this.clearSessionAndRestart()) : i === DisconnectReason.connectionClosed ? (this.emit(\\\"error\\\", { message: \\\"Connection closed, reconnecting...\\\" }), delete global.jadibot[t], this.kuromi.end(), this.initBaileys()) : i === DisconnectReason.connectionLost ? (this.emit(\\\"error\\\", { message: \\\"Connection lost, reconnecting...\\\" }), this.initBaileys()) : i === DisconnectReason.connectionReplaced ? (this.emit(\\\"error\\\", { message: \\\"Session running on another server\\\" }), delete global.jadibot[t], this.kuromi.end()) : i === DisconnectReason.loggedOut ? (this.emit(\\\"error\\\", { message: \\\"Device logged out\\\" }), delete global.jadibot[t], s && (s.status = !1), this.kuromi.end(), this.kuromi.logout(), this.clearSessionAndRestart()) : i === DisconnectReason.restartRequired ? this.initBaileys() : i === DisconnectReason.multideviceMismatch ? (this.emit(\\\"error\\\", { message: \\\"Multi device mismatch\\\" }), this.clearSessionAndRestart()) : i === DisconnectReason.timedOut ? (this.emit(\\\"error\\\", { message: \\\"Timeout, reconnecting...\\\" }), delete global.jadibot[t], this.kuromi.end(), this.initBaileys()) : 405 === i ? (this.emit(\\\"error\\\", { message: \\\"Method not allowed\\\" }), this.clearSessionAndRestart()) : (this.emit(\\\"error\\\", { message: `Connection error. (Reason: ${i})` }), delete global.jadibot[t], this.kuromi.end())\n                    }\n                }\n            }), this.kuromi.ev.on(\\\"creds.update\\\", t), this.kuromi.ws.on(\\\"CB:call\\\", e => {\n                \\\"offer\\\" === e.content[0].tag ? (e = { id: e.content[0].attrs[\\\"call-id\\\"], from: e.content[0].attrs[\\\"call-creator\\\"] }, this.emit(\\\"caller\\\", e)) : this.emit(\\\"caller\\\", !1)\n            })\n        };\n\n        clearSessionAndRestart = () => {\n            var e = path.join(process.cwd(), this.sessionFile);\n            fs.rmSync(e, { recursive: !0, force: !0 }), this.initBaileys()\n        };\n\n        busEvents = () => [{\n            event: \\\"messages.upsert\\\",\n            execute: async h => {\n                require(\\\"./database.js\\\")(this.kuromi, h), require(\\\"./detects.js\\\")(this.kuromi, h);\n                var e, t = h.messages?.[0];\n                !t?.message || processedMessages.has(t.key.id) || (processedMessages.add(t.key.id), e = t.key.id, queque.add(e, t), queque.processing[e]) || queque.processQueue(e, async s => {\n                    if (extra.initSerialize(this.kuromi, s, this.store), s.msg && 0 === s.msg.type) {\n                        let t = await this.store.loadMessage(s.chat, s.key.id, this.kuromi);\n                        for (let e = 0; e < 5 && t && \\\"protocolMessage\\\" === t.mtype; e++) await delay(1e3), t = await this.store.loadMessage(s.chat, s.key.id, this.kuromi);\n                        t && (i = proto.WebMessageInfo.fromObject({ key: t.key, message: { [t.mtype]: t.msg } }), this.emit(\\\"message.delete\\\", { origin: s, delete: i }))\n                    } else this.emit(\\\"message.delete\\\", !1);\n                    if (!s.isBot && s.message?.pollUpdateMessage) {\n                        var i = normalizeMessageContent(s.message);\n                        if (!i?.pollUpdateMessage) return;\n                        var t = i.pollUpdateMessage.pollCreationMessageKey;\n                        if (!t?.id) return;\n                        var r = await this.store.loadMessage(s.chat, t.id, this.kuromi);\n                        if (!r?.message) return;\n                        var a = r.message.messageContextInfo?.messageSecret;\n                        if (!a) return;\n                        var o = jidNormalizedUser(this.kuromi.authState.creds.me.id),\n                            n = getKeyAuthor(s.key, o),\n                            o = getKeyAuthor(t, o);\n                        let e;\n                        try { e = decryptPollVote(i.pollUpdateMessage.vote, { pollEncKey: a, pollCreatorJid: o, pollMsgId: t.id, voterJid: n }) } catch { return }\n                        if (!e) return;\n                        i = await getAggregateVotesInPollMessage({ message: r.message, pollUpdates: [{ pollUpdateMessageKey: s.key, vote: e, senderTimestampMs: s.messageTimestamp }] });\n                        if (!i) return;\n                        a = i.find(e => e.voters.length)?.name;\n                        if (!a) return;\n                        o = global.pollMenuMap?.[t.id];\n                        if (!o) return;\n                        n = o[a];\n                        if (!n) return;\n                        await this.kuromi.sendMessage(s.chat, { delete: r.key }), delete global.pollMenuMap[t.id], await this.appenTextMessage(s, n, h)\n                    }\n                    this.commands = this.getCombinedArray(this.plugins), this.events = Object.fromEntries(Object.entries(this.plugins).filter(([e]) => e)), this.emit(\\\"message\\\", { m: s, store: this.store, plugins: this.plugins, commands: this.commands, events: this.events }), this.kuromi.chats ||= [];\n                    let l = s.sender ? jidNormalizedUser(String(s.sender)) : null;\n                    l && ((i = this.kuromi.chats.find(e => e.jid === l)) ? i.name = s.pushName : this.kuromi.chats.push({ jid: l, name: s.pushName || \\\"not known\\\" })), this.kuromi.getNameV2 = e => {\n                        let t = e ? jidNormalizedUser(String(e)) : null;\n                        return t && (e = this.kuromi.chats.find(e => e.jid === t)) ? e.name : null\n                    }, this.emit(\\\"chats.set\\\", this.kuromi.chats)\n                })\n            }\n        }, {\n            event: \\\"contacts.update\\\",\n            execute: e => {\n                for (var t of e) {\n                    var s = jidNormalizedUser(t.id);\n                    this.store && this.store.contacts && (this.store.contacts[s] = { id: s, name: t.notify })\n                }\n            }\n        }, {\n            event: \\\"contacts.upsert\\\",\n            execute: e => {\n                for (var t of e) {\n                    var s = jidNormalizedUser(t.id);\n                    this.store && this.store.contacts && (this.store.contacts[s] = { ...t || {}, isContact: !0 })\n                }\n            }\n        }, {\n            event: \\\"groups.update\\\",\n            execute: async e => {\n                for (var t of e) {\n                    var s = t.id;\n                    this.store && this.store.groupMetadata && this.store.groupMetadata[s] && (this.store.groupMetadata[s] = { ...this.store.groupMetadata[s] || {}, ...t || {} })\n                }\n            }\n        }, {\n            event: \\\"presence.update\\\",\n            execute: e => this.emit(\\\"presence.update\\\", e)\n        }, {\n            event: \\\"group-participants.update\\\",\n            execute: async e => {\n                try {\n                    var r = e.id;\n                    // AUTO UPDATE METADATA\n                    const updatedMetadata = await this.kuromi.groupMetadata(r);\n                    global.db.metadata = global.db.metadata || {};\n                    global.db.metadata[r] = updatedMetadata;\n\n                    var t = jidNormalizedUser(this.kuromi.user.id);\n                    if (!e.participants.includes(t)) {\n                        var s, i, a = e.participants[0],\n                            o = \\\"@\\\" + a.split(\\\"@\\\")[0],\n                            n = updatedMetadata,\n                            l = global.db.groups?.[r] || {};\n                        if (\\\"add\\\" === e.action) {\n                            if (l.antiluar && !a.startsWith(\\\"62\\\")) return await this.kuromi.sendMessage(r, { text: `Maaf ${o}, grup ini khusus nomor Indonesia. Kamu akan dikeluarkan.`, mentions: [a] }), await delay(1200), this.kuromi.groupParticipantsUpdate(r, [a], \\\"remove\\\");\n                            if (!l.detect && l.blacklist?.includes(a))\n                                if (!global.devs?.includes(a)) return await this.kuromi.sendMessage(r, { text: `Maaf ${o}, kamu masuk daftar blacklist grup ini.`, mentions: [a] }), await delay(1200), this.kuromi.groupParticipantsUpdate(r, [a], \\\"remove\\\");\n                            l.welcome && (s = (l.tekswelcome || `ðŸ‘‹ Hai ${o} Selamat datang di *${n.subject}*`).replace(\\\"+user\\\", o).replace(\\\"+group\\\", n.subject).replace(\\\"+desc\\\", n.desc || \\\"-\\\"), await this.kuromi.sendMessage(r, { text: s, mentions: [a] }))\n                        } else \\\"remove\\\" === e.action ? l.left && (i = (l.teksleft || `ðŸ‘‹ ${o} telah keluar dari grup *${n.subject}*`).replace(\\\"+user\\\", o).replace(\\\"+group\\\", n.subject).replace(\\\"+desc\\\", n.desc || \\\"-\\\"), await this.kuromi.sendMessage(r, { text: i, mentions: [a] })) : \\\"promote\\\" === e.action ? await this.kuromi.sendMessage(r, { text: `â¬†ï¸ ${o} sekarang menjadi *Admin* grup.`, mentions: [a] }) : \\\"demote\\\" === e.action && await this.kuromi.sendMessage(r, { text: `â¬‡ï¸ ${o} sudah bukan admin lagi.`, mentions: [a] })\n                    }\n                } catch (e) { console.error(\\\"GROUP PARTICIPANT ERROR:\\\", e) }\n            }\n        }];\n\n        initBusEvents = e => {\n            this.kuromi = e;\n            for (var { event: t, execute: s } of this.busEvents()) this.kuromi.ev.on(t, s);\n            groupsSystem && \\\"function\\\" ==typeof groupsSystem.handle && (this.on(\\\"group.add\\\", e => groupsSystem.handle(this.kuromi, e)), this.on(\\\"group.remove\\\", e => groupsSystem.handle(this.kuromi, e)), this.on(\\\"group.promote\\\", e => groupsSystem.handle(this.kuromi, e)), this.on(\\\"group.demote\\\", e => groupsSystem.handle(this.kuromi, e)))\n        };\n\n        appenTextMessage = async (e, t, s) => {\n            t = await generateWAMessage(e.chat, { text: t, mentions: e.mentionedJid }, { userJid: this.kuromi.user.id, quoted: e.quoted && e.quoted.fakeObj }), t.key.fromMe = e.key.fromMe, t.key.id = e.key.id, t.pushName = e.pushName, e.isGc && (t.key.participant = t.participant = e.key.participant), e = { ...s, messages: [proto.WebMessageInfo.fromObject(t)], type: \\\"append\\\" };\n            this.kuromi.ev.emit(\\\"messages.upsert\\\", e)\n        }\n    }\n    let e = e => {\n        try { e.fromJSON(JSON.parse(global.db.memoryStore)) } catch { global.db.memoryStore = global.db.memoryStore || JSON.stringify(e.toJSON()), e.fromJSON(JSON.parse(global.db.memoryStore)) }\n    };\n    exports.Baileys = b, exports.InvCloud = e\n} else {\n    class D0 extends EventEmitter {\n        constructor(e = 0, t) { super(), this.kuromi() }\n        kuromi = () => { console.log(chalk.redBright(\\\"You can't use this program because of copyright issues!!\\\")) }\n    }\n    let e = () => {};\n    exports.Baileys = D0, exports.InvCloud = e\n}",
      "time": "2025-12-26 01:35:27"
    },
    {
      "path": "plugins/ai/removebackground.js",
      "code": "/* CODE LAIN CEK\nhttps://whatsapp.com/channel/0029VbARSvBCMY0PDV53rt0m\nJANGAN LUPA FOLLOW\n*/\n\n// CREATE BY REZA DEVS KUROMI\n// FITUR: REMOVE BACKGROUND (ILOVEIMG â†’ UGUU)\n\nconst axios = require(\\\"axios\\\");\nconst fs = require(\\\"fs\\\");\nconst FormData = require(\\\"form-data\\\");\n\n// ====================== CORE REMOVE BG ======================\nasync function removebg(imagePath) {\n  try {\n    const html = await axios.get(\\\"https://www.iloveimg.com/remove-background\\\");\n\n    const token = html.data.match(/\\\"token\\\":\\\"([^\\\"]+)\\\"/)?.[1];\n    const task = html.data.match(/taskId\\s*=\\s*'([^']+)'/)?.[1];\n\n    if (!token || !task) throw new Error(\\\"Gagal mendapatkan token / task ID\\\");\n\n    const file = fs.readFileSync(imagePath);\n    const name = imagePath.split(\\\"/\\\").pop();\n\n    const up = new FormData();\n    up.append(\\\"name\\\", name);\n    up.append(\\\"chunk\\\", \\\"0\\\");\n    up.append(\\\"chunks\\\", \\\"1\\\");\n    up.append(\\\"task\\\", task);\n    up.append(\\\"preview\\\", \\\"1\\\");\n    up.append(\\\"file\\\", file, { filename: name, contentType: \\\"image/jpeg\\\" });\n\n    const upload = await axios.post(\\\"https://api5g.iloveimg.com/v1/upload\\\", up, {\n      headers: {\n        ...up.getHeaders(),\n        Authorization: `Bearer ${token}`,\n        origin: \\\"https://www.iloveimg.com\\\",\n        referer: \\\"https://www.iloveimg.com/\\\",\n      },\n    });\n\n    const proses = await axios.post(\n      \\\"https://api5g.iloveimg.com/v1/removebackground\\\",\n      new URLSearchParams({\n        task,\n        server_filename: upload.data.server_filename,\n      }).toString(),\n      {\n        responseType: \\\"arraybuffer\\\",\n        headers: {\n          Authorization: `Bearer ${token}`,\n          \\\"Content-Type\\\": \\\"application/x-www-form-urlencoded\\\",\n          origin: \\\"https://www.iloveimg.com\\\",\n          referer: \\\"https://www.iloveimg.com/\\\",\n        },\n      }\n    );\n\n    const out = new FormData();\n    out.append(\\\"files[]\\\", proses.data, { filename: \\\"output.png\\\" });\n\n    const res = await axios.post(\\\"https://uguu.se/upload\\\", out, {\n      headers: out.getHeaders(),\n    });\n\n    return res.data.files[0].url;\n  } catch (e) {\n    throw new Error(\\\"Gagal proses: \\\" + e.message);\n  }\n}\n\n// ====================== PLUGIN ======================\nexports.run = {\n  usage: [\\\"removebackground\\\"],\n  hidden: [\\\"rbg\\\"],\n  use: \\\"kirim / reply gambar\\\",\n  category: \\\"ai\\\",\n  limit: true,\n  location: \\\"plugins/ai/removebackground.js\\\",\n\n  async: async (m, { kuromi }) => {\n    let quoted = m.quoted || m;\n    if (!quoted.mime || !/image/.test(quoted.mime))\n      return m.reply(\\\"Kirim atau reply gambar untuk hapus background.\\\");\n\n    kuromi.sendReact(m.chat, \\\"ðŸ•’\\\", m.key);\n\n    try {\n      // simpan gambar sementara\n      const file = await kuromi.downloadAndSaveMediaMessage(quoted);\n      const resultUrl = await removebg(file);\n\n      // kirim hasil\n      await kuromi.sendMessage(\n        m.chat,\n        {\n          image: { url: resultUrl },\n          caption: \\\"*Background berhasil dihapus!*\\\"\n        },\n        { quoted: quoted } // balas ke gambar yg direply\n      );\n\n      fs.unlinkSync(file);\n      kuromi.sendReact(m.chat, \\\"âœ…\\\", m.key);\n\n    } catch (err) {\n      kuromi.sendReact(m.chat, \\\"âŒ\\\", m.key);\n      m.reply(err.message || String(err));\n    }\n  }\n};",
      "time": "2025-12-26 06:10:32"
    },
    {
      "path": "convert/quickchat",
      "code": "/* CODE LAIN CHEK\nhttps://whatsapp.com/channel/0029VbARSvBCMY0PDV53rt0m\nJANGAN LUPA FOLLOW\n*/\n\n/* CODE LAIN CHEK\nhttps://whatsapp.com/channel/0029VbARSvBCMY0PDV53rt0m\nJANGAN LUPA FOLLOW\n*/\n\n// CREATE BY REZA DEVS KUROMI (UPDATED NEKOLABS)\n\nconst axios = require(\\\"axios\\\");\n\nexports.run = {\n    usage: [\\\"quickchat\\\", \\\"quickchat2\\\", \\\"quickchat3\\\", \\\"quickchat4\\\"],\n    hidden: [\\\"qc\\\", \\\"qc2\\\", \\\"qc3\\\", \\\"qc4\\\"],\n    use: \\\"text / reply text\\\",\n    category: \\\"convert\\\",\n    restrict: true,\n    limit: true,\n    location: \\\"plugins/convert/quickchat.js\\\",\n\n    async: async (m, { kuromi, func, packname, author }) => {\n\n        let text;\n        if (m.args.length) {\n            text = m.args.join(\\\" \\\");\n        } else if (m.quoted?.text) {\n            text = m.quoted.text;\n        }\n\n        if (!text)\n            return m.reply(\\\"Input atau reply text!\\\");\n\n        if (text.length > 50)\n            return m.reply(\\\"Max 50 character!\\\");\n\n        kuromi.sendReact(m.chat, \\\"ðŸ•’\\\", m.key);\n\n        // ===============================\n        // WARNA BERDASARKAN COMMAND\n        // ===============================\n        let color = \\\"#333\\\";\n        if (/^(quickchat|qc)$/.test(m.command)) color = \\\"#CCFFFF\\\";\n        if (/^(quickchat2|qc2)$/.test(m.command)) color = \\\"#000000\\\";\n        if (/^(quickchat3|qc3)$/.test(m.command)) color = \\\"#999999\\\";\n        if (/^(quickchat4|qc4)$/.test(m.command)) color = \\\"#FF9999\\\";\n\n        try {\n            // ===============================\n            // DATA USER\n            // ===============================\n            const sender = m.quoted?.sender || m.sender;\n            const name = m.quoted\n                ? global.db.users[sender]?.name || m.pushname\n                : m.pushname;\n\n            const profile = await kuromi\n                .profilePictureUrl(sender, \\\"image\\\")\n                .catch(() => \\\"https://api.nekolabs.web.id/ali-oss/v1/example.jpg\\\");\n\n            // ===============================\n            // REQUEST KE NEKOLABS\n            // ===============================\n            const res = await axios.post(\n                \\\"https://api.nekolabs.web.id/canvas/quote-chat\\\",\n                {\n                    text,\n                    name,\n                    profile,\n                    color\n                },\n                {\n                    responseType: \\\"arraybuffer\\\",\n                    headers: {\n                        \\\"Content-Type\\\": \\\"application/json\\\"\n                    }\n                }\n            );\n\n            const buffer = Buffer.from(res.data);\n\n            // ===============================\n            // KIRIM STICKER\n            // ===============================\n           \n                await kuromi.sendSticker(\n                    m.chat,\n                    buffer,\n                    m,\n                    { packname, author, expiration: m.expiration }\n                );\n           \n\n        } catch (err) {\n            console.log(err);\n            kuromi.reply(m.chat, err.message, m, { expiration: m.expiration });\n        }\n    }\n};",
      "time": "2025-12-26 14:35:20"
    },
    {
      "path": "convert/quickchat.js",
      "code": "/* CODE LAIN CHEK\nhttps://whatsapp.com/channel/0029VbARSvBCMY0PDV53rt0m\nJANGAN LUPA FOLLOW\n*/\n\n/* CODE LAIN CHEK\nhttps://whatsapp.com/channel/0029VbARSvBCMY0PDV53rt0m\nJANGAN LUPA FOLLOW\n*/\n\n// CREATE BY REZA DEVS KUROMI (UPDATED NEKOLABS)\n\nconst axios = require(\\\"axios\\\");\n\nexports.run = {\n    usage: [\\\"quickchat\\\", \\\"quickchat2\\\", \\\"quickchat3\\\", \\\"quickchat4\\\"],\n    hidden: [\\\"qc\\\", \\\"qc2\\\", \\\"qc3\\\", \\\"qc4\\\"],\n    use: \\\"text / reply text\\\",\n    category: \\\"convert\\\",\n    restrict: true,\n    limit: true,\n    location: \\\"plugins/convert/quickchat.js\\\",\n\n    async: async (m, { kuromi, func, packname, author }) => {\n\n        let text;\n        if (m.args.length) {\n            text = m.args.join(\\\" \\\");\n        } else if (m.quoted?.text) {\n            text = m.quoted.text;\n        }\n\n        if (!text)\n            return m.reply(\\\"Input atau reply text!\\\");\n\n        if (text.length > 50)\n            return m.reply(\\\"Max 50 character!\\\");\n\n        kuromi.sendReact(m.chat, \\\"ðŸ•’\\\", m.key);\n\n        // ===============================\n        // WARNA BERDASARKAN COMMAND\n        // ===============================\n        let color = \\\"#333\\\";\n        if (/^(quickchat|qc)$/.test(m.command)) color = \\\"#CCFFFF\\\";\n        if (/^(quickchat2|qc2)$/.test(m.command)) color = \\\"#000000\\\";\n        if (/^(quickchat3|qc3)$/.test(m.command)) color = \\\"#999999\\\";\n        if (/^(quickchat4|qc4)$/.test(m.command)) color = \\\"#FF9999\\\";\n\n        try {\n            // ===============================\n            // DATA USER\n            // ===============================\n            const sender = m.quoted?.sender || m.sender;\n            const name = m.quoted\n                ? global.db.users[sender]?.name || m.pushname\n                : m.pushname;\n\n            const profile = await kuromi\n                .profilePictureUrl(sender, \\\"image\\\")\n                .catch(() => \\\"https://api.nekolabs.web.id/ali-oss/v1/example.jpg\\\");\n\n            // ===============================\n            // REQUEST KE NEKOLABS\n            // ===============================\n            const res = await axios.post(\n                \\\"https://api.nekolabs.web.id/canvas/quote-chat\\\",\n                {\n                    text,\n                    name,\n                    profile,\n                    color\n                },\n                {\n                    responseType: \\\"arraybuffer\\\",\n                    headers: {\n                        \\\"Content-Type\\\": \\\"application/json\\\"\n                    }\n                }\n            );\n\n            const buffer = Buffer.from(res.data);\n\n            // ===============================\n            // KIRIM STICKER\n            // ===============================\n           \n                await kuromi.sendSticker(\n                    m.chat,\n                    buffer,\n                    m,\n                    { packname, author, expiration: m.expiration }\n                );\n           \n\n        } catch (err) {\n            console.log(err);\n            kuromi.reply(m.chat, err.message, m, { expiration: m.expiration });\n        }\n    }\n};",
      "time": "2025-12-27 01:48:08"
    },
    {
      "path": "plugins/convert/quickchat.js",
      "code": "/* CODE LAIN CHEK\nhttps://whatsapp.com/channel/0029VbARSvBCMY0PDV53rt0m\nJANGAN LUPA FOLLOW\n*/\n\n/* CODE LAIN CHEK\nhttps://whatsapp.com/channel/0029VbARSvBCMY0PDV53rt0m\nJANGAN LUPA FOLLOW\n*/\n\n// CREATE BY REZA DEVS KUROMI (UPDATED NEKOLABS)\n\nconst axios = require(\\\"axios\\\");\n\nexports.run = {\n    usage: [\\\"quickchat\\\", \\\"quickchat2\\\", \\\"quickchat3\\\", \\\"quickchat4\\\"],\n    hidden: [\\\"qc\\\", \\\"qc2\\\", \\\"qc3\\\", \\\"qc4\\\"],\n    use: \\\"text / reply text\\\",\n    category: \\\"convert\\\",\n    restrict: true,\n    limit: true,\n    location: \\\"plugins/convert/quickchat.js\\\",\n\n    async: async (m, { kuromi, func, packname, author }) => {\n\n        let text;\n        if (m.args.length) {\n            text = m.args.join(\\\" \\\");\n        } else if (m.quoted?.text) {\n            text = m.quoted.text;\n        }\n\n        if (!text)\n            return m.reply(\\\"Input atau reply text!\\\");\n\n        if (text.length > 50)\n            return m.reply(\\\"Max 50 character!\\\");\n\n        kuromi.sendReact(m.chat, \\\"ðŸ•’\\\", m.key);\n\n        // ===============================\n        // WARNA BERDASARKAN COMMAND\n        // ===============================\n        let color = \\\"#333\\\";\n        if (/^(quickchat|qc)$/.test(m.command)) color = \\\"#CCFFFF\\\";\n        if (/^(quickchat2|qc2)$/.test(m.command)) color = \\\"#000000\\\";\n        if (/^(quickchat3|qc3)$/.test(m.command)) color = \\\"#999999\\\";\n        if (/^(quickchat4|qc4)$/.test(m.command)) color = \\\"#FF9999\\\";\n\n        try {\n            // ===============================\n            // DATA USER\n            // ===============================\n            const sender = m.quoted?.sender || m.sender;\n            const name = m.quoted\n                ? global.db.users[sender]?.name || m.pushname\n                : m.pushname;\n\n            const profile = await kuromi\n                .profilePictureUrl(sender, \\\"image\\\")\n                .catch(() => \\\"https://api.nekolabs.web.id/ali-oss/v1/example.jpg\\\");\n\n            // ===============================\n            // REQUEST KE NEKOLABS\n            // ===============================\n            const res = await axios.post(\n                \\\"https://api.nekolabs.web.id/canvas/quote-chat\\\",\n                {\n                    text,\n                    name,\n                    profile,\n                    color\n                },\n                {\n                    responseType: \\\"arraybuffer\\\",\n                    headers: {\n                        \\\"Content-Type\\\": \\\"application/json\\\"\n                    }\n                }\n            );\n\n            const buffer = Buffer.from(res.data);\n\n            // ===============================\n            // KIRIM STICKER\n            // ===============================\n           \n                await kuromi.sendSticker(\n                    m.chat,\n                    buffer,\n                    m,\n                    { packname, author, expiration: m.expiration }\n                );\n           \n\n        } catch (err) {\n            console.log(err);\n            kuromi.reply(m.chat, err.message, m, { expiration: m.expiration });\n        }\n    }\n};",
      "time": "2025-12-27 12:40:03"
    },
    {
      "path": "plugins/ai/telanjangin.js",
      "code": "/* \n FITUR: LIVE3D (DEEPNUDE/CLOTH REMOVER)\n BASE: https://live3d.io/\n AUTHOR: Shannz (Converted to Kuromi Plugin)\n*/\n\nconst axios = require(\\\"axios\\\");\nconst FormData = require(\\\"form-data\\\");\nconst crypto = require(\\\"crypto\\\");\nconst { fromBuffer } = require(\\\"file-type\\\");\n\n/* ================= CONFIGURATION ================= */\nconst CONFIG = {\n    BASE_URL: 'https://app.live3d.io',\n    CDN_URL: 'https://temp.live3d.io/',\n    ENDPOINTS: {\n        UPLOAD: '/aitools/upload-img',\n        CREATE: '/aitools/of/create',\n        STATUS: '/aitools/of/check-status'\n    },\n    SECRETS: {\n        FP: '78dc286eaeb7fb88586e07f0d18bf61b',\n        APP_ID: 'aifaceswap',\n        PUBLIC_KEY: `-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCwlO+boC6cwRo3UfXVBadaYwcX\n0zKS2fuVNY2qZ0dgwb1NJ+/Q9FeAosL4ONiosD71on3PVYqRUlL5045mvH2K9i8b\nAFVMEip7E6RMK6tKAAif7xzZrXnP1GZ5Rijtqdgwh+YmzTo39cuBCsZqK9oEoeQ3\nr/myG9S+9cR5huTuFQIDAQAB\n-----END PUBLIC KEY-----`\n    },\n    HEADERS: {\n        'User-Agent': 'Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Mobile Safari/537.36',\n        'Accept': 'application/json, text/plain, */*',\n        'sec-ch-ua-platform': '\\\"Android\\\"',\n        'theme-version': '83EmcUoQTUv50LhNx0VrdcK8rcGexcP35FcZDcpgWsAXEyO4xqL5shCY6sFIWB2Q',\n        'origin': 'https://live3d.io',\n        'referer': 'https://live3d.io/',\n        'priority': 'u=1, i'\n    }\n};\n\n/* ================= UTILITIES ================= */\nconst utils = {\n    genHex: (bytes) => crypto.randomBytes(bytes).toString('hex'),\n\n    genRandomString: (length) => {\n        const chars = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\\\";\n        let result = \\\"\\\";\n        for (let i = 0; i < length; i++) result += chars.charAt(Math.floor(Math.random() * chars.length));\n        return result;\n    },\n\n    aesEncrypt: (plaintext, keyStr, ivStr) => {\n        const key = Buffer.from(keyStr, 'utf8');\n        const iv = Buffer.from(ivStr, 'utf8');\n        const cipher = crypto.createCipheriv('aes-128-cbc', key, iv);\n        let encrypted = cipher.update(plaintext, 'utf8', 'base64');\n        encrypted += cipher.final('base64');\n        return encrypted;\n    },\n\n    rsaEncrypt: (data) => {\n        const buffer = Buffer.from(data, 'utf8');\n        const encrypted = crypto.publicEncrypt({\n            key: CONFIG.SECRETS.PUBLIC_KEY,\n            padding: crypto.constants.RSA_PKCS1_PADDING,\n        }, buffer);\n        return encrypted.toString('base64');\n    },\n\n    generateHeaders: () => {\n        const aesKey = utils.genRandomString(16);\n        const xCode = Date.now().toString();\n        const xGuide = utils.rsaEncrypt(aesKey);\n        const plaintextFp = `${CONFIG.SECRETS.APP_ID}:${CONFIG.SECRETS.FP}`;\n        const fp1 = utils.aesEncrypt(plaintextFp, aesKey, aesKey);\n\n        return {\n            ...CONFIG.HEADERS,\n            'x-code': xCode,\n            'x-guide': xGuide,\n            'fp': CONFIG.SECRETS.FP,\n            'fp1': fp1\n        };\n    }\n};\n\n/* ================= MAIN FUNCTION ================= */\nconst live3d = {\n    generate: async (imageBuffer) => {\n        const originFrom = utils.genHex(8);\n        const requestFrom = 9;\n\n        try {\n            // Validasi buffer\n            if (!imageBuffer) throw new Error(\\\"Buffer gambar kosong.\\\");\n\n            // Deteksi tipe mime\n            const mime = await fromBuffer(imageBuffer);\n            const filename = `upload.${mime ? mime.ext : 'jpg'}`;\n\n            console.log(`\\n=== Live3D Generator [Hex: ${originFrom}] ===`);\n            process.stdout.write(`[1/3] Uploading image... `);\n\n            // Persiapan Form Data\n            const form = new FormData();\n            // Append buffer langsung, bukan read stream dari file path\n            form.append('file', imageBuffer, { filename: filename });\n            form.append('fn_name', 'cloth-change');\n            form.append('request_from', requestFrom.toString());\n            form.append('origin_from', originFrom);\n\n            const uploadHeaders = { ...utils.generateHeaders(), ...form.getHeaders() };\n\n            // Upload\n            const uploadRes = await axios.post(CONFIG.BASE_URL + CONFIG.ENDPOINTS.UPLOAD, form, { headers: uploadHeaders });\n            let serverPath = uploadRes.data?.data;\n            if (typeof serverPath === 'object' && serverPath.path) serverPath = serverPath.path;\n\n            if (!serverPath) throw new Error(\\\"Gagal mendapatkan path server.\\\");\n            console.log(`Done.`);\n\n            // Submit Task\n            process.stdout.write(`[2/3] Submitting task... `);\n\n            const submitPayload = {\n                \\\"fn_name\\\": \\\"cloth-change\\\",\n                \\\"call_type\\\": 3,\n                \\\"input\\\": {\n                    \\\"source_image\\\": serverPath,\n                    \\\"prompt\\\": \\\"best quality, naked, nude\\\",\n                    \\\"cloth_type\\\": \\\"full_outfits\\\",\n                    \\\"request_from\\\": requestFrom,\n                    \\\"type\\\": 1\n                },\n                \\\"request_from\\\": requestFrom,\n                \\\"origin_from\\\": originFrom\n            };\n\n            const submitRes = await axios.post(CONFIG.BASE_URL + CONFIG.ENDPOINTS.CREATE, submitPayload, {\n                headers: { ...utils.generateHeaders(), 'Content-Type': 'application/json' }\n            });\n\n            const taskId = submitRes.data?.data?.task_id;\n            if (!taskId) throw new Error(\\\"Gagal mendapatkan Task ID.\\\");\n            console.log(`Done (ID: ${taskId})`);\n\n            // Polling Status\n            let isCompleted = false;\n            let attempts = 0;\n            let resultUrl = null;\n            const maxAttempts = 40;\n\n            while (!isCompleted && attempts < maxAttempts) {\n                attempts++;\n                await new Promise(r => setTimeout(r, 3000));\n\n                const statusPayload = {\n                    \\\"task_id\\\": taskId,\n                    \\\"fn_name\\\": \\\"cloth-change\\\",\n                    \\\"call_type\\\": 3,\n                    \\\"consume_type\\\": 0,\n                    \\\"request_from\\\": requestFrom,\n                    \\\"origin_from\\\": originFrom\n                };\n\n                const statusRes = await axios.post(CONFIG.BASE_URL + CONFIG.ENDPOINTS.STATUS, statusPayload, {\n                    headers: { ...utils.generateHeaders(), 'Content-Type': 'application/json' }\n                });\n\n                const data = statusRes.data?.data;\n                if (!data) continue;\n\n                const status = data.status;\n\n                process.stdout.clearLine();\n                process.stdout.cursorTo(0);\n\n                if (status === 2) {\n                    resultUrl = data.result_image;\n                    if (resultUrl && !resultUrl.startsWith('http')) {\n                        resultUrl = CONFIG.CDN_URL + resultUrl;\n                    }\n                    process.stdout.write(`[3/3] Status: Success!\\n`);\n                    isCompleted = true;\n                } else if (status === 1) {\n                    const dots = \\\".\\\".repeat((attempts % 3) + 1);\n                    process.stdout.write(`[3/3] Status: Generating${dots} `);\n                } else {\n                    process.stdout.write(`[3/3] Status: Queue (Rank ${data.rank})... `);\n                }\n            }\n\n            if (!resultUrl) throw new Error(\\\"Timeout generating image.\\\");\n\n            console.log(`\\n[RESULT] ${resultUrl}\\n`);\n            return resultUrl;\n\n        } catch (error) {\n            console.log(`\\n[X] Error: ${error.message}`);\n            if (error.response) console.log(`    Server Msg: ${JSON.stringify(error.response.data)}`);\n            throw error; // Re-throw agar ditangkap di handler\n        }\n    }\n};\n\n/* ================= PLUGIN EXPORT ================= */\nexports.run = {\n    usage: [\\\"deepnude\\\", \\\"live3d\\\", \\\"telanjangin\\\"], // Nama command\n    use: \\\"reply/kirim gambar\\\",                // Cara pakai\n    category: \\\"ai\\\",                           // Kategori menu\n    async: async (m, { kuromi, quoted }) => {\n        try {\n            // Validasi Input: Pastikan user mereply gambar\n            if (!quoted || !/image/.test(quoted.mime)) {\n                return m.reply(\\\"Reply atau kirim gambar dengan command untuk memproses.\\\");\n            }\n\n            // Kirim reaksi loading\n            kuromi.sendReact(m.chat, \\\"ðŸ•’\\\", m.key);\n            m.reply(\\\"Memproses gambar, ini mungkin memakan waktu...\\\");\n\n            /* ================= DOWNLOAD IMAGE ================= */\n            const buffer = await quoted.download();\n            if (!buffer) throw new Error(\\\"Gagal mendownload gambar.\\\");\n\n            /* ================= PROCESS TO LIVE3D ================= */\n            // Panggil fungsi generate dengan buffer\n            const resultUrl = await live3d.generate(buffer);\n\n            /* ================= SEND RESULT ================= */\n            await kuromi.sendMessage(\n                m.chat,\n                {\n                    image: { url: resultUrl },\n                    caption: `âœ¨ *LIVE3D SUCCESS*\\n` +\n                             `ðŸ”ž Fitur : Cloth Remover\\n` +\n                             `â± Status : Completed`\n                },\n                { quoted: m }\n            );\n\n            // Ubah reaksi jadi sukses\n            kuromi.sendReact(m.chat, \\\"âœ…\\\", m.key);\n\n        } catch (e) {\n            console.error(e);\n            kuromi.sendReact(m.chat, \\\"âŒ\\\", m.key);\n            \n            // Pesan error yang lebih user-friendly\n            const errMsg = e.response ? JSON.stringify(e.response.data) : e.message;\n            m.reply(`âŒ Gagal memproses gambar.\\n\\nServer mungkin sedang penuh atau gambar tidak didukung.\\n\\nDetail Error: ${errMsg}`);\n        }\n    },\n    location: \\\"plugins/ai/telanjangin.js\\\",\npremium: true \n};",
      "time": "2026-01-04 09:11:25"
    }
  ],
  "remove": [],
  "version": "1.30"
}